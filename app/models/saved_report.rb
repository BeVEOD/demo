# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Sun Oct 20 00:13:11 +0200 2013
## It should be placed at 'app/models/saved_report.rb'
## All manual modifications will be destroyed on next generation
################################################


class SavedReport < ActiveRecord::Base

  self.table_name = 'saved_reports'

  SEARCHABLE_FIELDS = [:name,:created_at].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:name => :string, :created_at => :datetime, :url => :string, :data => :text).freeze
  COMPARATORS = {:name => ActiveSupport::OrderedHash['=~', ["saved_reports.name LIKE ?", '%%%s%'], '!~', ["saved_reports.name NOT LIKE ?", '%%%s%'], '^=', ["saved_reports.name LIKE ?", '%s%'], '$=', ["saved_reports.name LIKE ?", '%%%s'], '=', ["saved_reports.name = ?"], '!=', ["saved_reports.name <> ?"], 'NULL', ["saved_reports.name IS NULL", ''], 'NOT_NULL', ["saved_reports.name IS NOT NULL", '']],
    :created_at => ActiveSupport::OrderedHash['=', ["saved_reports.created_at = ?"], '!=', ["saved_reports.created_at <> ?"], '>', ["saved_reports.created_at > ?"], '<', ["saved_reports.created_at < ?"], '>=', ["saved_reports.created_at >= ?"], '<=', ["saved_reports.created_at <= ?"]],
    :created_at_min => ActiveSupport::OrderedHash['>=', ["saved_reports.created_at >= ?"], '>', ["saved_reports.created_at > ?"]],
    :created_at_max => ActiveSupport::OrderedHash['<=', ["saved_reports.created_at <= ?"], '<', ["saved_reports.created_at < ?"]],
    :url => ActiveSupport::OrderedHash['=~', ["saved_reports.url LIKE ?", '%%%s%'], '!~', ["saved_reports.url NOT LIKE ?", '%%%s%'], '^=', ["saved_reports.url LIKE ?", '%s%'], '$=', ["saved_reports.url LIKE ?", '%%%s'], '=', ["saved_reports.url = ?"], '!=', ["saved_reports.url <> ?"], 'NULL', ["saved_reports.url IS NULL", ''], 'NOT_NULL', ["saved_reports.url IS NOT NULL", '']],
  :data => ActiveSupport::OrderedHash['=~', ["saved_reports.data LIKE ?", '%%%s%'], '!~', ["saved_reports.data NOT LIKE ?", '%%%s%'], '^=', ["saved_reports.data LIKE ?", '%s%'], '$=', ["saved_reports.data LIKE ?", '%%%s'], '=', ["saved_reports.data = ?"], '!=', ["saved_reports.data <> ?"], 'NULL', ["saved_reports.data IS NULL", ''], 'NOT_NULL', ["saved_reports.data IS NOT NULL", '']]}.freeze

  FILES_DEST = Rails.root.join('files', %q{saved_reports}).to_s


  # == Validations



  # == Triggers



  # == Relations
  #
  # Associations through specific setters
  #
  # Virtual Fields
  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-09-03 16:56:08 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return SavedReport.new if att.blank?
    std_atts = att.reject{|k,v| %w(id).include?(k.to_s) }
    saved_report = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      saved_report = SavedReport.find(att[:id])
      saved_report.attributes = std_atts
    else
      saved_report = SavedReport.new(std_atts)
    end

    # clean associations
    #clean binaries
    #clean serialized data

    return saved_report
  end


  # The disp_name is how any record will appear in most use cases, such as lists of associated records during 'show', 'list'...
  #
  # Faveod will try to guess the best single field, based on SID, usually from fields containing "Title", "Name" or "Label".
  #
  # Customized code often will often look like these snippets:
  # Multiple key: "#{self.first_name} #{self.last_name}"
  # Date or time: "#{self.name} #{self.created_at.strftime('%H:%M %y-%m-%d') if self.created_at}"
  # Associations: "#{self.name} #{self.user ? self.user.disp_name : _('No user')}"
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2011-05-31 17:21:54 UTC
  # Status:: Validated


  def disp_name
    self.name || ''
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      SavedReport.new.params_to_attributes(values).each { |k,v|
        case k.to_sym
        when :name
          cmp = comps["comp_name"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :name : "name_#{string_h[cmp]}"
          cond[field] = val
        when :created_at
          cmp = comps["comp_created_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :created_at : "created_at_#{date_h[cmp]}"
          cond[field] = val
        end
      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = SavedReport.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.savedreport_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    SavedReport.first(:order => 'saved_reports.id DESC', :conditions => ["saved_reports.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    SavedReport.first(:order => 'saved_reports.id', :conditions => ["saved_reports.id > ?", self.id])
  end

  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-11-01 16:01:43 UTC


  def self.named_scope_default_scope_method

    {}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      if [:name, :created_at, :url, :data
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })

def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs
if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics
# BINARIES CONSTANTS


end
