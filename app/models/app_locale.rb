# -*- encoding : utf-8 -*-
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##############
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Tue Apr 02 23:20:35 +0200 2013
## It should be placed at 'app/models/app_locale.rb'
## All manual modifications will be destroyed on next generation
################################################


class AppLocale < ActiveRecord::Base

  self.table_name = 'app_locales'

  SEARCHABLE_FIELDS = [].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:locale_code => :string, :po => :binary, :updated_at => :datetime).freeze
  COMPARATORS = {:locale_code => ActiveSupport::OrderedHash['=~', ["app_locales.locale_code LIKE ?", '%%%s%'], '!~', ["app_locales.locale_code NOT LIKE ?", '%%%s%'], '^=', ["app_locales.locale_code LIKE ?", '%s%'], '$=', ["app_locales.locale_code LIKE ?", '%%%s'], '=', ["app_locales.locale_code = ?"], '!=', ["app_locales.locale_code <> ?"], 'NULL', ["app_locales.locale_code IS NULL", ''], 'NOT_NULL', ["app_locales.locale_code IS NOT NULL", '']],
    :po => ActiveSupport::OrderedHash['=~', ["app_locales.po__name LIKE ?", '%%%s%'], '!~', ["app_locales.po__name NOT LIKE ?", '%%%s%'], '^=', ["app_locales.po__name LIKE ?", '%s%'], '$=', ["app_locales.po__name LIKE ?", '%%%s'], '=', ["app_locales.po__name = ?"], '!=', ["app_locales.po__name <> ?"], 'NULL', ["app_locales.po__name IS NULL", ''], 'NOT_NULL', ["app_locales.po__name IS NOT NULL", '']],
    :updated_at => ActiveSupport::OrderedHash['=', ["app_locales.updated_at = ?"], '!=', ["app_locales.updated_at <> ?"], '>', ["app_locales.updated_at > ?"], '<', ["app_locales.updated_at < ?"], '>=', ["app_locales.updated_at >= ?"], '<=', ["app_locales.updated_at <= ?"]],
    :updated_at_min => ActiveSupport::OrderedHash['>=', ["app_locales.updated_at >= ?"], '>', ["app_locales.updated_at > ?"]],
  :updated_at_max => ActiveSupport::OrderedHash['<=', ["app_locales.updated_at <= ?"], '<', ["app_locales.updated_at < ?"]]}.freeze
  DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6"
  USER_AGENTS = ["Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6",
    "Mozilla/5.0 (compatible; Konqueror/2.2.2; Linux 2.4.14-xfs; X11; i686)",
    "Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20021219 Chimera/0.6",
    "Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.0.1) Gecko/20030306 Camino/0.7",
    "Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-US) AppleWebKit/xx (KHTML like Gecko) OmniWeb/v5xx.xx",
    "W3CLineMode/5.4.0 libwww/5.x.x",
    "Lynx/2.8.4rel.1 libwww-FM/2.14 SSL-MM/1.4.1 OpenSSL/0.9.6c",
    "Links (0.9xpre12; Linux 2.2.14-5.0 i686; 80x24)",
    "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3) Gecko/20090305 Firefox/3.1b3 GTB5",
    "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; ko; rv:1.9.1b2) Gecko/20081201 Firefox/3.1b2",
    "Mozilla/5.0 (X11; U; SunOS sun4u; en-US; rv:1.9b5) Gecko/2008032620 Firefox/3.0b5",
    "Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.8.1.12) Gecko/20080214 Firefox/2.0.0.12",
    "Mozilla/5.0 (Windows; U; Windows NT 5.1; cs; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.8",
    "Mozilla/5.0 (X11; U; OpenBSD i386; en-US; rv:1.8.0.5) Gecko/20060819 Firefox/1.5.0.5",
    "Mozilla/5.0 (Windows; U; Windows NT 5.0; es-ES; rv:1.8.0.3) Gecko/20060426 Firefox/1.5.0.3",
    "Mozilla/5.0 (Windows; U; WinNT4.0; en-US; rv:1.7.9) Gecko/20050711 Firefox/1.0.5",
    "Mozilla/4.0 (compatible; MSIE 5.0; Windows NT;)",
    "Mozilla/4.0 (Windows; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)",
    "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; GTB5; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; InfoPath.2; OfficeLiveConnector.1.3; OfficeLivePatch.0.0)",
    "Mozilla/4.0 (Mozilla/4.0; MSIE 7.0; Windows NT 5.1; FDM; SV1; .NET CLR 3.0.04506.30)",
    "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; .NET CLR 2.0.50727)"
  ]

  FILES_DEST = Rails.root.join('files', %q{app_locales}).to_s


  # == Validations


  validates_presence_of(:locale_code)
  validates_uniqueness_of(:locale_code)


  # == Triggers


  after_save(:copy_po_file)

  after_create :po__after_create_trigger

  after_update :po__after_update_trigger

  after_destroy :po__after_destroy_trigger

  # == Relations
  #
  # Associations through specific setters
  #
  # Virtual Fields
  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-03-22 09:46:46 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return AppLocale.new if att.blank?
    std_atts = att.reject{|k,v| %w(id po po_tmp po_name).include?(k.to_s) }
    app_locale = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      app_locale = AppLocale.find(att[:id])
      app_locale.attributes = std_atts
    else
      app_locale = AppLocale.new(std_atts)
    end

    # clean associations
    #clean binaries
    ## clean binaries

    val = att[:po]
    if val
      if val == '_destroy'
        app_locale.po__name = nil
        app_locale.po = nil
      elsif val == '_forget'
      elsif val.size == 0
        att.delete(:po)
      else
        app_locale.po__name = File.basename(val.original_filename).parameterize.sub(/(-)(\w+)\Z/, '.\2')
        app_locale.po = val.read
      end
    else
      if !att[:po_tmp].blank? && !att[:po_name].blank?
        app_locale.po__name         = att[:po_name]
        app_locale.po__cache[:name] = att[:po_name]
        app_locale.po__cache[:tmp]  = att[:po_tmp]
      end
    end

    return app_locale
  end


  # The disp_name is how any record will appear in most use cases, such as lists of associated records during 'show', 'list'...
  #
  # Faveod will try to guess the best single field, based on SID, usually from fields containing "Title", "Name" or "Label".
  #
  # Customized code often will often look like these snippets:
  # Multiple key: "#{self.first_name} #{self.last_name}"
  # Date or time: "#{self.name} #{self.created_at.strftime('%H:%M %y-%m-%d') if self.created_at}"
  # Associations: "#{self.name} #{self.user ? self.user.disp_name : _('No user')}"
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2011-05-31 17:21:54 UTC
  # Status:: Validated


  def disp_name
    self.locale_code
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      AppLocale.new.params_to_attributes(values).each { |k,v|

      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Creates the thumbnail and returns it.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2013-02-04 15:16:10 UTC
  # Status:: Validated


  def thumbnail(sid, opts={})

    maxwidth	= (opts[:maxwidth] || 128).to_f
    maxheight	= (opts[:maxheight] || 128).to_f
    aspectratio	= maxwidth / maxheight
    path		= nil
    dest_path	= nil
    pic		= nil
    case sid.to_sym
    when :po
      path		= self.po__path
      dest_path	= self.po__thumb_path
    end
    pic	   = path ? Magick::Image.read(path).first : Magick::Image.from_blob(pic).first
    imgwidth  = pic.columns
    imgheight = pic.rows
    imgratio  = imgwidth.to_f / imgheight.to_f
    scaleratio= imgratio > aspectratio ? maxwidth / imgwidth : maxheight / imgheight
    thumb	   = pic.thumbnail(scaleratio)
    thumb.write(dest_path) if dest_path
    return thumb.to_blob
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = AppLocale.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.applocale_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    AppLocale.first(:order => 'app_locales.id DESC', :conditions => ["app_locales.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    AppLocale.first(:order => 'app_locales.id', :conditions => ["app_locales.id > ?", self.id])
  end

  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-11-01 16:01:43 UTC


  def self.named_scope_default_scope_method

    {}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      if [:locale_code, :po, :updated_at
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })


# Returns managed locales
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2010-01-20 17:33:59 UTC
# Status:: Validation Pending


def self.app_locales
GSS[:locales] ? GSS[:locales].split(' ') : %w(en fr)
end


# Available locales.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2010-06-16 14:34:53 UTC
# Status:: Validated


def locale_code__potential_values
AppLocale.app_locales
end


# Translations: copies PO file to the right path.
#
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:26:44 UTC
# Status:: Validation Pending


def copy_po_file
dest_path = Rails.root.join('po', self.locale_code.to_s, "#{APP_SID}.po")
FileUtils.cp(self.po__path, dest_path) if self.po__name
self.po_to_yml
end


# Translations: stores a PO file in YAML.
#
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:27:11 UTC
# Status:: Should be optimized


def po_to_yml
AppLocale.po_files(self.locale_code).each do |t|
  @trans_file = File.basename(t)
  @gettext_trans = true
  @gettext_untrans = @gettext_fuzzy = @gettext_obsol = false
  @translation = self.gettext_fct("trans")[:translation]
  @translation.each do |file, data|
    yml_gettext = Rails.root.join('po', self.locale_code, "#{file}_trans.yml")
    File.open(yml_gettext, "w+") do |f|
      YAML.dump(data.inject({}) {|acc,v| acc[v[0]] = v[1] ; acc}, f)
    end
  end
  @gettext_untrans = true
  @gettext_trans = @gettext_fuzzy = @gettext_obsol = false
  @translation = self.gettext_fct("untrans")[:translation]
  @translation.each do |file, data|
    yml_gettext = Rails.root.join('po', self.locale_code, file + '_' + 'untrans.yml')
    File.open(yml_gettext, "w+") do |f|
      YAML.dump(data.inject({}) {|acc,v| acc[v[0]] = v[1] ; acc}, f)
    end
  end
  @gettext_fuzzy = true
  @gettext_untrans = @gettext_trans = @gettext_obsol = false
  @translation = self.gettext_fct("fuzzy")[:translation]
  @translation.each do |file, data|
    yml_gettext = Rails.root.join('po', self.locale_code, file + '_' + 'fuzzy.yml')
    File.open(yml_gettext, "w+") do |f|
      YAML.dump(data.inject({}) {|acc,v| acc[v[0]] = v[1] ; acc}, f)
    end
  end
  @gettext_obsol = true
  @gettext_untrans = @gettext_trans = @gettext_fuzzy = false
  @translation = self.gettext_fct("obsol")[:translation]
  @translation.each do |file, data|
    yml_gettext = Rails.root.join('po', self.locale_code, file + '_' + 'obsol.yml')
    File.open(yml_gettext, "w+") do |f|
      YAML.dump(data.inject({}) {|acc,v| acc[v[0]] = v[1] ; acc}, f)
    end
  end
end
end


# Translations: extracts PO data from a YAML file.
#
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:27:21 UTC
# Status:: Validation Pending


def yml_to_po
Dir.glob(Rails.root.join('po', self.locale_code, '*.po')).each do |t|
  @trans_file = File.basename(t)
  my_file = Rails.root.join('po', self.locale_code, "#{@trans_file}_trans.yml")
  msgid	  = { @trans_file => {} }
  if File.exist? my_file
    msgid_temp = YAML.load(File.open(my_file, 'r'))
    if msgid_temp
      msgid_temp.each do |l, ldata|
        mmsgid = l.gsub(/\n/, "\\n").gsub(/\r/,'')
        msgid[@trans_file][mmsgid] = ldata.gsub(/\r/,'')
      end
    end
    self.generate_po_files(msgid)
  end
end
end


# Translations: generates PO file from stored format.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-02-27 11:06:28 UTC
# Status:: Validation Pending


def generate_po_files(msgids)
msgids.each do |f, fdata|
  pot_file = Rails.root.join('tmp', "tmp_#{f}_#{self.locale_code}.pot")
  po_file  = Rails.root.join('po', self.locale_code, f)
  tmp_file = Rails.root.join('tmp', "tmp_#{f}")
  File.open(tmp_file, "w+") do |filetmp|
    filetmp.puts IO.readlines(po_file).reject{|line| line =~ /\A#~/ }
  end
  File.open(pot_file, "w+") do |file|
    file.puts GetText::RGetText.generate_pot(fdata.keys.sort.map{|t| [t]})
  end
  data = fdata.map {|t, tdata| [t, tdata] }.sort{|x, y| x[0] <=> y[0]}
  i = 0
  lines =  IO.readlines(pot_file).map do |line|
    if line !~ /\Amsgstr/
      line
    else
      if data[0] && data[0][0] !~ /\000/ && tdata = data.shift
        line = "msgstr #{tdata[1].inspect}\n"
      else
        line = "msgstr[#{i}] #{data[0][1].split("\000")[i].inspect}\n"
        i += 1
        if !data[0][1].split("\000")[i] && tdata = data.shift && i = 0
        end
      end
      line
    end
  end
  File.open(pot_file, "w+") do |file|
    file.puts GetText::RGetText.generate_pot_header
    lines.each do |line|
      file.puts line
    end
  end
  GetText.msgmerge(pot_file, tmp_file, "#{APP_SID} #{APP_VERSION}", {:msgmerge => :no_fuzzy_matching})
  FileUtils.remove(tmp_file)
  File.open(pot_file, "a+") do |filetmp|
    if !lines.empty?
      if (upto = File.open(po_file, 'r').readlines.index {|x| x =~ /\A#~/})
        0.upto(upto - 3) do |j|
          lines.shift
        end
        filetmp.write lines
      end
    end
  end
  FileUtils.move(pot_file, po_file)
end
end


# Translations: PO file management.
#
# Author:: Yann Azoury
# Version:: 9
# Last Update:: 2013-02-27 11:07:34 UTC
# Status:: Should be optimized


def gettext_fct(type, params = {})

# require 'gettext/poparser'

require 'gettext/tools'
res = {:translation => {}, :md5 => {}}
case type
when "trans"
  @gettext_trans = true
when "untrans"
  @gettext_untrans = true
when "fuzzy"
  @gettext_fuzzy = true
when "obsol"
  @gettext_obsol = true
end
AppLocale.po_files(self.locale_code).each do |t|
  @trans_file = File.basename(t)
  @translation ||= {}
  @md5 ||= {}
  source_file = Rails.root.join('po', self.locale_code, @trans_file)
  if File.exist? source_file
    to_parse = GetText::PoParser.new
    data = GetText::MOFile.new
    data_with_fuzzy = GetText::MOFile.new
    @translation[@trans_file] ||= {}
    @translation[@trans_file][self.locale_code] ||= {}
    file = Rails.root.join("tmp/tmp_#{self.locale_code}_#{@trans_file}")
    if @gettext_obsol
      lines = File.open(source_file, 'r').readlines
      File.open(file, "w+") { |f| f.puts GetText::RGetText.generate_pot_header }
      if !lines.empty?
        if (upto = lines.index {|x| x =~ /\A#~/})
          File.open(file, "a+") do |filetmp|
            0.upto(upto - 1) do |j|
              lines.shift
            end
            lines.each do |cur_line|
              filetmp.puts cur_line.gsub(/\A#~ /, "")
            end
          end
        end
      end
    end
    if @gettext_obsol
      FileUtils.move(file, file + "_tmp")
      source_file = file + "_tmp"
    end
    File.open(file, "w+") do |filetmp|
      filetmp.puts IO.readlines(source_file).map{ |line|
        if ! @gettext_trans
          line.gsub(/msgstr \"\"/, "msgstr \"DUMMY_MSGSTR\"")
        else
          line
        end
      }
    end
    to_parse.parse_file(file, data, true)
    to_parse.parse_file(file, data_with_fuzzy, false) if @gettext_fuzzy || @gettext_obsol
    FileUtils.remove(file)
    FileUtils.remove(source_file) if @gettext_obsol
    @translation[@trans_file] = data if @gettext_trans || @gettext_untrans
    @translation[@trans_file] = data_with_fuzzy.diff(data) if @gettext_fuzzy
    @translation[@trans_file] = data_with_fuzzy if @gettext_obsol
    filter = params && params[:filters] && params[:filters][:msgid] ? Regexp.new(params[:filters][:msgid]) : nil
    @translation.each do |file, fdata|
      @translation[file].delete("")
      fdata.each do |msgid, trans|
        @translation[file][msgid] = trans.gsub(/DUMMY_MSGSTR/, "")
        @translation[file].delete(msgid) and next if filter && msgid !~ filter
        @translation[file].delete(msgid) if @gettext_untrans && trans != "DUMMY_MSGSTR"
        @md5[file]  = Base64.encode64("#{file}").gsub(/\n/,'').gsub(/=/,'!') unless @md5[file]
        @md5[msgid] = Base64.encode64("#{msgid}").gsub(/\n/,'').gsub(/=/,'!') unless @md5[msgid]
      end
    end
  end
  res[:translation].merge!(@translation)
  res[:md5].merge!(@md5)
end
return res
end


# WARNING: DEPRECATED!
# Translations: process PO files with BackgrounDRb
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Sylvain Abélard
# Version:: 5
# Last Update:: 2010-06-16 14:38:15 UTC
# Status:: Deprecated


def self.updatepo_status_deprecated

logger.warn("Warning: Executing deprecated method 'updatepo_status_deprecated' from AppLocale")
if BgWorker.bgdrb_connected?
  sleep 5
  MiddleMan.all_worker_info.each do |w, tab|
    if !tab.nil?
      tab.each { |data|
        return true if data[:worker] == :po_update_worker
      }
    end
  end
end
return false
end


# Translations: initializer.
#
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:27:35 UTC
# Status:: Validation Pending


def init_po
pot_file = Rails.root.join('po', "#{APP_SID}.pot")
po_dir	 = Rails.root.join('po', self.locale_code)
FileUtils.mkdir(po_dir) if !File.exists?(po_dir)
po_file  = Rails.root.join('po', self.locale_code, "#{APP_SID}.po")
FileUtils.cp(pot_file, po_file) if !File.exists?(po_file)
end


# Translations: initializing POT files.
#
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:27:48 UTC
# Status:: Validation Pending


def self.init_pot
pot_file = Rails.root.join('po', "#{APP_SID}.pot")
if !File.exists?(pot_file)
  @translation ||= {}
  Dir.glob(Rails.root.join('po', '**', '*.{po}')).each do |file|
    to_parse = GetText::PoParser.new
    data = GetText::MOFile.new
    @translation = to_parse.parse_file(file, data, true)
  end
  File.open(pot_file, "w+") do |filetmp|
    filetmp.puts GetText::RGetText.generate_pot_header
    filetmp.puts GetText::RGetText.generate_pot(@translation.keys.sort.map{|t| [t]})
  end
end
end


# Translations: get translations' counts.
#
# Author:: Yann Azoury
# Version:: 7
# Last Update:: 2013-03-31 21:28:13 UTC
# Status:: Should be optimized


def count_total_element(type, filter = {})
count = 0
filter_count = 0
Dir.glob(Rails.root.join('po', self.locale_code, '*.po')).each do |t|
  trans_file = "#{File.basename(t)}_#{type}.yml"
  my_file = Rails.root.join('po', self.locale_code, trans_file)
  self.po_to_yml if !File.exist? my_file
  translation ||= {}
  if File.exist? my_file
    translation[trans_file] = YAML.load(File.open(my_file, 'r'))
    translation.each do |file, fdata|
      count += fdata.keys.count
      fdata.each {|k, d|
        filter_count += 1 if filter && k =~ filter
      }
    end
  end
end
count = "#{filter_count.to_s} / #{count.to_s}" if filter
return count
end


# Translations: get a translation.
#
# Author:: Sylvain Abélard
# Version:: 8
# Last Update:: 2010-06-16 14:40:55 UTC
# Status:: Should be optimized


def self.get_translation(text, to, from = "en")
dest_for_en ||= ['sq', 'de', 'en', 'ar', 'bg', 'ca', 'zh-CN', 'ko', 'hr', 'da', 'es', 'et', 'fi', 'fr', 'gl', 'el', 'iw', 'hi', 'hu', 'id', 'it', 'ja', 'lv', 'lt', 'mt', 'nl', 'no', 'pl', 'pt', 'ro', 'ru', 'sr', 'sk', 'sl', 'sv', 'tl', 'cs', 'th', 'tr', 'uk', 'vi', 'sq', 'de', 'en', 'ar', 'bg', 'ca', 'zh-CN', 'zh-TW', 'ko', 'hr', 'da', 'es', 'et', 'fi', 'fr', 'gl', 'el', 'iw', 'hi', 'hu', 'id', 'it', 'ja', 'lv', 'lt', 'mt', 'nl', 'no', 'pl', 'pt', 'ro', 'ru', 'sr', 'sk', 'sl', 'sv', 'tl', 'cs', 'th', 'tr', 'uk', 'vi']
capacities  ||= {'en' => dest_for_en}
return "" if to == from

# raise "Can't translate" if !dest_for_en.include?(to)

return "" unless capacities[from] && capacities[from].include?(to)
@uri ||= URI.parse("http://translate.google.com/translate_t")
@uri.query = URI.encode("langpair=#{from}|#{to}&text=#{text}")
timeout(10) do
  @doc = open(@uri.to_s, {"User-Agent" => AppLocale.user_agent(true)}) { |f| #randomize user-agent
    Hpricot(f)
  }
end

# raise "Google did not answer correctly" if @doc.nil?

return @doc ? (@doc/"#result_box").inner_text : nil
end


# Translations: prepare auto-translations.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-03-31 21:28:23 UTC
# Status:: Validation Pending


def auto_translate
@lang_file = self.locale_code
translation = self.gettext_fct_from_yml("untrans")[:translation]
translation.each do |file, fmsgid|
  fmsgid.each do |msgid, msgstr|
    translation[file][msgid] = AppLocale.get_translation(msgid, self.locale_code)
    sleep 2
  end
  my_file = Rails.root.join('po', @lang_file, file)
  msgid = {}
  msgid[file] = YAML.load(File.open(my_file, 'r'))
  translation[file].each do |mmsgid, msgstr|
    msgid[file].delete(mmsgid)
  end
  File.open(my_file, "w+") do |f|
    YAML.dump(msgid[file].inject({}) {|acc,v| acc[v[0]] = v[1] ; acc}, f)
  end
  my_file = my_file.gsub(/_(fuzzy|obsol|untrans).yml/, "_trans.yml")
  msgid[file] = YAML.load(File.open(my_file, 'r'))
  translation[file].each do |mmsgid, msgstr|
    msgid[file][mmsgid] = msgstr
  end
  File.open(my_file, "w+") do |f|
    YAML.dump(msgid[file].inject({}) {|acc,v| acc[v[0]] = v[1] ; acc}, f)
  end
end
end


# WARNING: DEPRECATED!
# Translations: BackgrounDRb status.
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Sylvain Abélard
# Version:: 5
# Last Update:: 2010-06-16 14:41:59 UTC
# Status:: Deprecated


def self.auto_translate_status_deprecated

logger.warn("Warning: Executing deprecated method 'auto_translate_status_deprecated' from AppLocale")
if BgWorker.bgdrb_connected?
  sleep 5
  MiddleMan.all_worker_info.each do |w, tab|
    if !tab.nil?
      tab.each { |data|
        return true if data[:worker] == :auto_translate_worker
      }
    end
  end
end
return false
end


#--
# DEPRECATED: this method would be removed
#++
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2010-01-22 17:40:19 UTC
# Status:: Deprecated


def auto_translate_hazardous_deprecated

logger.warn("Warning: Executing deprecated method 'auto_translate_hazardous_deprecated' from AppLocale")
separator = ".........."
msgids = []
translation = self.gettext_fct_from_yml("untrans")[:translation]
translation.each do |file, fmsgid|
  fmsgid.each do |msgid, msgstr|
    msgids << msgid
  end
end
res = []
(msgids.paginate(:page => 1, :per_page => 25).total_pages).times do |e|
  mi = msgids.paginate(:page => e + 1, :per_page => 25).join(" " + separator + " ")
  begin
    doc = AppLocale.get_translation(mi, self.locale_code)
  rescue
    logger.warn("Google did not answer correctly")
  end
  temp << (" " + separator + " ") unless e == 1
  temp << doc
  texts = doc.split(separator)
  if texts
    res = res + texts
  end
  sleep 10
end
i = 0
translation.each do |file, fmsgid|
  fmsgid.each do |msgid, msgstr|
    translation[file][msgid] = res[i]
    translation[file][msgid] = "" if translation[file][msgid].nil?
    i += 1
  end
end
return translation
end


# Translations: get data from YAML files.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-03-31 21:30:40 UTC
# Status:: Should be optimized


def gettext_fct_from_yml(type, params = {})
res = {:translation => {}, :md5 => {}}
case type
when "trans"
  @gettext_trans = true
when "untrans"
  @gettext_untrans = true
when "fuzzy"
  @gettext_fuzzy = true
when "obsol"
  @gettext_obsol = true
end
Dir.glob(Rails.root.join('po', self.locale_code, "*.po")).each do |t|
  @trans_file = File.basename(t)
  @trans_file += "_trans.yml" if @gettext_trans
  @trans_file += "_fuzzy.yml" if @gettext_fuzzy
  @trans_file += "_obsol.yml" if @gettext_obsol
  @trans_file += "_untrans.yml" if @gettext_untrans
  get_file = @trans_file
  my_file = Rails.root.join('po', self.locale_code, @trans_file)
  self.po_to_yml if !File.exist? my_file
  @trans_file = get_file
  @translation = nil
  @translation ||= {}
  @md5 ||= {}
  if File.exist? my_file
    @translation[@trans_file] ||= {}
    @translation[@trans_file] = YAML.load(File.open(my_file, 'r'))
    filter = params[:filters] && params[:filters][:msgid] ? Regexp.new(params[:filters][:msgid]) : nil
    @translation.each do |file, fdata|
      @md5[file] = Base64.encode64("#{@trans_file}").gsub(/\n/,'').gsub(/=/,'!') unless @md5[file]
      fdata.each do |msgid, trans|
        @translation[file].delete(msgid) and next if filter && msgid !~ filter
        @md5[msgid] = Base64.encode64("#{msgid}").gsub(/\n/,'').gsub(/=/,'!') unless @md5[msgid]
      end
    end
  end
  res[:translation].merge!(@translation)
  res[:md5].merge!(@md5)
end
return res
end


# Translations: is BGWorker working?
#
# Author:: Sylvain Abélard
# Version:: 5
# Last Update:: 2010-06-16 15:07:18 UTC
# Status:: Validation Pending


def self.working?(task=nil)
tasks = [task].flatten || ['updatepo', 'makemo', 'auto_translate']
BgWorker.exists?(["name IN (?) AND locked_at IS NOT NULL", tasks])
end


# Translations: list PO files.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-03-31 21:30:48 UTC
# Status:: Validated


def self.po_files(locale_code=nil)
Dir.glob(Rails.root.join('po', locale_code, '*.po'))
end


# WARNING: check your services' Terms of Use.
# Translations: auto-translate process: forge a user-agent identification.
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 15:08:12 UTC
# Status:: Validation Pending


def self.user_agent(random=false)
if random
  AppLocale::USER_AGENTS[rand(AppLocale::USER_AGENTS.size)]
else
  AppLocale::DEFAULT_USER_AGENT
end
end


# WARNING: check your services' Terms of Use.
# Translations: auto-translate: get a translations batch.
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 15:09:16 UTC
# Status:: Should be optimized


def self.get_translations(msgids=[])
return if msgids.blank?
if opts[:group]
  mi = msgids.join("[````]")
  uri.query = URI.encode("langpair=en|#{loc}&text=#{mi}")
  doc = open(uri.to_s, {"User-Agent" => AppLocale.user_agent}) { |f|
    Hpricot(f)
  }
  raise "Google did not answer correctly" if doc.nil?
  text = (doc/"#result_box").inner_text
  raise "Google did not answer correctly" if text.blank?
  texts = text.split(" [````]")
  raise "Google can't translate more" if texts.empty?
  return texts
else
  return msgids.collect{ |mi|

    # logger.debug("Working on: #{mi}")

    uri.query = URI.encode("langpair=en|#{loc}&text=#{mi}")
    doc = open(uri.to_s, {"User-Agent" => AppLocale.user_agent}) { |f|
      Hpricot(f)
    }
    text = (doc/"#result_box").inner_text.sub(/\ $/, '')
    raise "Google can't translate more" if text.nil?
    text
  }
end
end


# Translations: runs a background job.
#
# Author:: Yann Azoury
# Version:: 7
# Last Update:: 2012-05-29 00:35:14 UTC
# Status:: Validation Pending


def self.start(task_name)
task = task_name.to_s.tr('_', '')
if Rails.env == 'development'

  # Threads are too often reset by Passenger in development
  # so we need to compensate for the scheduler not working

  BgWorker.run_task(task, 3, true)
else
  BgWorker.run_task(task)
end
end

def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs
if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics



# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def locale_code_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def locale_code_to_spreadsheet(opts={})
self.locale_code
end


# Author:: Pierre Carrio
# Version:: 2
# Last Update:: 2012-11-29 17:07:41 UTC
# Status:: Validated


def po

if @po_cache && @po_cache[:tmp]
  @po_cache[:path] = File.join(FILES_DEST_PO, 'cache', @po_cache[:tmp])
end
if @po_cache && File.exists?(@po_cache[:path])
  return File.read(@po_cache[:path])
else
  File.open(self.po__path, 'r').read unless self.new_record? || !File.exist?(self.po__path)
end
end


# Gives the file path.
#
# Author:: Pierre Carrio
# Version:: 3
# Last Update:: 2012-11-29 17:08:18 UTC
# Status:: Validated


def po__path
if !@po_cache.blank? && !@po_cache[:path].blank?
  @po_cache[:path]
else
  File.join(FILES_DEST_PO, "#{self.id}_#{self.po__name}")
end
end


# Gives the file size.
#
# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-01-16 14:40:38 UTC
# Status:: Validated


def po__size
if File.exist?(self.po__path)
  return File.size(self.po__path)
else
  return self.po ? self.po.length : 0
end
end


# Sets everything up when saving a file field.
#
# Author:: Yann Azoury
# Version:: 7
# Last Update:: 2013-02-04 14:09:22 UTC
# Status:: Validated


def po=(val)

# make cache dir

cdir = File.join(FILES_DEST_PO, 'cache')
FileUtils.makedirs(cdir) unless File.exist?(cdir)

# remove existing cache file (create) or file (update)

File.delete(@po_cache[:path]) if @po_cache && @po_cache[:path] && File.exist?(@po_cache[:path])
File.delete(self.po__path) if File.exist?(self.po__path)

#set cache, prepare for failed validation or after_create trigger

@po_cache ||= {}
@po_cache[:name] = self.attributes['po__name']
@po_cache[:tmp] = "#{UUID.new.generate}--#{@po_cache[:name]}"
@po_cache[:path] = File.join(cdir, @po_cache[:tmp])
File.open(@po_cache[:path], 'w') {|f| f.write(val) }

#TODO

return val
end


# Returns thumbnails path for the current data.
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 00:31:32 UTC
# Status:: Validated


def po__thumb_path

File.join(FILES_DEST_PO__THUMBS, File.basename(self.po__path))
end


# Returns the MIME Type of current file (based on its name).
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 00:43:35 UTC
# Status:: Validated


def po__mime_type
if !self.po__name.blank?
  mt = MIME::Types.of(File.extname(self.po__name)).first
  return mt ? mt.content_type : "application/octet-stream"
end
end


# Rename the file correctly on the file system after create.
#
# Author:: Pierre Carrio
# Version:: 4
# Last Update:: 2012-12-03 09:41:10 UTC
# Status:: Validated


def po__after_create_trigger

if !@po_cache.blank? && !@po_cache[:tmp].blank?
  @po_cache[:path] = File.join(FILES_DEST_PO, 'cache', @po_cache[:tmp])
end
if !@po_cache.blank? && @po_cache[:path]
  if File.exist?(@po_cache[:path])
    File.rename(@po_cache[:path], File.join(FILES_DEST_PO, "#{self.id}_#{self.po__name}"))
  else
    logger.warn("Should not happen! cache: #{@po_cache.inspect} - name: #{self.po__name}")
  end
end
@po_cache = {}
end


# Rename Files correctly after update.
#
# Author:: Pierre Carrio
# Version:: 5
# Last Update:: 2012-12-03 09:40:46 UTC
# Status:: Validated


def po__after_update_trigger

Dir[File.join(FILES_DEST_PO__THUMBS, "#{self.id}_*")].each{|f| File.delete(f); break} #will be regenerated
if !@po_cache.blank? && !@po_cache[:tmp].blank?
  @po_cache[:path] = File.join(FILES_DEST_PO, 'cache', @po_cache[:tmp])
end
if !@po_cache.blank? && @po_cache[:path] && File.exist?(@po_cache[:path])
  Dir[File.join(FILES_DEST_PO, "#{self.id}_*")].each{|f| File.delete(f); break}
  dest = File.join(FILES_DEST_PO, "#{self.id}_#{self.po__name}")
  logger.debug("=== CACHE [#{@po_cache[:path].inspect}] DEST [#{dest.inspect}]")
  FileUtils.mv(@po_cache[:path], File.join(FILES_DEST_PO, "#{self.id}_#{self.po__name}"))
else
  src = self.po__path
  if !File.exists?(src) # bad name
    Dir[File.join(FILES_DEST_PO, "#{self.id}_*")].each{|f| File.rename(f, src); break}
  end
end
@po_cache = {}
end


# Remove files of destroyed row.
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 01:12:31 UTC
# Status:: Validated


def po__after_destroy_trigger

Dir[File.join(FILES_DEST_PO, "#{self.id}_*")].each{|f| File.delete(f)}
Dir[File.join(FILES_DEST_PO__THUMBS, "#{self.id}_*")].each{|f| File.delete(f)}
end


# return current cache hash
#
# Author:: Yann Azoury
# Version:: 6
# Last Update:: 2012-11-30 10:43:55 UTC
# Status:: Validated


def po__cache
@po_cache ||= {}
end


# Exporting: display filename if available
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2011-06-08 18:34:29 UTC
# Status:: Requires Tests


def po_to_spreadsheet(opts={})
self.po__name
end


# Exporting timestamp: displays as 2030-12-25 18:30:02.
# Use {:datetime_format => "On %m/%d/%Y, at %Hh%Mm%Ss"} to display as "On 12/25/2030, at 18h30m02s"
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2011-06-10 15:12:37 UTC
# Status:: Validation Pending


def updated_at_to_spreadsheet(opts={})
self.updated_at.blank? ? '' : self.updated_at.strftime(opts[:datetime_format] || '%Y-%m-%d %H:%M:%S')
end


# Importing DateTime from spreadsheet: accepts DateTime variants, converting from Excel numbers, french dates, and whatever Chronic accepts.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-09 18:09:48 UTC
# Status:: Requires Tests


def updated_at_from_spreadsheet(v, opts={})
french_hour_regexp = /(\d{1,2})[h:](\d{1,2})[m:](\d{2,4})s?/
french_date_regexp = /(\d{1,2})\/(\d{1,2})\/(\d{2,4})/
if v.is_a?(DateTime) || v.is_a?(Time)
  v
elsif v.is_a?(Date)
  DateTime.civil(v.year, v.month, v.day)
elsif v.is_a?(Numeric)
  int = v.to_i
  d   = Date.new(1900, 1, 1) + ((int > 58) ? int+1 : int)
  flt = v.abs % 1 # 345.678 -> 0.678, -123.456 -> .456
  sec = 24 * 60 * 60 * flt
  DateTime.parse(Time.local(d.year, d.month, d.day) + sec)
elsif v.is_a?(String) && v =~ french_date_regexp
  m = v.match(french_date_regexp)
  "#{m[3]}-#{m[2]}-#{m[1]}"
  Chronic::parse(v.sub(m[0], "#{m[3]}-#{m[2]}-#{m[1]}"))
else
  Chronic::parse(v.to_s)
end
end


def self.po_folder

Rails.root.join('files/po_files')

end

FILES_DEST_PO = self.po_folder
FILES_DEST_PO__THUMBS = FILES_DEST_PO + '__thumbs'

FileUtils.makedirs(FILES_DEST_PO) unless File.exist?(FILES_DEST_PO)
FileUtils.makedirs(FILES_DEST_PO__THUMBS) unless File.exist?(FILES_DEST_PO__THUMBS)

after_create {|rec|
src = File.join(FILES_DEST_PO, "_#{rec.po__name}")
src = File.join(FILES_DEST_PO, "_") unless File.exists?(src)
File.rename(src, File.join(FILES_DEST_PO, "#{rec.id}_#{rec.po__name}")) if File.exists?(src)

}
after_update {|rec|
src = rec.po__path
Dir[File.join(FILES_DEST_PO__THUMBS, "#{rec.id}_*")].each{|f| File.delete(f); break}
if !File.exists?(src) # bad name
  Dir[File.join(FILES_DEST_PO, "#{rec.id}_*")].each{|f| File.rename(f, src); break}

end
}
after_destroy {|rec|
Dir[File.join(FILES_DEST_PO, "#{rec.id}_*")].each{|f| File.delete(f)}
Dir[File.join(FILES_DEST_PO__THUMBS, "#{rec.id}_*")].each{|f| File.delete(f)}

}

end
