# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:41:16 +0100 2013
## It should be placed at 'app/models/user.rb'
## All manual modifications will be destroyed on next generation
################################################


class User < ActiveRecord::Base

  self.table_name = 'users'

  SEARCHABLE_FIELDS = [:login,:customers,:telephone,:dev_feedbacks,:file_imports].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:login => :string, :first_name => :string, :last_name => :string, :email => :string, :customers => :hm_assoc, :telephone => :string, :language => :string, :active => :boolean, :hashed_password => :string, :salt => :string, :last_login => :datetime, :last_session_id => :string, :user_accesses => :hm_assoc, :profiles => :habtm_assoc, :dev_feedbacks => :hm_assoc, :file_imports => :hm_assoc).freeze
  COMPARATORS = {:login => ActiveSupport::OrderedHash['=~', ["users.login LIKE ?", '%%%s%'], '!~', ["users.login NOT LIKE ?", '%%%s%'], '^=', ["users.login LIKE ?", '%s%'], '$=', ["users.login LIKE ?", '%%%s'], '=', ["users.login = ?"], '!=', ["users.login <> ?"], 'NULL', ["users.login IS NULL", ''], 'NOT_NULL', ["users.login IS NOT NULL", '']],
    :first_name => ActiveSupport::OrderedHash['=~', ["users.first_name LIKE ?", '%%%s%'], '!~', ["users.first_name NOT LIKE ?", '%%%s%'], '^=', ["users.first_name LIKE ?", '%s%'], '$=', ["users.first_name LIKE ?", '%%%s'], '=', ["users.first_name = ?"], '!=', ["users.first_name <> ?"], 'NULL', ["users.first_name IS NULL", ''], 'NOT_NULL', ["users.first_name IS NOT NULL", '']],
    :last_name => ActiveSupport::OrderedHash['=~', ["users.last_name LIKE ?", '%%%s%'], '!~', ["users.last_name NOT LIKE ?", '%%%s%'], '^=', ["users.last_name LIKE ?", '%s%'], '$=', ["users.last_name LIKE ?", '%%%s'], '=', ["users.last_name = ?"], '!=', ["users.last_name <> ?"], 'NULL', ["users.last_name IS NULL", ''], 'NOT_NULL', ["users.last_name IS NOT NULL", '']],
    :email => ActiveSupport::OrderedHash['=~', ["users.email LIKE ?", '%%%s%'], '!~', ["users.email NOT LIKE ?", '%%%s%'], '^=', ["users.email LIKE ?", '%s%'], '$=', ["users.email LIKE ?", '%%%s'], '=', ["users.email = ?"], '!=', ["users.email <> ?"], 'NULL', ["users.email IS NULL", ''], 'NOT_NULL', ["users.email IS NOT NULL", '']],
    :customers => ActiveSupport::OrderedHash['IN', ["customers.id IN (?)"], 'NOT_IN', ["customers.id NOT IN (?)"]],
    :telephone => ActiveSupport::OrderedHash['=~', ["users.telephone LIKE ?", '%%%s%'], '!~', ["users.telephone NOT LIKE ?", '%%%s%'], '^=', ["users.telephone LIKE ?", '%s%'], '$=', ["users.telephone LIKE ?", '%%%s'], '=', ["users.telephone = ?"], '!=', ["users.telephone <> ?"], 'NULL', ["users.telephone IS NULL", ''], 'NOT_NULL', ["users.telephone IS NOT NULL", '']],
    :language => ActiveSupport::OrderedHash['=~', ["users.language LIKE ?", '%%%s%'], '!~', ["users.language NOT LIKE ?", '%%%s%'], '^=', ["users.language LIKE ?", '%s%'], '$=', ["users.language LIKE ?", '%%%s'], '=', ["users.language = ?"], '!=', ["users.language <> ?"], 'NULL', ["users.language IS NULL", ''], 'NOT_NULL', ["users.language IS NOT NULL", '']],
    :active => ActiveSupport::OrderedHash['=', ["users.active = ?"], '!=', ["users.active <> ?"], 'NULL', ["users.active IS NULL", ''], 'NOT_NULL', ["users.active IS NOT NULL", '']],
    :hashed_password => ActiveSupport::OrderedHash['=~', ["users.hashed_password LIKE ?", '%%%s%'], '!~', ["users.hashed_password NOT LIKE ?", '%%%s%'], '^=', ["users.hashed_password LIKE ?", '%s%'], '$=', ["users.hashed_password LIKE ?", '%%%s'], '=', ["users.hashed_password = ?"], '!=', ["users.hashed_password <> ?"], 'NULL', ["users.hashed_password IS NULL", ''], 'NOT_NULL', ["users.hashed_password IS NOT NULL", '']],
    :salt => ActiveSupport::OrderedHash['=~', ["users.salt LIKE ?", '%%%s%'], '!~', ["users.salt NOT LIKE ?", '%%%s%'], '^=', ["users.salt LIKE ?", '%s%'], '$=', ["users.salt LIKE ?", '%%%s'], '=', ["users.salt = ?"], '!=', ["users.salt <> ?"], 'NULL', ["users.salt IS NULL", ''], 'NOT_NULL', ["users.salt IS NOT NULL", '']],
    :last_login => ActiveSupport::OrderedHash['=', ["users.last_login = ?"], '!=', ["users.last_login <> ?"], '>', ["users.last_login > ?"], '<', ["users.last_login < ?"], '>=', ["users.last_login >= ?"], '<=', ["users.last_login <= ?"]],
    :last_login_min => ActiveSupport::OrderedHash['>=', ["users.last_login >= ?"], '>', ["users.last_login > ?"]],
    :last_login_max => ActiveSupport::OrderedHash['<=', ["users.last_login <= ?"], '<', ["users.last_login < ?"]],
    :last_session_id => ActiveSupport::OrderedHash['=~', ["users.last_session_id LIKE ?", '%%%s%'], '!~', ["users.last_session_id NOT LIKE ?", '%%%s%'], '^=', ["users.last_session_id LIKE ?", '%s%'], '$=', ["users.last_session_id LIKE ?", '%%%s'], '=', ["users.last_session_id = ?"], '!=', ["users.last_session_id <> ?"], 'NULL', ["users.last_session_id IS NULL", ''], 'NOT_NULL', ["users.last_session_id IS NOT NULL", '']],
    :user_accesses => ActiveSupport::OrderedHash['IN', ["user_accesses.id IN (?)"], 'NOT_IN', ["user_accesses.id NOT IN (?)"]],
    :profiles => ActiveSupport::OrderedHash['IN', ["profiles_users.profile_id IN (?)"], 'NOT_IN', ["profiles_users.profile_id NOT IN (?)"]],
    :dev_feedbacks => ActiveSupport::OrderedHash['IN', ["dev_feedbacks.id IN (?)"], 'NOT_IN', ["dev_feedbacks.id NOT IN (?)"]],
    :file_imports => ActiveSupport::OrderedHash['IN', ["file_imports.id IN (?)"], 'NOT_IN', ["file_imports.id NOT IN (?)"]],
  :accesses => ActiveSupport::OrderedHash['IN', [". IN (?)"], 'NOT_IN', [". NOT IN (?)"]]}.freeze

  FILES_DEST = Rails.root.join('files', %q{users}).to_s


  # == Validations


  validates_presence_of(:login)
  validates_uniqueness_of(:login, :case_sensitive => false)
  validates_presence_of(:email)

  def self.validates_as_email_243_for_email(field, options = {})
    pattern = /\A(|(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\-+)|([A-Za-z0-9]+\.+)|([A-Za-z0-9]+\++))*[A-Za-z0-9]+@((\w+\-+)|(\w+\.))*\w{1,63}\.[a-zA-Z]{2,6})\Z/i

    # validates length

    email_len_opts = options.merge(:in => (3)..(320))
    validates_length_of :email, email_len_opts

    # validates format

    email_fmt_opts = options.merge({:with => pattern,
    :message => (options['wrong_format'] || options['message'] || _('%{value} is not a valid email address')) })
    validates_format_of :email, email_fmt_opts
  end
  validates_as_email_243_for_email(:email)


  # == Triggers


  before_create(:set_default_profiles)
  before_validation(:set_default_password, :on => :create)
  after_create(:email_welcome_and_pass)


  # == Relations
  #


  has_many :customers, :foreign_key => "user_id", :class_name => "Customer"
  has_many :user_accesses, :dependent => :destroy, :foreign_key => "user_id", :class_name => "UserAccess"
  has_many :dev_feedbacks, :foreign_key => "user_id", :class_name => "DevFeedback"
  has_many :file_imports, :foreign_key => "user_id", :class_name => "FileImport"
  has_and_belongs_to_many :profiles, :association_foreign_key => "profile_id", :join_table => "profiles_users", :foreign_key => "user_id", :class_name => "Profile"
  has_many :accesses, :source => :access, :through => :user_accesses


  # Associations through specific setters
  #



  def accesses=(array)
    ids = array.map(&:id)
    UserAccess.where(['user_accesses.user_id = ? AND user_accesses.access_id NOT IN (?)', self.id, ids]).select(:id).each(&:destroy)
    user_access_ids = UserAccess.all(:conditions => {:user_id => self.id, :access_id => ids}, :select => 'access_id').map(&:access_id)
    (ids - user_access_ids).each{|i|
      UserAccess.create(:user_id => self.id, :access_id => i)
    }
    self.accesses.reload
  end

  # Virtual Fields

  attr_accessor :password

  attr_accessor :customers_was
  attr_accessor :user_accesses_was
  attr_accessor :accesses_was
  attr_accessor :profiles_was
  attr_accessor :dev_feedbacks_was
  attr_accessor :file_imports_was


  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-09-03 16:56:08 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return User.new if att.blank?
    std_atts = att.reject{|k,v| %w(id customers user_accesses accesses profiles dev_feedbacks file_imports).include?(k.to_s) }
    user = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      user = User.find(att[:id])
      user.attributes = std_atts
    else
      user = User.new(std_atts)
    end

    # clean associations

    user.customers_load_from_params(att[:customers])
    user.user_accesses_load_from_params(att[:user_accesses])
    user.accesses_load_from_params(att[:accesses])
    user.profiles_load_from_params(att[:profiles])
    user.dev_feedbacks_load_from_params(att[:dev_feedbacks])
    user.file_imports_load_from_params(att[:file_imports])

    #clean binaries
    #clean serialized data

    return user
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      User.new.params_to_attributes(values).each { |k,v|
        case k.to_sym
        when :login
          cmp = comps["comp_login"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :login : "login_#{string_h[cmp]}"
          cond[field] = val
        when :customers
          cmp = comps["comp_customers"]
          val = cmp == 'IS NULL' ? nil : v
          field = assoc_h[cmp].nil? ? 'customers.user_id' : "customers_#{assoc_h[cmp]}"
          cond[field] = val
          inc << :customers
        when :telephone
          cmp = comps["comp_telephone"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :telephone : "telephone_#{string_h[cmp]}"
          cond[field] = val
        when :dev_feedbacks
          cmp = comps["comp_dev_feedbacks"]
          val = cmp == 'IS NULL' ? nil : v
          field = assoc_h[cmp].nil? ? 'dev_feedbacks.user_id' : "dev_feedbacks_#{assoc_h[cmp]}"
          cond[field] = val
          inc << :dev_feedbacks
        when :file_imports
          cmp = comps["comp_file_imports"]
          val = cmp == 'IS NULL' ? nil : v
          field = assoc_h[cmp].nil? ? 'file_imports.user_id' : "file_imports_#{assoc_h[cmp]}"
          cond[field] = val
          inc << :file_imports
        end
      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Makes all kind of calculations for reports.
  #
  # Author:: Yann Azoury
  # Version:: 20
  # Last Update:: 2013-02-27 12:27:37 UTC
  # Status:: Should be optimized


  def self.report_calculation(op, field = :id, opts = {})
    scope	= opts[:scope]
    labels	= opts[:labels]	  || []
    step	= opts[:step]
    group	= opts[:group]
    ret_hash= opts[:ret_hash] || false
    opsym	= case op
    when :count, 'count'			then field = :id ; :count
    when :avg, 'avg', 'average', :average	then :avg
    when :value, 'value', :sum, 'sum'	then :sum
    when :min, 'min', :minimum, 'minimum'	then :min
    when :max, 'max', :maximum, 'maximum'	then :max
    else field = :id ; :count
    end
    case group
    when nil
      return scope.blank? ? self.calculate(opsym, field) : with_scope(:find => {:conditions => scope}) { self.calculate(opsym, field) }
    when :profiles, 'profiles'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :user_id, :joins => :profiles)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :user_id, :joins => :profiles)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :customers, 'customers'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :user_id, :joins => :customers)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :user_id, :joins => :customers)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :user_accesses, 'user_accesses'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :user_id, :joins => :user_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :user_id, :joins => :user_accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :dev_feedbacks, 'dev_feedbacks'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :user_id, :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :user_id, :joins => :dev_feedbacks)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :file_imports, 'file_imports'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :user_id, :joins => :file_imports)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :user_id, :joins => :file_imports)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :accesses, 'accesses'
      h = if scope.blank?
        self.calculate(opsym, field, :group => "users.id", :joins => :accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => "users.id", :joins => :accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :active, 'active'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'active')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'active')
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"user_accesses.read", 'user_accesses.read'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'user_accesses.read', :joins => :user_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'user_accesses.read', :joins => :user_accesses)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"user_accesses.write", 'user_accesses.write'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'user_accesses.write', :joins => :user_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'user_accesses.write', :joins => :user_accesses)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"dev_feedbacks.ticket_status", 'dev_feedbacks.ticket_status'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'dev_feedbacks.ticket_status', :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'dev_feedbacks.ticket_status', :joins => :dev_feedbacks)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :login, 'login'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'login')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'login')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :first_name, 'first_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'first_name')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'first_name')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :last_name, 'last_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'last_name')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'last_name')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :email, 'email'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'email')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'email')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :telephone, 'telephone'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'telephone')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'telephone')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :language, 'language'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'language')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'language')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :password, 'password'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'password')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'password')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :hashed_password, 'hashed_password'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'hashed_password')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'hashed_password')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :salt, 'salt'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'salt')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'salt')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :last_session_id, 'last_session_id'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'last_session_id')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'last_session_id')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"customers.first_name", 'customers.first_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'customers.first_name', :joins => :customers)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'customers.first_name', :joins => :customers)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"customers.last_name", 'customers.last_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'customers.last_name', :joins => :customers)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'customers.last_name', :joins => :customers)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"customers.new_string", 'customers.new_string'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'customers.new_string', :joins => :customers)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'customers.new_string', :joins => :customers)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"accesses.app_sid", 'accesses.app_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'accesses.app_sid', :joins => :accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'accesses.app_sid', :joins => :accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"accesses.set_sid", 'accesses.set_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'accesses.set_sid', :joins => :accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'accesses.set_sid', :joins => :accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"accesses.table_sid", 'accesses.table_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'accesses.table_sid', :joins => :accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'accesses.table_sid', :joins => :accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"accesses.field_sid", 'accesses.field_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'accesses.field_sid', :joins => :accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'accesses.field_sid', :joins => :accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"accesses.action_sid", 'accesses.action_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'accesses.action_sid', :joins => :accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'accesses.action_sid', :joins => :accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"accesses.type_sid", 'accesses.type_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'accesses.type_sid', :joins => :accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'accesses.type_sid', :joins => :accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"profiles.name", 'profiles.name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'profiles.name', :joins => :profiles)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'profiles.name', :joins => :profiles)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.title", 'dev_feedbacks.title'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'dev_feedbacks.title', :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'dev_feedbacks.title', :joins => :dev_feedbacks)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.url", 'dev_feedbacks.url'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'dev_feedbacks.url', :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'dev_feedbacks.url', :joins => :dev_feedbacks)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.controller", 'dev_feedbacks.controller'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'dev_feedbacks.controller', :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'dev_feedbacks.controller', :joins => :dev_feedbacks)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.action", 'dev_feedbacks.action'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'dev_feedbacks.action', :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'dev_feedbacks.action', :joins => :dev_feedbacks)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.ip", 'dev_feedbacks.ip'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'dev_feedbacks.ip', :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'dev_feedbacks.ip', :joins => :dev_feedbacks)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.ua", 'dev_feedbacks.ua'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'dev_feedbacks.ua', :joins => :dev_feedbacks)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'dev_feedbacks.ua', :joins => :dev_feedbacks)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.lft", 'dev_feedbacks.lft'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.joins(:dev_feedbacks).where(["users.dev_feedbacks.lft >= ? AND users.dev_feedbacks.lft < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.joins(:dev_feedbacks).where(["users.dev_feedbacks.lft >= ? AND users.dev_feedbacks.lft < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.parent_id", 'dev_feedbacks.parent_id'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.joins(:dev_feedbacks).where(["users.dev_feedbacks.parent_id >= ? AND users.dev_feedbacks.parent_id < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.joins(:dev_feedbacks).where(["users.dev_feedbacks.parent_id >= ? AND users.dev_feedbacks.parent_id < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"dev_feedbacks.rgt", 'dev_feedbacks.rgt'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.joins(:dev_feedbacks).where(["users.dev_feedbacks.rgt >= ? AND users.dev_feedbacks.rgt < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.joins(:dev_feedbacks).where(["users.dev_feedbacks.rgt >= ? AND users.dev_feedbacks.rgt < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"file_imports.read_lines", 'file_imports.read_lines'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.joins(:file_imports).where(["users.file_imports.read_lines >= ? AND users.file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.joins(:file_imports).where(["users.file_imports.read_lines >= ? AND users.file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"file_imports.wrote_records", 'file_imports.wrote_records'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.joins(:file_imports).where(["users.file_imports.wrote_records >= ? AND users.file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.joins(:file_imports).where(["users.file_imports.wrote_records >= ? AND users.file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"file_imports.expected_total", 'file_imports.expected_total'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.joins(:file_imports).where(["users.file_imports.expected_total >= ? AND users.file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.joins(:file_imports).where(["users.file_imports.expected_total >= ? AND users.file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"file_imports.error_count", 'file_imports.error_count'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.joins(:file_imports).where(["users.file_imports.error_count >= ? AND users.file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.joins(:file_imports).where(["users.file_imports.error_count >= ? AND users.file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :last_login, 'last_login'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(users.last_login)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(users.last_login),'-', WEEK(users.last_login))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(users.last_login),'-', MONTH(users.last_login))"
        when :year
          lab_format = '%Y'
          "YEAR(users.last_login)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'last_login')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'last_login')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :"customers.new_date", 'customers.new_date'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(customers.new_date)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(customers.new_date),'-', WEEK(customers.new_date))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(customers.new_date),'-', MONTH(customers.new_date))"
        when :year
          lab_format = '%Y'
          "YEAR(customers.new_date)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'customers.new_date', :joins => :customers)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'customers.new_date', :joins => :customers)
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :"dev_feedbacks.created_at", 'dev_feedbacks.created_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(dev_feedbacks.created_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(dev_feedbacks.created_at),'-', WEEK(dev_feedbacks.created_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(dev_feedbacks.created_at),'-', MONTH(dev_feedbacks.created_at))"
        when :year
          lab_format = '%Y'
          "YEAR(dev_feedbacks.created_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'dev_feedbacks.created_at', :joins => :dev_feedbacks)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'dev_feedbacks.created_at', :joins => :dev_feedbacks)
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :"file_imports.started_at", 'file_imports.started_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.started_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.started_at),'-', WEEK(file_imports.started_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.started_at),'-', MONTH(file_imports.started_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.started_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'file_imports.started_at', :joins => :file_imports)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'file_imports.started_at', :joins => :file_imports)
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :"file_imports.completed_at", 'file_imports.completed_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.completed_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.completed_at),'-', WEEK(file_imports.completed_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.completed_at),'-', MONTH(file_imports.completed_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.completed_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'file_imports.completed_at', :joins => :file_imports)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'file_imports.completed_at', :joins => :file_imports)
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["users.#{group} >= ? AND users.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    else
      logger.debug("Unknown Group: #{group} (operation: #{opsym}, scope: #{scope})")
    end
    return []
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = User.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.user_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    User.first(:order => 'users.id DESC', :conditions => ["users.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    User.first(:order => 'users.id', :conditions => ["users.id > ?", self.id])
  end

  # Author:: Sylvain Abélard
  # Version:: 3
  # Last Update:: 2010-06-18 10:06:24 UTC

  scope(:active, :conditions => {:active => true})


  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2010-04-19 15:03:16 UTC


  def self.named_scope_except_domain_method(domain)
    {:conditions => "email NOT LIKE '%@#{domain}'"}
  end

  scope(:except_domain, proc {|domain| named_scope_except_domain_method(domain) })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2010-04-19 15:04:04 UTC


  def self.named_scope_with_domain_method(domain)
    {:conditions => "email LIKE '%@#{domain}'"}
  end

  scope(:with_domain, proc {|domain| named_scope_with_domain_method(domain) })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2010-04-19 15:04:38 UTC


  def self.named_scope_with_mail_method
    {:conditions => "email IS NOT NULL"}
  end

  scope(:with_mail, proc { named_scope_with_mail_method })

  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-11-01 16:01:43 UTC


  def self.named_scope_default_scope_method

    {}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      case field.to_sym
      when :customers, :user_id
        joins_fields << :customers
      when :user_accesses, :user_id
        joins_fields << :user_accesses
      when :profiles, :user_id
        joins_fields << :profiles
      when :dev_feedbacks, :user_id
        joins_fields << :dev_feedbacks
      when :file_imports, :user_id
        joins_fields << :file_imports
      end
      if [:login, :first_name, :last_name, :email, :customers, :user_id, :telephone, :language, :active, :hashed_password, :salt, :last_login, :last_session_id, :user_accesses, :profiles, :dev_feedbacks, :file_imports
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })


# Find matching user.
#
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2012-12-25 18:48:23 UTC
# Status:: Validated


def self.sign_on(login, password)
user = where(:login => login).first
return nil if !user || !user.active?
return user if Digest::SHA1.hexdigest(password+user.salt) == user.hashed_password
end


# Returns true if the user belongs to this profile (can be a profile id, name or object).
#
# Author:: Yann Azoury
# Version:: 8
# Last Update:: 2012-12-25 18:44:30 UTC
# Status:: Validated


def has_profile?(*profiles)
@has_profiles ||= {}
profile = profiles.shift
return true if self.new_record? && profile == 'Not Logged'
@has_profiles[profile] = case profile
when nil
  false
when Fixnum
  self.profile_ids.include?(profile)
when String
  self.profiles.where(:name => profile).select('id').first
when Profile
  self.profiles.where(:id => profile).select('id').first
end unless @has_profiles.has_key?(profile)
return @has_profiles[profile] || profiles.find{|t| self.has_profile?(t) }
end


# Checks per-action access.
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 14:31:10 UTC
# Status:: Validated


def can_run_self?(action)
return false if !self.active? || self.new_record?
case action
when nil then return false
when Access then return UserAccess.exists?(:user_id => self.id, :access_id => action.id)
when Hash then
  cond = ["accesses.action_sid = ? AND accesses.table_sid = ?", action[:action_sid], action[:table_sid]]
  return self.user_accesses.first(:include => :access, :conditions => cond)
else
  return false
end
end


# Check per-profile access.
#
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-10-31 16:42:00 UTC
# Status:: Validated


def can_run_by_profile?(action)
return false unless self.active?
if self.new_record?
  prof = Profile.where(:name => 'Not Logged').first
  return prof.can_run?(action) if prof
elsif action.is_a?(Hash)
  cond = ["profile_id IN (?) AND accesses.action_sid = ? AND accesses.table_sid = ?", self.profile_ids, action[:action_sid], action[:table_sid]]
  return ProfileAccess.where(cond).include(:access).first
elsif action.is_a?(Access)
  return ProfileAccess.exists?(:profile_id => self.profile_ids, :access_id => action.id)
end
end


# Checks accesses.
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 14:31:31 UTC
# Status:: Validated


def can_run?(action)
return self.active? && (can_run_by_profile?(action) || can_run_self?(action))
end


# Adds "Logged In" to a user's profiles if not already present.
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2010-06-16 14:32:00 UTC
# Status:: Validated


def set_default_profiles
p = Profile.find_by_name("Logged In")
profiles << p unless profiles.include?(p)
end


# Sets a default randomized "salt" and password.
#
# Author:: Yann Azoury
# Version:: 7
# Last Update:: 2011-03-29 18:44:29 UTC
# Status:: Validated


def set_default_password
self.password = :random
end


# Shortcut: checks if user is administrator.
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 14:32:42 UTC
# Status:: Validated


def is_admin?
self.has_profile?('Admin', 'Faveod User')
end


# Displays object name in human-readable format.
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2010-06-16 14:33:02 UTC
# Status:: Validated


def disp_name
"#{self.first_name} #{self.last_name}"
end


# Send an email to user
#
# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2009-09-01 16:52:43 UTC
# Status:: Validated


def email_welcome_and_pass
old_gt = I18n.locale
I18n.locale = self.language unless self.language.blank?
UserMailer.deliver_account_infos(self, @password) # Uniq time with decoded password
I18n.locale = old_gt
end


# Returns a hash describing this user's homepage URL.
#
# Author:: Yann Azoury
# Version:: 6
# Last Update:: 2010-09-13 12:23:13 UTC
# Status:: Validated


def home_page
if self.has_profile?('Admin', 'Faveod User')
  {:controller => :system_settings}
else
  {:controller => :users, :action => :show, :id => self.id}
end
end


# Available languages.
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2010-06-16 14:33:38 UTC
# Status:: Validated


def language__potential_values
(GSS[:locales] || 'en fr de ar').split(" ").map{|l| [l,l]}
end


# Change password using random or parameter.
#
# Author:: Sylvain Abélard
# Version:: 5
# Last Update:: 2012-05-23 10:47:58 UTC
# Status:: Validated


def password=(pass)

chars = ("a".."z").to_a + ("A".."Z").to_a + ("0".."9").to_a
self.salt = (1..10).to_a.map{ chars[rand(chars.size-1)] }.join
@password = (pass == :random || pass.blank?) ? (1..10).to_a.map{ chars[rand(chars.size-1)] }.join : pass
self.hashed_password = Digest::SHA1.hexdigest(@password+self.salt)
end


# Author:: Sylvain Abélard
# Version:: 1
# Last Update:: 2013-08-06 10:53:07 UTC
# Status:: In Progress


def users_ids
if self.has_profile?('Manager')
  self.sales.map{|guy| guy.users_ids}
else
  [self.id]
end
end

# useful method


def customers_human_display

return customers.map(&:disp_name).to_sentence(:connector => _('and'))

end


# useful method


def user_accesses_human_display

return user_accesses.map(&:disp_name).to_sentence(:connector => _('and'))

end


# useful method


def accesses_human_display

return accesses ? accesses.disp_name : ""

end


# useful method


def profiles_human_display

return profiles.map(&:disp_name).to_sentence(:connector => _('and'))

end


# useful method


def dev_feedbacks_human_display

return dev_feedbacks.map(&:disp_name).to_sentence(:connector => _('and'))

end


# useful method


def file_imports_human_display

return file_imports.map(&:disp_name).to_sentence(:connector => _('and'))

end


def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs
if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics



# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def customers__potential_values(options = {})
if options.has_key?(:page)
  Customer.paginate(options)
else
  Customer.all(options)
end
end


# Load association from different params formats.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-10-02 15:11:56 UTC
# Status:: Validated


def customers_load_from_params(val)

self.customers_was = self.customers.all if val
case val
when Hash, HashWithIndifferentAccess
  self.customers = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = Customer.load_from_params(v)
      elt.user_id ||= self.id
      if !elt.valid?
        self.errors.add(:customers, _("Invalid customers: %{d}") % {:d => elt.errors.full_messages.join(',')})
        nil
      else
        elt
      end
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.customers.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        Customer.find(k) unless k.to_i == 0
      end
    else
      elt = Customer.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:customers, _("Invalid customers: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact
when Array
  val = val.compact.map(&:to_i).reject{|v| v == 0}
  self.customers = (val.empty? ? [] : Customer.find(val))
when String, Fixnum
  self.customers = val.blank? ? nil : [Customer.find(val)]
when nil
else logger.warn("Unexpected params type for 'customers': #{val.class}")
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def user_accesses__potential_values(options = {})
if options.has_key?(:page)
  UserAccess.paginate(options)
else
  UserAccess.all(options)
end
end


# Load association from different params formats.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-10-02 15:11:56 UTC
# Status:: Validated


def user_accesses_load_from_params(val)

self.user_accesses_was = self.user_accesses.all if val
case val
when Hash, HashWithIndifferentAccess
  self.user_accesses = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = UserAccess.load_from_params(v)
      elt.user_id ||= self.id
      if !elt.valid?
        self.errors.add(:user_accesses, _("Invalid user_accesses: %{d}") % {:d => elt.errors.full_messages.join(',')})
        nil
      else
        elt
      end
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.user_accesses.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        UserAccess.find(k) unless k.to_i == 0
      end
    else
      elt = UserAccess.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:user_accesses, _("Invalid user_accesses: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact
when Array
  val = val.compact.map(&:to_i).reject{|v| v == 0}
  self.user_accesses = (val.empty? ? [] : UserAccess.find(val))
when String, Fixnum
  self.user_accesses = val.blank? ? nil : [UserAccess.find(val)]
when nil
else logger.warn("Unexpected params type for 'user_accesses': #{val.class}")
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def accesses__potential_values(options = {})
if options.has_key?(:page)
  Access.paginate(options)
else
  Access.all(options)
end
end


# Load association from different params formats.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-10-02 15:11:56 UTC
# Status:: Validated


def accesses_load_from_params(val)

self.accesses_was = self.accesses.all if val
case val
when Hash, HashWithIndifferentAccess
  self.accesses = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = Access.load_from_params(v)
      if !elt.valid?
        self.errors.add(:accesses, _("Invalid accesses: %{d}") % {:d => elt.errors.full_messages.join(',')})
        nil
      else
        elt
      end
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.accesses.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        Access.find(k) unless k.to_i == 0
      end
    else
      elt = Access.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:accesses, _("Invalid accesses: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact
when Array
  val = val.compact.map(&:to_i).reject{|v| v == 0}
  self.accesses = (val.empty? ? [] : Access.find(val))
when String, Fixnum
  self.accesses = val.blank? ? nil : [Access.find(val)]
when nil
else logger.warn("Unexpected params type for 'accesses': #{val.class}")
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def profiles__potential_values(options = {})
if options.has_key?(:page)
  Profile.paginate(options)
else
  Profile.all(options)
end
end


# Load association from different params formats.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-10-02 15:11:56 UTC
# Status:: Validated


def profiles_load_from_params(val)

self.profiles_was = self.profiles.all if val
case val
when Hash, HashWithIndifferentAccess
  self.profiles = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = Profile.load_from_params(v)
      if !elt.valid?
        self.errors.add(:profiles, _("Invalid profiles: %{d}") % {:d => elt.errors.full_messages.join(',')})
        nil
      else
        elt
      end
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.profiles.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        Profile.find(k) unless k.to_i == 0
      end
    else
      elt = Profile.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:profiles, _("Invalid profiles: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact
when Array
  val = val.compact.map(&:to_i).reject{|v| v == 0}
  self.profiles = (val.empty? ? [] : Profile.find(val))
when String, Fixnum
  self.profiles = val.blank? ? nil : [Profile.find(val)]
when nil
else logger.warn("Unexpected params type for 'profiles': #{val.class}")
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def dev_feedbacks__potential_values(options = {})
if options.has_key?(:page)
  DevFeedback.paginate(options)
else
  DevFeedback.all(options)
end
end


# Load association from different params formats.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-10-02 15:11:56 UTC
# Status:: Validated


def dev_feedbacks_load_from_params(val)

self.dev_feedbacks_was = self.dev_feedbacks.all if val
case val
when Hash, HashWithIndifferentAccess
  self.dev_feedbacks = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = DevFeedback.load_from_params(v)
      elt.user_id ||= self.id
      if !elt.valid?
        self.errors.add(:dev_feedbacks, _("Invalid dev_feedbacks: %{d}") % {:d => elt.errors.full_messages.join(',')})
        nil
      else
        elt
      end
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.dev_feedbacks.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        DevFeedback.find(k) unless k.to_i == 0
      end
    else
      elt = DevFeedback.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:dev_feedbacks, _("Invalid dev_feedbacks: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact
when Array
  val = val.compact.map(&:to_i).reject{|v| v == 0}
  self.dev_feedbacks = (val.empty? ? [] : DevFeedback.find(val))
when String, Fixnum
  self.dev_feedbacks = val.blank? ? nil : [DevFeedback.find(val)]
when nil
else logger.warn("Unexpected params type for 'dev_feedbacks': #{val.class}")
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def file_imports__potential_values(options = {})
if options.has_key?(:page)
  FileImport.paginate(options)
else
  FileImport.all(options)
end
end


# Load association from different params formats.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-10-02 15:11:56 UTC
# Status:: Validated


def file_imports_load_from_params(val)

self.file_imports_was = self.file_imports.all if val
case val
when Hash, HashWithIndifferentAccess
  self.file_imports = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = FileImport.load_from_params(v)
      elt.user_id ||= self.id
      if !elt.valid?
        self.errors.add(:file_imports, _("Invalid file_imports: %{d}") % {:d => elt.errors.full_messages.join(',')})
        nil
      else
        elt
      end
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.file_imports.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        FileImport.find(k) unless k.to_i == 0
      end
    else
      elt = FileImport.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:file_imports, _("Invalid file_imports: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact
when Array
  val = val.compact.map(&:to_i).reject{|v| v == 0}
  self.file_imports = (val.empty? ? [] : FileImport.find(val))
when String, Fixnum
  self.file_imports = val.blank? ? nil : [FileImport.find(val)]
when nil
else logger.warn("Unexpected params type for 'file_imports': #{val.class}")
end
end

# BINARIES CONSTANTS


end
