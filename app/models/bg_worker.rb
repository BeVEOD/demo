# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Fri Oct 18 12:04:12 +0200 2013
## It should be placed at 'app/models/bg_worker.rb'
## All manual modifications will be destroyed on next generation
################################################


class BgWorker < ActiveRecord::Base

  self.table_name = 'bg_workers'

  SEARCHABLE_FIELDS = [:from,:cron,:triggered_by,:no_duplicate,:priority,:planned_at,:created_at,:started_at,:locked_at,:locked_by,:completed_at,:last_return_code,:attempts,:failed_at,:logs].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:every => :static_list, :from => :datetime, :cron => :string, :triggered_by => :static_list, :no_duplicate => :boolean, :name => :string, :priority => :integer, :planned_at => :datetime, :created_at => :datetime, :started_at => :datetime, :locked_at => :datetime, :locked_by => :string, :completed_at => :datetime, :last_return_code => :integer, :attempts => :integer, :failed_at => :datetime, :logs => :text).freeze
  COMPARATORS = {:every => ActiveSupport::OrderedHash['IN', ["FIND_IN_SET(?, bg_workers.every)"], 'NOT_IN', ["NOT FIND_IN_SET(?, bg_workers.every)"], 'NULL', ["bg_workers.every IS NULL", ''], 'NOT_NULL', ["bg_workers.every IS NOT NULL", '']],
    :from => ActiveSupport::OrderedHash['=', ["bg_workers.from = ?"], '!=', ["bg_workers.from <> ?"], '>', ["bg_workers.from > ?"], '<', ["bg_workers.from < ?"], '>=', ["bg_workers.from >= ?"], '<=', ["bg_workers.from <= ?"]],
    :from_min => ActiveSupport::OrderedHash['>=', ["bg_workers.from >= ?"], '>', ["bg_workers.from > ?"]],
    :from_max => ActiveSupport::OrderedHash['<=', ["bg_workers.from <= ?"], '<', ["bg_workers.from < ?"]],
    :cron => ActiveSupport::OrderedHash['=~', ["bg_workers.cron LIKE ?", '%%%s%'], '!~', ["bg_workers.cron NOT LIKE ?", '%%%s%'], '^=', ["bg_workers.cron LIKE ?", '%s%'], '$=', ["bg_workers.cron LIKE ?", '%%%s'], '=', ["bg_workers.cron = ?"], '!=', ["bg_workers.cron <> ?"], 'NULL', ["bg_workers.cron IS NULL", ''], 'NOT_NULL', ["bg_workers.cron IS NOT NULL", '']],
    :triggered_by => ActiveSupport::OrderedHash['=', ["bg_workers.triggered_by = ?"], '!=', ["bg_workers.triggered_by <> ?"], 'NULL', ["bg_workers.triggered_by IS NULL", ''], 'NOT_NULL', ["bg_workers.triggered_by IS NOT NULL", '']],
    :no_duplicate => ActiveSupport::OrderedHash['=', ["bg_workers.no_duplicate = ?"], '!=', ["bg_workers.no_duplicate <> ?"], 'NULL', ["bg_workers.no_duplicate IS NULL", ''], 'NOT_NULL', ["bg_workers.no_duplicate IS NOT NULL", '']],
    :name => ActiveSupport::OrderedHash['=~', ["bg_workers.name LIKE ?", '%%%s%'], '!~', ["bg_workers.name NOT LIKE ?", '%%%s%'], '^=', ["bg_workers.name LIKE ?", '%s%'], '$=', ["bg_workers.name LIKE ?", '%%%s'], '=', ["bg_workers.name = ?"], '!=', ["bg_workers.name <> ?"], 'NULL', ["bg_workers.name IS NULL", ''], 'NOT_NULL', ["bg_workers.name IS NOT NULL", '']],
    :priority => ActiveSupport::OrderedHash['=', ["bg_workers.priority = ?"], '!=', ["bg_workers.priority <> ?"], '>', ["bg_workers.priority > ?"], '<', ["bg_workers.priority < ?"], '>=', ["bg_workers.priority >= ?"], '<=', ["bg_workers.priority <= ?"]],
    :priority_min => ActiveSupport::OrderedHash['>=', ["bg_workers.priority >= ?"], '>', ["bg_workers.priority > ?"]],
    :priority_max => ActiveSupport::OrderedHash['<=', ["bg_workers.priority <= ?"], '<', ["bg_workers.priority < ?"]],
    :planned_at => ActiveSupport::OrderedHash['=', ["bg_workers.planned_at = ?"], '!=', ["bg_workers.planned_at <> ?"], '>', ["bg_workers.planned_at > ?"], '<', ["bg_workers.planned_at < ?"], '>=', ["bg_workers.planned_at >= ?"], '<=', ["bg_workers.planned_at <= ?"]],
    :planned_at_min => ActiveSupport::OrderedHash['>=', ["bg_workers.planned_at >= ?"], '>', ["bg_workers.planned_at > ?"]],
    :planned_at_max => ActiveSupport::OrderedHash['<=', ["bg_workers.planned_at <= ?"], '<', ["bg_workers.planned_at < ?"]],
    :created_at => ActiveSupport::OrderedHash['=', ["bg_workers.created_at = ?"], '!=', ["bg_workers.created_at <> ?"], '>', ["bg_workers.created_at > ?"], '<', ["bg_workers.created_at < ?"], '>=', ["bg_workers.created_at >= ?"], '<=', ["bg_workers.created_at <= ?"]],
    :created_at_min => ActiveSupport::OrderedHash['>=', ["bg_workers.created_at >= ?"], '>', ["bg_workers.created_at > ?"]],
    :created_at_max => ActiveSupport::OrderedHash['<=', ["bg_workers.created_at <= ?"], '<', ["bg_workers.created_at < ?"]],
    :started_at => ActiveSupport::OrderedHash['=', ["bg_workers.started_at = ?"], '!=', ["bg_workers.started_at <> ?"], '>', ["bg_workers.started_at > ?"], '<', ["bg_workers.started_at < ?"], '>=', ["bg_workers.started_at >= ?"], '<=', ["bg_workers.started_at <= ?"]],
    :started_at_min => ActiveSupport::OrderedHash['>=', ["bg_workers.started_at >= ?"], '>', ["bg_workers.started_at > ?"]],
    :started_at_max => ActiveSupport::OrderedHash['<=', ["bg_workers.started_at <= ?"], '<', ["bg_workers.started_at < ?"]],
    :locked_at => ActiveSupport::OrderedHash['=', ["bg_workers.locked_at = ?"], '!=', ["bg_workers.locked_at <> ?"], '>', ["bg_workers.locked_at > ?"], '<', ["bg_workers.locked_at < ?"], '>=', ["bg_workers.locked_at >= ?"], '<=', ["bg_workers.locked_at <= ?"]],
    :locked_at_min => ActiveSupport::OrderedHash['>=', ["bg_workers.locked_at >= ?"], '>', ["bg_workers.locked_at > ?"]],
    :locked_at_max => ActiveSupport::OrderedHash['<=', ["bg_workers.locked_at <= ?"], '<', ["bg_workers.locked_at < ?"]],
    :locked_by => ActiveSupport::OrderedHash['=~', ["bg_workers.locked_by LIKE ?", '%%%s%'], '!~', ["bg_workers.locked_by NOT LIKE ?", '%%%s%'], '^=', ["bg_workers.locked_by LIKE ?", '%s%'], '$=', ["bg_workers.locked_by LIKE ?", '%%%s'], '=', ["bg_workers.locked_by = ?"], '!=', ["bg_workers.locked_by <> ?"], 'NULL', ["bg_workers.locked_by IS NULL", ''], 'NOT_NULL', ["bg_workers.locked_by IS NOT NULL", '']],
    :completed_at => ActiveSupport::OrderedHash['=', ["bg_workers.completed_at = ?"], '!=', ["bg_workers.completed_at <> ?"], '>', ["bg_workers.completed_at > ?"], '<', ["bg_workers.completed_at < ?"], '>=', ["bg_workers.completed_at >= ?"], '<=', ["bg_workers.completed_at <= ?"]],
    :completed_at_min => ActiveSupport::OrderedHash['>=', ["bg_workers.completed_at >= ?"], '>', ["bg_workers.completed_at > ?"]],
    :completed_at_max => ActiveSupport::OrderedHash['<=', ["bg_workers.completed_at <= ?"], '<', ["bg_workers.completed_at < ?"]],
    :last_return_code => ActiveSupport::OrderedHash['=', ["bg_workers.last_return_code = ?"], '!=', ["bg_workers.last_return_code <> ?"], '>', ["bg_workers.last_return_code > ?"], '<', ["bg_workers.last_return_code < ?"], '>=', ["bg_workers.last_return_code >= ?"], '<=', ["bg_workers.last_return_code <= ?"]],
    :last_return_code_min => ActiveSupport::OrderedHash['>=', ["bg_workers.last_return_code >= ?"], '>', ["bg_workers.last_return_code > ?"]],
    :last_return_code_max => ActiveSupport::OrderedHash['<=', ["bg_workers.last_return_code <= ?"], '<', ["bg_workers.last_return_code < ?"]],
    :attempts => ActiveSupport::OrderedHash['=', ["bg_workers.attempts = ?"], '!=', ["bg_workers.attempts <> ?"], '>', ["bg_workers.attempts > ?"], '<', ["bg_workers.attempts < ?"], '>=', ["bg_workers.attempts >= ?"], '<=', ["bg_workers.attempts <= ?"]],
    :attempts_min => ActiveSupport::OrderedHash['>=', ["bg_workers.attempts >= ?"], '>', ["bg_workers.attempts > ?"]],
    :attempts_max => ActiveSupport::OrderedHash['<=', ["bg_workers.attempts <= ?"], '<', ["bg_workers.attempts < ?"]],
    :failed_at => ActiveSupport::OrderedHash['=', ["bg_workers.failed_at = ?"], '!=', ["bg_workers.failed_at <> ?"], '>', ["bg_workers.failed_at > ?"], '<', ["bg_workers.failed_at < ?"], '>=', ["bg_workers.failed_at >= ?"], '<=', ["bg_workers.failed_at <= ?"]],
    :failed_at_min => ActiveSupport::OrderedHash['>=', ["bg_workers.failed_at >= ?"], '>', ["bg_workers.failed_at > ?"]],
    :failed_at_max => ActiveSupport::OrderedHash['<=', ["bg_workers.failed_at <= ?"], '<', ["bg_workers.failed_at < ?"]],
  :logs => ActiveSupport::OrderedHash['=~', ["bg_workers.logs LIKE ?", '%%%s%'], '!~', ["bg_workers.logs NOT LIKE ?", '%%%s%'], '^=', ["bg_workers.logs LIKE ?", '%s%'], '$=', ["bg_workers.logs LIKE ?", '%%%s'], '=', ["bg_workers.logs = ?"], '!=', ["bg_workers.logs <> ?"], 'NULL', ["bg_workers.logs IS NULL", ''], 'NOT_NULL', ["bg_workers.logs IS NOT NULL", '']]}.freeze
  EVERIES = ["Once", "Hour", "6 hours", "12 hours", "Day", "Every weekday (mon - fri)", "2 days", "Week", "Fortnight", "Month", "2 months", "Quarter", "6 months", "Year"]
  LOCALIZED_EVERIES = [_("Once"), _("Hour"), _("6 hours"), _("12 hours"), _("Day"), _("Every weekday (mon - fri)"), _("2 days"), _("Week"), _("Fortnight"), _("Month"), _("2 months"), _("Quarter"), _("6 months"), _("Year")]
  TRIGGERED_BIES = ["Scheduled", "Code triggered", "User triggered", "On Start", "On Stop"]
  LOCALIZED_TRIGGERED_BIES = [_("Scheduled"), _("Code triggered"), _("User triggered"), _("On Start"), _("On Stop")]
  FILES_DEST = Rails.root.join('files', %q{bg_workers}).to_s


  # default values

  after_initialize do
    if self.new_record?

      self.no_duplicate ||= (true)
      self.priority ||= (0)
      self.attempts ||= (0)
    else

      self.no_duplicate = (true) if self.attributes.has_key?('no_duplicate') && self.no_duplicate.nil?

      self.priority ||= (0) if self.attributes.has_key?('priority')
      self.attempts ||= (0) if self.attributes.has_key?('attempts')
    end
  end

  #  after_find do
  #
  #      self.no_duplicate ||= (true)
  #      self.priority ||= (0)
  #      self.attempts ||= (0)
  # end
  # == Validations



  # == Triggers


  after_save(:update_config)
  after_save(:wake_and_check)


  # == Relations
  #
  # Associations through specific setters
  #
  # Virtual Fields


  attr_accessor :every__index_was
  attr_accessor :triggered_by__index_was

  def self.attribute_condition(quoted_column_name, argument)
    if quoted_column_name[/\.(\'|\`){0,1}(every|triggered_by)(__index){0,1}(\'|\`){0,1}\Z/]
      %Q[#{quoted_column_name.sub('__index', '')} = ?]
    else
      case argument
      when nil   then "#{quoted_column_name} IS ?"
      when Array, ActiveRecord::Associations::AssociationCollection, ActiveRecord::NamedScope::Scope then "#{quoted_column_name} IN (?)"
      when Range
        if argument.exclude_end?
          "#{quoted_column_name} >= ? AND #{quoted_column_name} < ?"
        else
          "#{quoted_column_name} BETWEEN ? AND ?"
        end
      else            "#{quoted_column_name} = ?"
      end
    end
  end


  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-09-03 16:56:08 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return BgWorker.new if att.blank?
    std_atts = att.reject{|k,v| %w(id).include?(k.to_s) }
    bg_worker = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      bg_worker = BgWorker.find(att[:id])
      bg_worker.attributes = std_atts
    else
      bg_worker = BgWorker.new(std_atts)
    end

    # clean associations
    #clean binaries
    #clean serialized data

    return bg_worker
  end


  # The disp_name is how any record will appear in most use cases, such as lists of associated records during 'show', 'list'...
  #
  # Faveod will try to guess the best single field, based on SID, usually from fields containing "Title", "Name" or "Label".
  #
  # Customized code often will often look like these snippets:
  # Multiple key: "#{self.first_name} #{self.last_name}"
  # Date or time: "#{self.name} #{self.created_at.strftime('%H:%M %y-%m-%d') if self.created_at}"
  # Associations: "#{self.name} #{self.user ? self.user.disp_name : _('No user')}"
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2011-05-31 17:21:54 UTC
  # Status:: Validated


  def disp_name
    self.name || ''
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      BgWorker.new.params_to_attributes(values).each { |k,v|
        case k.to_sym
        when :from
          cmp = comps["comp_from"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :from : "from_#{date_h[cmp]}"
          cond[field] = val
        when :cron
          cmp = comps["comp_cron"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :cron : "cron_#{string_h[cmp]}"
          cond[field] = val
        when :triggered_by
          cmp = comps["comp_triggered_by"]
          cmp ||= 'LIKE'
          vals = val.is_a?(Enumerable) ? val : v.split(',').map(&:to_i)
          vals = vals.map {|i| found = BgWorker::TRIGGERED_BIES.index(i);
          found ? found + 1 : i}
          val = cmp == 'IS NULL' ? nil : vals
          field = numb_h[cmp].nil? ? :triggered_by : "triggered_by_#{numb_h[cmp]}"
          cond[field] = val
        when :no_duplicate
          cmp = comps["comp_no_duplicate"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :no_duplicate : "no_duplicate_#{numb_h[cmp]}"
          cond[field] = val
        when :priority
          cmp = comps["comp_priority"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :priority : "priority_#{numb_h[cmp]}"
          cond[field] = val
        when :planned_at
          cmp = comps["comp_planned_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :planned_at : "planned_at_#{date_h[cmp]}"
          cond[field] = val
        when :created_at
          cmp = comps["comp_created_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :created_at : "created_at_#{date_h[cmp]}"
          cond[field] = val
        when :started_at
          cmp = comps["comp_started_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :started_at : "started_at_#{date_h[cmp]}"
          cond[field] = val
        when :locked_at
          cmp = comps["comp_locked_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :locked_at : "locked_at_#{date_h[cmp]}"
          cond[field] = val
        when :locked_by
          cmp = comps["comp_locked_by"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :locked_by : "locked_by_#{string_h[cmp]}"
          cond[field] = val
        when :completed_at
          cmp = comps["comp_completed_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :completed_at : "completed_at_#{date_h[cmp]}"
          cond[field] = val
        when :last_return_code
          cmp = comps["comp_last_return_code"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :last_return_code : "last_return_code_#{numb_h[cmp]}"
          cond[field] = val
        when :attempts
          cmp = comps["comp_attempts"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :attempts : "attempts_#{numb_h[cmp]}"
          cond[field] = val
        when :failed_at
          cmp = comps["comp_failed_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :failed_at : "failed_at_#{date_h[cmp]}"
          cond[field] = val
        when :logs
          cmp = comps["comp_logs"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :logs : "logs_#{string_h[cmp]}"
          cond[field] = val
        end
      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Makes all kind of calculations for reports.
  #
  # Author:: Yann Azoury
  # Version:: 20
  # Last Update:: 2013-02-27 12:27:37 UTC
  # Status:: Should be optimized


  def self.report_calculation(op, field = :id, opts = {})
    scope	= opts[:scope]
    labels	= opts[:labels]	  || []
    step	= opts[:step]
    group	= opts[:group]
    ret_hash= opts[:ret_hash] || false
    opsym	= case op
    when :count, 'count'			then field = :id ; :count
    when :avg, 'avg', 'average', :average	then :avg
    when :value, 'value', :sum, 'sum'	then :sum
    when :min, 'min', :minimum, 'minimum'	then :min
    when :max, 'max', :maximum, 'maximum'	then :max
    else field = :id ; :count
    end
    case group
    when nil
      return scope.blank? ? self.calculate(opsym, field) : with_scope(:find => {:conditions => scope}) { self.calculate(opsym, field) }

    when :every, 'every'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'every')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'every')
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :triggered_by, 'triggered_by'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'triggered_by')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'triggered_by')
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :no_duplicate, 'no_duplicate'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'no_duplicate')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'no_duplicate')
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :start_cond_overview, 'start_cond_overview'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'start_cond_overview')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'start_cond_overview')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :cron, 'cron'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'cron')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'cron')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :name, 'name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'name')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'name')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :locked_by, 'locked_by'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'locked_by')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'locked_by')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :priority, 'priority'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["bg_workers.priority >= ? AND bg_workers.priority < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["bg_workers.priority >= ? AND bg_workers.priority < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :last_return_code, 'last_return_code'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["bg_workers.last_return_code >= ? AND bg_workers.last_return_code < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["bg_workers.last_return_code >= ? AND bg_workers.last_return_code < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :attempts, 'attempts'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["bg_workers.attempts >= ? AND bg_workers.attempts < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["bg_workers.attempts >= ? AND bg_workers.attempts < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :from, 'from'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(bg_workers.from)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(bg_workers.from),'-', WEEK(bg_workers.from))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(bg_workers.from),'-', MONTH(bg_workers.from))"
        when :year
          lab_format = '%Y'
          "YEAR(bg_workers.from)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'from')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'from')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :planned_at, 'planned_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(bg_workers.planned_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(bg_workers.planned_at),'-', WEEK(bg_workers.planned_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(bg_workers.planned_at),'-', MONTH(bg_workers.planned_at))"
        when :year
          lab_format = '%Y'
          "YEAR(bg_workers.planned_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'planned_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'planned_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :created_at, 'created_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(bg_workers.created_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(bg_workers.created_at),'-', WEEK(bg_workers.created_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(bg_workers.created_at),'-', MONTH(bg_workers.created_at))"
        when :year
          lab_format = '%Y'
          "YEAR(bg_workers.created_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'created_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'created_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :started_at, 'started_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(bg_workers.started_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(bg_workers.started_at),'-', WEEK(bg_workers.started_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(bg_workers.started_at),'-', MONTH(bg_workers.started_at))"
        when :year
          lab_format = '%Y'
          "YEAR(bg_workers.started_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :locked_at, 'locked_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(bg_workers.locked_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(bg_workers.locked_at),'-', WEEK(bg_workers.locked_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(bg_workers.locked_at),'-', MONTH(bg_workers.locked_at))"
        when :year
          lab_format = '%Y'
          "YEAR(bg_workers.locked_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'locked_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'locked_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :completed_at, 'completed_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(bg_workers.completed_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(bg_workers.completed_at),'-', WEEK(bg_workers.completed_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(bg_workers.completed_at),'-', MONTH(bg_workers.completed_at))"
        when :year
          lab_format = '%Y'
          "YEAR(bg_workers.completed_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :failed_at, 'failed_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(bg_workers.failed_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(bg_workers.failed_at),'-', WEEK(bg_workers.failed_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(bg_workers.failed_at),'-', MONTH(bg_workers.failed_at))"
        when :year
          lab_format = '%Y'
          "YEAR(bg_workers.failed_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'failed_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'failed_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["bg_workers.#{group} >= ? AND bg_workers.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    else
      logger.debug("Unknown Group: #{group} (operation: #{opsym}, scope: #{scope})")
    end
    return []
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = BgWorker.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.bgworker_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    BgWorker.first(:order => 'bg_workers.id DESC', :conditions => ["bg_workers.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    BgWorker.first(:order => 'bg_workers.id', :conditions => ["bg_workers.id > ?", self.id])
  end

  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-01-15 16:26:22 UTC


  def self.named_scope_default_scope_method
    {:order => 'priority DESC, planned_at ASC'}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Sylvain Abélard
  # Version:: 7
  # Last Update:: 2010-01-15 16:26:49 UTC


  def self.named_scope_next_tasks_method
    {
      :order => 'priority DESC, planned_at ASC',
      :conditions =>
      ['(run_at <= ? AND (locked_at IS NULL OR locked_at < ?) OR (locked_by = ?)) AND failed_at IS NULL',
      Time.now, Time.now - self.max_run_time, self.worker_name]
    }
  end

  scope(:next_tasks, proc { named_scope_next_tasks_method })

  # Author:: Sylvain Abélard
  # Version:: 8
  # Last Update:: 2010-01-08 10:44:57 UTC


  def self.named_scope_with_priority_method(mini=nil, maxi=nil)
    min = mini
    max = maxi
    if mini.is_a?(Array)
      min = mini[0]
      max = mini[1]
    end
    min ||= self.min_priority
    max ||= self.max_priority
    return {} if min.blank? && max.blank?
    c = []
    if min.blank?
      c = ['priority <= ?', max]
    elsif max.blank?
      c = ['priority >= ?', min]
    else
      c = ['priority >= ? AND priority <= ?', min, max]
    end
    {:conditions => c}
  end

  scope(:with_priority, proc {|mini| named_scope_with_priority_method(mini) })

  # Author:: Sylvain Abélard
  # Version:: 2
  # Last Update:: 2010-01-15 16:24:53 UTC


  def self.named_scope_running_method
    {:conditions => 'locked_at IS NOT NULL'}
  end

  scope(:running, proc { named_scope_running_method })

  # Author:: Sylvain Abélard
  # Version:: 2
  # Last Update:: 2010-01-15 16:25:25 UTC


  def self.named_scope_queued_method
    {
      :order => 'planned_at DESC',
      :conditions => 'locked_at IS NULL'
    }
  end

  scope(:queued, proc { named_scope_queued_method })

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      if [:from, :cron, :triggered_by, :no_duplicate, :name, :priority, :planned_at, :created_at, :started_at, :locked_at, :locked_by, :completed_at, :last_return_code, :attempts, :failed_at, :logs
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [:every
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })


# Background Worker: YAML config management.
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:28:35 UTC
# Status:: Deprecated


def update_config

logger.warn("Warning: Executing deprecated method 'update_config' from BgWorker")
return true
config_file = Rails.root.join('config', 'backgroundrb.yml')
config = YAML.load(File.open(config_file, 'r'))
config[:schedules] ||= {}
logger.debug("config: #{config.inspect}")
if self.enabled?
  config[:schedules] = {"#{self.name.underscore.gsub(/\s/, '_')}_worker".to_sym => {:do_work => {:trigger_args => self.to_cron_format }}}
else
  config[:schedules].delete("#{self.name.underscore.gsub(/\s/, '_')}_worker".to_sym)
end
File.open(config_file, "w") do |out|
  YAML.dump(config, out)
end
end


# Background Worker: CRONTAB format.
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Sylvain Abélard
# Version:: 5
# Last Update:: 2010-06-16 14:42:34 UTC
# Status:: Deprecated


def to_cron_format

logger.warn("Warning: Executing deprecated method 'to_cron_format' from BgWorker")
[ second_interval 	||
  '*', minute_interval 	||
  '*' , hour_interval 	||
  '*', day_interval 	||
  '*', month_interval	||
  '*', weekday_interval ||
  '*', year_interval 	||
'*'].join(' ')
end


# WARNING: DEPRECATED!
# Background Worker: BackgrounDRb status.
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:31:44 UTC
# Status:: Deprecated


def self.bgdrb_connected?

logger.warn("Warning: Executing deprecated method 'bgdrb_connected?' from BgWorker")
@bg_running = false
begin

  #  @bg_running = MiddleMan.instance_variable_get("@connection_status")

  config = BackgrounDRb::Config.read_config(Rails.root.join("config", "backgroundrb.yml"))
  pid_file = Rails.root.join("tmp", "pids", "backgroundrb_#{config[:backgroundrb][:port]}.pid")

  #  logger.debug("PID FILE: #{pid_file}")

  return false if !File.exists?(pid_file)
  @bg_running = true
  pid = IO.read(pid_file).to_i
  if RUBY_PLATFORM =~ /linux/
    ps_res = []
    IO.popen("ps -p #{pid}") { |io| ps_res = io.readlines }

    #    logger.debug("PS_RES = #{ps_res.inspect}")

    return false if ps_res.length < 2
  end
rescue => e
  logger.warn("Error during 'bgdrb_connected': #{e}")
end
return @bg_running
end


# WARNING: DEPRECATED!
# Background Worker: start BackgrounDRb server.
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 14:43:24 UTC
# Status:: Deprecated


def self.start_server

logger.warn("Warning: Executing deprecated method 'start_server' from BgWorker")
IO.popen('./script/backgroundrb start') {} unless self.bgdrb_connected?
end


# WARNING: DEPRECATED!
# Background Worker: stop BackgrounDRb server.
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2013-03-31 21:30:08 UTC
# Status:: Deprecated


def self.stop_server

logger.warn("Warning: Executing deprecated method 'stop_server' from BgWorker")
config = BackgrounDRb::Config.read_config(Rails.root.join("config", "backgroundrb.yml"))
pid_file = Rails.root.join("tmp", "pids", "backgroundrb_#{config[:backgroundrb][:port]}.pid")
begin
  pid = nil
  File.open(pid_file, "r") { |pid_handle| pid = pid_handle.gets.strip.chomp.to_i }
  Process.kill('TERM', pid) ; Process.kill('KILL', pid)
ensure
  File.delete(pid_file) if File.exists?(pid_file)
end
IO.popen('./script/backgroundrb stop') {}
end


# WARNING: DEPRECATED!
# Background Worker: parsing results.
#
#--
# DEPRECATED: this method would be removed
#++
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-02-27 11:07:57 UTC
# Status:: Deprecated


def self.parse_part(part, range=nil)

logger.warn("Warning: Executing deprecated method 'parse_part' from BgWorker")
return range  if part.nil? or part == '*' or part =~ /\A[*0]\/1\Z/
r = Array.new
part.split(',').each do |p|
  if p =~ /-/  # 0-5
    r << Range.new(*(p.scan(/\d+/).map { |x| x.to_i })).map { |x| x.to_i }
  elsif p =~ /(\*|\d+)\/(\d+)/ && range  # */5, 2/10
    min = $1 == '*' ? 0 : $1.to_i
    inc = $2.to_i
    (min .. range.end).each_with_index do |x, i|
      r << (range.begin == 1 ? x + 1 : x) if i % inc == 0
      end
    else
      r << p.to_i
    end
  end
  r.flatten
end


# Background Worker: find when to run a given task next.
#
# Author:: Sylvain Abélard
# Version:: 6
# Last Update:: 2010-06-16 14:46:18 UTC
# Status:: Should be optimized


def next_time(cron_expr, current_time = Time.now)
  wdays = {
    0 => "Sunday",
    1 => "Monday",
    2 => "Tuesday",
    3 => "Wednesday",
    4 => "Thursday",
    5 => "Friday",
    6 => "Saturday"
  }

  # sec = min = hour = day = month = wday = year = ""

  sec, min, hour, day, month, wday, year = cron_expr.split(' ')
  t_sec,t_min,t_hour,t_day,t_month,t_year,t_wday,t_yday,t_idst,t_zone = current_time.to_a
  sec	= BgWorker.parse_part(sec, 0 .. 59)
  min	= BgWorker.parse_part(min, 0 .. 59)
  hour	= BgWorker.parse_part(hour, 0 .. 23)
  day	= BgWorker.parse_part(day, 1 .. 31)
  month	= BgWorker.parse_part(month, 1 .. 12)
  year	= BgWorker.parse_part(year)
  wday	= BgWorker.parse_part(wday, 0 .. 6)
  if year && !year.include?(t_year)
    return nil if t_year > year.max
    t_year = year.detect { |y| y > t_year }
  end
  unless month.include?(t_month)
    next_month = month.detect { |m| m > t_month } || month.min
    t_day,t_hour,t_min,t_sec = day.min,hour.min,min.min,sec.min
    if next_month < t_month
      t_month = next_month
      t_year += 1
    end
    t_month = next_month
  end
  if !(!day.eql?(1..31)) && (!wday.eql?(0..6))
    unless wday.include?(t_wday)
      next_wday = wday.detect { |w| w > t_wday} || wday.min
      t_hour,t_min,t_sec = hour.min,min.min,sec.min
      t_time = Chronic.parse("next #{wdays[next_wday]}",:now => current_time)
      t_day,t_month,t_year = t_time.to_a[3..5]
      t_wday = next_wday
    end
  elsif !(!wday.eql?(0..6)) && (!day.eql?(1..31))
    lday = (Date.new(t_year, t_month, 1).next_month - 1.day).day
    day_range = (1..lday)
    day_array = day.select { |d| day_range === d }
    unless day_array.include?(t_day)
      next_day = day_array.detect { |d| d > t_day } || day_array.min
      t_hour,t_min,t_sec = hour.min,min.min,sec.min
      if !next_day || next_day < t_day
        t_time = Chronic.parse("next month",:now => current_time)
        t_day = next_day.nil? ? day.min : next_day
        t_month,t_year = t_time.month,t_time.year
      end
      t_day = next_day
    end
  else
    lday = (Date.new(t_year, t_month, 1).next_month - 1.day).day
    day_range = (1..lday)
    day_array = day.select { |d| day_range === d }
    if !day_array.include?(t_day) && !wday.include?(t_wday)
      next_day = day_array.detect { |d| d > t_day } || day_array.min
      next_wday = wday.detect { |w| w > t_wday } || wday.min
      t_hour,t_min,t_sec = hour.min,min.min,sec.min
      if !next_day || next_day < t_day
        next_time_mday = Chronic.parse("next month",:now => current_time)
      else
        t_day = next_day
        next_time_mday = current_time
      end
      next_time_wday = Chronic.parse("next #{WDAYS[next_wday]}",:now => current_time)
      if next_time_mday < next_time_wday
        t_day,t_month,t_year = next_time_mday.to_a[3..5]
      else
        t_day,t_month,t_year = next_time_wday.to_a[3..5]
      end
    end
  end
  unless hour.include?(t_hour)
    next_hour = hour.detect { |h| h > t_hour } || hour.min
    t_min,t_sec = min.min,sec.min
    if next_hour < t_hour
      t_hour = next_hour
      next_day = Chronic.parse("next day",:now => current_time)
      t_day,t_month,t_year,t_wday = next_day.to_a[3..6]
    end
    t_hour = next_hour
  end
  unless min.include?(t_min)
    next_min = min.detect { |m| m > t_min } || min.min
    t_sec = sec.min
    if next_min < t_min
      t_min = next_min
      next_hour = Chronic.parse("next hour",:now => current_time)
      t_hour,t_day,t_month,t_year,t_wday = next_hour.to_a[2..6]
    end
    t_min = next_min
  end
  unless sec.include?(t_sec)
    next_sec = sec.detect { |s| s > t_sec } || sec.min
    if next_sec < t_sec
      t_sec = next_sec
      next_min = Chronic.parse("next minute",:now => current_time)
      t_min,t_hour,t_day,t_month,t_year,t_wday = next_min.to_a[1..6]
    end
    t_sec = next_sec
  end
  return Time.local(t_sec,t_min,t_hour,t_day,t_month,t_year,t_wday,nil,t_idst,t_zone)
end


# Background Worker: name.
#
# Author:: Sylvain Abélard
# Version:: 6
# Last Update:: 2010-06-16 14:52:51 UTC
# Status:: Validation Pending


def self.worker_name
  "host:#{Socket.gethostname} pid:#{Process.pid}" rescue "pid:#{Process.pid}"
end


# Background Worker: clears all locks.
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2010-06-16 14:53:01 UTC
# Status:: Validation Pending


def self.clear_locks!(worker_name=nil)
  if worker_name
    update_all("locked_by = null, locked_at = null", ["locked_by = ?", worker_name])
  else
    update_all("locked_by = null, locked_at = null")
  end
end


# Background Worker: returns nil if not failed, not nil if failed.
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 14:53:28 UTC
# Status:: Validation Pending


def failed?
  self.failed_at
end


# Background Workers: reschedules a failed job.
# The more a job fails, the longer the delay.
# With too many fails, a job will eventually fail.
#
# Author:: Sylvain Abélard
# Version:: 13
# Last Update:: 2010-06-16 15:17:09 UTC
# Status:: Validation Pending


def reschedule(message, backtrace=[], time=nil)
  if self.attempts < BgWorker.max_attempts
    time ||= Time.now + (attempts ** 4) + 5
    self.attempts += 1
    self.planned_at = time
    self.logs ||= ''
    self.logs = "[#{Time.now}]"+ message + "\n" + backtrace.join("\n") + self.logs
    self.unlock
    save!
  else
    BgWorker.log "* [JOB][#{self.name}] PERMANENTLY removing because of #{attempts} consequetive failures."
    BgWorker.destroy_failed_jobs? ? destroy : update_attribute(:failed_at, Time.now)
  end
end


# Background Worker: returns true if we should destroy failed jobs.
#
# Author:: Sylvain Abélard
# Version:: 5
# Last Update:: 2010-06-16 14:55:10 UTC
# Status:: Validated


def self.destroy_failed_jobs?
  SystemSetting['background_worker - destroy_failed_jobs'] || false
end


# Background Worker: starts a worker.
#
# Author:: Sylvain Abélard
# Version:: 21
# Last Update:: 2010-06-16 14:56:05 UTC
# Status:: Validation Pending


def start(options=nil)
  BgWorker.log("Worker: Starting #{BgWorker.worker_name}")
  begin

    # trap('TERM') { BgWorker.log 'Worker: Exiting...'; $exit = true }
    # trap('INT')  { BgWorker.log 'Worker: Exiting...'; $exit = true }

    loop do
      result = nil
      realtime = Benchmark.realtime do
        result = BgWorker.work_off(options)
      end
      count = result.sum

      # break if $exit

      if count.zero?
        self.sleep
      else
        BgWorker.log("Worker: #{count} jobs processed at %.4f j/s, %d failed ..." % [count / realtime, result.last])
      end

      # break if $exit

    end
  ensure
    BgWorker.log("Worker: clearing locks")
    BgWorker.clear_locks!
  end
end


# Background Worker: shortcut: returns the "background_worker - quiet" system setting, or FALSE.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2010-06-16 14:57:18 UTC
# Status:: Validated


def self.quiet?
  SystemSetting['background_worker - quiet'] || false
end


# Background Worker: returns minimum priority for jobs to be considered, or NIL.
#
# Author:: Sylvain Abélard
# Version:: 6
# Last Update:: 2010-06-16 14:57:36 UTC
# Status:: Validated


def self.min_priority
  SystemSetting['background_worker - min_priority'] || ENV['MIN_PRIORITY'] || nil
end


# Background Worker: returns maximum priority to consider jobs, or NIL.
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 14:57:56 UTC
# Status:: Validated


def self.max_priority
  SystemSetting['background_worker - max_priority'] || ENV['MAX_PRIORITY'] || nil
end


# Uses a MaVeoC-specific log in a separate file.
#
# Author:: Yann Azoury
# Version:: 13
# Last Update:: 2012-04-22 01:52:33 UTC
# Status:: Validated


def self.log(*args)
  file = Rails.public_path.join('bg_worker.log')
  File.open(file, 'a+') {|f|
  f.write("[#{Process.pid}][#{Time.now.strftime('%H:%M:%S')}] #{args.join(': ')}\n")}
end


# Background Worker: puts jobs to sleep.
#
# Author:: Sylvain Abélard
# Version:: 6
# Last Update:: 2010-06-16 14:59:03 UTC
# Status:: Validated


def sleep
  next_task = BgWorker.queued.first
  if next_task
    lapse = next_task.planned_at - Time.now
    if lapse > 0
      BgWorker.log("Thread: next task at #{next_task.planned_at}, sleeping for #{lapse}s")
      sleep (lapse)

      #else
      #  BgWorker.log("Thread: next tasks are waiting, going on to next loop...")

    end
  else
    BgWorker.log("Thread: no next task - sleeping")
    sleep
  end
end


# Background Worker: returns maximum job attempts, or 25.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2010-06-16 14:59:35 UTC
# Status:: Validated


def self.max_attempts
  SystemSetting['background_worker - max_attempts'] || 25
end


# Author:: Sylvain Abélard
# Version:: 1
# Last Update:: 2009-12-29 11:39:43 UTC
# Status:: Validated


def self.max_run_time
  SystemSetting['background_worker - max_run_time'] || 4.hours
end


# Beware, this state is not saved to the DB.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2010-01-06 12:58:49 UTC
# Status:: Validation Pending


def unlock
  self.locked_at = nil
  self.locked_by = nil
end


# Background Worker: runs a task.
#
# Author:: Sylvain Abélard
# Version:: 27
# Last Update:: 2010-06-16 15:00:13 UTC
# Status:: Validated


def self.run_task(task, triggered_by=2, force_launch=false)
  if task.is_a?(BgWorker)
    updated = task.update_attributes(:planned_at => Time.now, :triggered_by => 3)
    BgWorker.reserve_and_run_one_job({:task => task}) if force_launch && updated
  else
    name = if task.is_a?(Hash)
      task[:fullname]
    else
      task
    end

    # TASK : add job in database
    # BgWorker.log("Jobs: add job to DB #{task.inspect}")

    db_task = BgWorker.create(:name => name, :planned_at => Time.now, :triggered_by => triggered_by)
    BgWorker.reserve_and_run_one_job({:task => db_task}) if force_launch && !db_task.new_record?
  end
end


# Background Worker: locks and launches task.
#
# Author:: Sylvain Abélard
# Version:: 10
# Last Update:: 2010-06-16 15:01:09 UTC
# Status:: Validation Pending


def run_with_lock(max_run_time=nil, worker_name=nil)
  BgWorker.log "* [JOB][#{name}] aquiring lock"
  max_run_time ||= BgWorker.max_run_time
  worker_name  ||= BgWorker.worker_name
  unless lock_exclusively!(max_run_time, worker_name)

    # We did not get the lock, some other worker process must have

    BgWorker.log "* [JOB][#{name}] failed to aquire exclusive lock"
    return nil # no work done
  end
  begin
    runtime = Benchmark.realtime do
      invoke_job # TODO: raise error if takes longer than max_run_time
    end

    # TODO: warn if runtime > max_run_time ?

    BgWorker.log "* [JOB][#{name}] completed after %.4f" % runtime
    return true # did work
  rescue Exception => e
    BgWorker.log("* [JOB][#{name}] failed with #{error.class.name}: #{error.message} - #{attempts} failed attempts")
    reschedule e.message, e.backtrace
    return false # work failed
  end
end


# Get some (non-locked) jobs and execute them.
#
# Author:: Yann Azoury
# Version:: 21
# Last Update:: 2012-04-22 01:28:00 UTC
# Status:: Validation Pending


def self.reserve_and_run_one_job(options={})
  if options[:task]
    opt = options[:task]
    job = if opt.is_a?(BgWorker)
      opt
    elsif opt.is_a?(Hash)
      BgWorker.find_by_name(opt[:fullname])
    else
      BgWorker.find_by_name(opt)
    end
    return job.run_with_lock(options[:max_run_time], options[:worker_name]) if job
  else
    next_tasks = BgWorker.next_tasks.with_priority(
    options[:min_priority] || BgWorker.min_priority,
    options[:max_priority] || BgWorker.max_priority).all(:limit => 5)

    # BgWorker.log("Worker: #{next_tasks.count} next tasks found")

    next_tasks.each do |job|
      t = job.run_with_lock(options[:max_run_time], options[:worker_name])
      return t unless t == nil # return if we did work (good or bad)
    end
    nil
  end
end


# Background Worker: puts an exclusive lock on a task.
#
# Author:: Sylvain Abélard
# Version:: 11
# Last Update:: 2010-06-16 15:01:38 UTC
# Status:: Validation Pending


def lock_exclusively!(max_run_time=nil, worker=nil)

  # BgWorker.log "Worker: #{worker.inspect} locking jobs"

  max_run_time	||= BgWorker.max_run_time
  worker		||= BgWorker.worker_name
  now 		  = Time.now
  if locked_at.nil? || locked_at < now - max_run_time
    self.update_attributes(:locked_at => now, :locked_by => worker, :started_at => now)
  else
    return false
  end
end


# Background Worker: current job runs task after task, then returns a quick report.
#
# Author:: Sylvain Abélard
# Version:: 11
# Last Update:: 2010-06-16 15:02:34 UTC
# Status:: Validation Pending


def self.work_off(options=nil)

  # BgWorker.log("Worker: work_offloading")

  options	||= {}
  success, failure = 0, 0
  (options[:num] || 100).times do
    case self.reserve_and_run_one_job(options)
    when true
      success += 1
    when false
      failure += 1
    else
      break # leave if no work could be done
    end
    break if $exit # leave if we're exiting
  end
  return [success, failure]
end


# Invokes a job.
#
# Author:: Yann Azoury
# Version:: 17
# Last Update:: 2012-04-22 01:53:00 UTC
# Status:: Validation Pending


def invoke_job

  # BgWorker.log("Worker: invoke job")

  fork {

    # BgWorker.log("Worker: fork: system 'cd #{Rails.root}; rake #{self.name}'")

    `cd #{Rails.root}; rake #{self.name}`

    # BgWorker.log("Worker: fork: closing job #{res ? 'OK' : 'KO'}, return code: #{$?}")

    self.close_job($?)
  }
end


# Background Worker: starts a new worker in a new thread.
#
# Author:: Sylvain Abélard
# Version:: 10
# Last Update:: 2010-06-16 15:03:01 UTC
# Status:: Validation Pending


def self.start_worker

  # WORK : the worker will fetch jobs and run them

  BgWorker.log("Worker: start_worker")

  # TODO: THREAD STUFF

  Thread.new {
    Thread.current[:name] = "background_worker"
    BgWorker.log("Worker: new worker thread starting...")
    BgWorker.new.start
  }
end


# Background Worker: gets task hash.
#
# Author:: Sylvain Abélard
# Version:: 10
# Last Update:: 2010-06-16 15:03:29 UTC
# Status:: Validated


def self.task(attributes={})
  t = {
    :namespace	=> '',
    :desc		=> '',
    :name		=> '',
    :filename	=> '',
    :dependencies	=> '',
    :args		=> '',
    :code		=> ''
  }.merge(attributes)
  t[:name] = t[:name].gsub('bg_worker_', '')
  t[:fullname] = t[:namespace].blank? ? "bg_worker_#{t[:name]}" : "#{t[:namespace]}:bg_worker_#{t[:name]}"
  t
end


# Background Worker: outputs results and closes a job.
#
# Author:: Sylvain Abélard
# Version:: 21
# Last Update:: 2010-06-16 15:03:54 UTC
# Status:: Validation Pending


def close_job(errcode)
  repeat = case self.every__index

    # when 1 # once

  when 2;  1.hour
  when 3;  6.hours
  when 4;  12.hours
  when 5;  1.day
  when 6 #weekday
    res = 1
    res += 1.day until (1..5).member?((self.planned_at + res).wday)
    res
  when 7;  2.days
  when 8;  1.week
  when 9;  2.weeks #fortnight
  when 10; 1.month
  when 11; 2.months
  when 12; 3.months #quarter
  when 13; 6.months
  when 14; 1.year
  else
    nil
  end
  up = {
    :completed_at	=> Time.now,
    :locked_at	=> nil,
    :locked_by	=> nil,

    #	:last_error	=> 0,

    :attempts	=> 0,
    :logs		=> "[#{Time.now}]"+ message + "\n" + backtrace.join("\n") + (self.logs.to_s)
  }
  if repeat
    up[:planned_at] = self.planned_at + repeat
    BgWorker.log "* [JOB][#{self.name}] rescheduling at #{up[:planned_at]} (#{self.every})"
  end
  ActiveRecord::Base.connection.reconnect! if !ActiveRecord::Base.connected?
  updated = self.update_attributes(up)
  BgWorker.log "* [JOB][#{self.name}] closed"
end


# Background Worker: useful display of a task's start condition.
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2010-06-16 15:05:21 UTC
# Status:: Validation Pending


def start_cond_overview
  if !self.triggered_by.blank?
    "#{_('Event')}: #{self.triggered_by}"
  elsif !self.cron.blank?
    "#{Cron}: #{self.cron}"
  elsif self.every__index == 1
    _("No repetition")
  else
    "#{_('Every')} #{_(self.every)}, #{_('starting')} #{self.from}"
  end
end


# Background Worker: wakes a worker.
#
# Author:: Sylvain Abélard
# Version:: 18
# Last Update:: 2010-06-16 15:05:32 UTC
# Status:: Validated


def self.wakeup
  Thread.list.each {|t|
    if t[:name] == 'background_worker'
      BgWorker.log("wakeup: woke a thread")
      t.wakeup
    end
  }
end


# Background Worker: wakes a worker.
#
# Author:: Sylvain Abélard
# Version:: 8
# Last Update:: 2010-06-16 15:05:48 UTC
# Status:: Validated


def wake_and_check
  BgWorker.wakeup
  return true
end

def self.assoc_sids_to_columns(attrs)
  h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs
  if attrs.has_key?(:conditions)
    attrs[:conditions] = h
    attrs
  else
    h
  end
end


#== Field Logics



# Returns translated string value.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-03-21 11:35:21 UTC
# Status:: Validated


def every(t = false)
  return [] if read_attribute(:every).nil? || read_attribute(:every) == 0
  return read_attribute(:every) if read_attribute(:every).is_a?(Array)
  read_attribute(:every).split(',').map{|i| _(EVERIES[i.to_i - 1].to_s) }
end


# Returns the 1-based index(es).
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 00:13:42 UTC
# Status:: Validated


def every__index
  (read_attribute(:every) || '').split(',').map{|i| i.to_i}
end


# Returns the potential values for this list.
#
# Author:: Yann Azoury
# Version:: 2
# Last Update:: 2011-08-09 11:09:07 UTC
# Status:: Validated


def every__potential_values(current_user = nil)
  EVERIES
end


# Flexible setter for the static list.
#
# Author:: Yann Azoury
# Version:: 12
# Last Update:: 2013-09-03 16:56:09 UTC
# Status:: Validated


def every=(val)

  self.every__index_was = self.every__index
  res = Array(val).compact.map{|i|
    case i
    when nil
      nil
    when 1..14 # index
      i
    when *EVERIES
      EVERIES.index(i) + 1
    when "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14" # index as string
      i.to_i
    end
  }.compact.join(',')
  write_attribute(:every, res)
end


# Returns translated string value.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-03-21 11:35:21 UTC
# Status:: Validated


def triggered_by(t = false)
  return nil if read_attribute(:triggered_by).nil? || read_attribute(:triggered_by) == 0
  return t ? _(TRIGGERED_BIES[(read_attribute(:triggered_by)) - 1].to_s) : TRIGGERED_BIES[(read_attribute(:triggered_by)) - 1].to_s
end


# Returns the 1-based index(es).
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 00:13:42 UTC
# Status:: Validated


def triggered_by__index
  return read_attribute(:triggered_by)
end


# Returns the potential values for this list.
#
# Author:: Yann Azoury
# Version:: 2
# Last Update:: 2011-08-09 11:09:07 UTC
# Status:: Validated


def triggered_by__potential_values(current_user = nil)
  TRIGGERED_BIES
end


# Flexible setter for the static list.
#
# Author:: Yann Azoury
# Version:: 12
# Last Update:: 2013-09-03 16:56:09 UTC
# Status:: Validated


def triggered_by=(val)

  self.triggered_by__index_was = self.triggered_by__index
  case val
  when nil
    write_attribute(:triggered_by, nil)
  when 1..5 # index
    write_attribute(:triggered_by, val)
  when "1", "2", "3", "4", "5" # index as string
    write_attribute(:triggered_by, val.to_i)
  when *(self.triggered_by__potential_values) # value
    write_attribute(:triggered_by, self.triggered_by__potential_values.index(val) + 1)
  when *LOCALIZED_TRIGGERED_BIES # localized value
    write_attribute(:triggered_by, LOCALIZED_TRIGGERED_BIES.index(val) + 1)
  else
    write_attribute(:triggered_by, nil)
  end
end

# BINARIES CONSTANTS


end
