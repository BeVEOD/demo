# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Wed Aug 28 16:13:34 +0200 2013
## It should be placed at 'app/models/uncatched_exception.rb'
## All manual modifications will be destroyed on next generation
################################################


class UncatchedException < ActiveRecord::Base

  self.table_name = 'uncatched_exceptions'

  SEARCHABLE_FIELDS = [:created_at].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:exception_class => :string, :controller_name => :string, :action_name => :string, :message => :text, :backtrace => :text, :environment => :text, :request => :text, :created_at => :datetime).freeze
  COMPARATORS = {:exception_class => ActiveSupport::OrderedHash['=~', ["uncatched_exceptions.exception_class LIKE ?", '%%%s%'], '!~', ["uncatched_exceptions.exception_class NOT LIKE ?", '%%%s%'], '^=', ["uncatched_exceptions.exception_class LIKE ?", '%s%'], '$=', ["uncatched_exceptions.exception_class LIKE ?", '%%%s'], '=', ["uncatched_exceptions.exception_class = ?"], '!=', ["uncatched_exceptions.exception_class <> ?"], 'NULL', ["uncatched_exceptions.exception_class IS NULL", ''], 'NOT_NULL', ["uncatched_exceptions.exception_class IS NOT NULL", '']],
    :controller_name => ActiveSupport::OrderedHash['=~', ["uncatched_exceptions.controller_name LIKE ?", '%%%s%'], '!~', ["uncatched_exceptions.controller_name NOT LIKE ?", '%%%s%'], '^=', ["uncatched_exceptions.controller_name LIKE ?", '%s%'], '$=', ["uncatched_exceptions.controller_name LIKE ?", '%%%s'], '=', ["uncatched_exceptions.controller_name = ?"], '!=', ["uncatched_exceptions.controller_name <> ?"], 'NULL', ["uncatched_exceptions.controller_name IS NULL", ''], 'NOT_NULL', ["uncatched_exceptions.controller_name IS NOT NULL", '']],
    :action_name => ActiveSupport::OrderedHash['=~', ["uncatched_exceptions.action_name LIKE ?", '%%%s%'], '!~', ["uncatched_exceptions.action_name NOT LIKE ?", '%%%s%'], '^=', ["uncatched_exceptions.action_name LIKE ?", '%s%'], '$=', ["uncatched_exceptions.action_name LIKE ?", '%%%s'], '=', ["uncatched_exceptions.action_name = ?"], '!=', ["uncatched_exceptions.action_name <> ?"], 'NULL', ["uncatched_exceptions.action_name IS NULL", ''], 'NOT_NULL', ["uncatched_exceptions.action_name IS NOT NULL", '']],
    :message => ActiveSupport::OrderedHash['=~', ["uncatched_exceptions.message LIKE ?", '%%%s%'], '!~', ["uncatched_exceptions.message NOT LIKE ?", '%%%s%'], '^=', ["uncatched_exceptions.message LIKE ?", '%s%'], '$=', ["uncatched_exceptions.message LIKE ?", '%%%s'], '=', ["uncatched_exceptions.message = ?"], '!=', ["uncatched_exceptions.message <> ?"], 'NULL', ["uncatched_exceptions.message IS NULL", ''], 'NOT_NULL', ["uncatched_exceptions.message IS NOT NULL", '']],
    :backtrace => ActiveSupport::OrderedHash['=~', ["uncatched_exceptions.backtrace LIKE ?", '%%%s%'], '!~', ["uncatched_exceptions.backtrace NOT LIKE ?", '%%%s%'], '^=', ["uncatched_exceptions.backtrace LIKE ?", '%s%'], '$=', ["uncatched_exceptions.backtrace LIKE ?", '%%%s'], '=', ["uncatched_exceptions.backtrace = ?"], '!=', ["uncatched_exceptions.backtrace <> ?"], 'NULL', ["uncatched_exceptions.backtrace IS NULL", ''], 'NOT_NULL', ["uncatched_exceptions.backtrace IS NOT NULL", '']],
    :environment => ActiveSupport::OrderedHash['=~', ["uncatched_exceptions.environment LIKE ?", '%%%s%'], '!~', ["uncatched_exceptions.environment NOT LIKE ?", '%%%s%'], '^=', ["uncatched_exceptions.environment LIKE ?", '%s%'], '$=', ["uncatched_exceptions.environment LIKE ?", '%%%s'], '=', ["uncatched_exceptions.environment = ?"], '!=', ["uncatched_exceptions.environment <> ?"], 'NULL', ["uncatched_exceptions.environment IS NULL", ''], 'NOT_NULL', ["uncatched_exceptions.environment IS NOT NULL", '']],
    :request => ActiveSupport::OrderedHash['=~', ["uncatched_exceptions.request LIKE ?", '%%%s%'], '!~', ["uncatched_exceptions.request NOT LIKE ?", '%%%s%'], '^=', ["uncatched_exceptions.request LIKE ?", '%s%'], '$=', ["uncatched_exceptions.request LIKE ?", '%%%s'], '=', ["uncatched_exceptions.request = ?"], '!=', ["uncatched_exceptions.request <> ?"], 'NULL', ["uncatched_exceptions.request IS NULL", ''], 'NOT_NULL', ["uncatched_exceptions.request IS NOT NULL", '']],
    :created_at => ActiveSupport::OrderedHash['=', ["uncatched_exceptions.created_at = ?"], '!=', ["uncatched_exceptions.created_at <> ?"], '>', ["uncatched_exceptions.created_at > ?"], '<', ["uncatched_exceptions.created_at < ?"], '>=', ["uncatched_exceptions.created_at >= ?"], '<=', ["uncatched_exceptions.created_at <= ?"]],
    :created_at_min => ActiveSupport::OrderedHash['>=', ["uncatched_exceptions.created_at >= ?"], '>', ["uncatched_exceptions.created_at > ?"]],
  :created_at_max => ActiveSupport::OrderedHash['<=', ["uncatched_exceptions.created_at <= ?"], '<', ["uncatched_exceptions.created_at < ?"]]}.freeze

  FILES_DEST = Rails.root.join('files', %q{uncatched_exceptions}).to_s


  # == Validations



  # == Triggers



  # == Relations
  #
  # Associations through specific setters
  #
  # Virtual Fields
  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-03-22 09:46:46 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return UncatchedException.new if att.blank?
    std_atts = att.reject{|k,v| %w(id).include?(k.to_s) }
    uncatched_exception = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      uncatched_exception = UncatchedException.find(att[:id])
      uncatched_exception.attributes = std_atts
    else
      uncatched_exception = UncatchedException.new(std_atts)
    end

    # clean associations
    #clean binaries


    return uncatched_exception
  end


  # The disp_name is how any record will appear in most use cases, such as lists of associated records during 'show', 'list'...
  #
  # Faveod will try to guess the best single field, based on SID, usually from fields containing "Title", "Name" or "Label".
  #
  # Customized code often will often look like these snippets:
  # Multiple key: "#{self.first_name} #{self.last_name}"
  # Date or time: "#{self.name} #{self.created_at.strftime('%H:%M %y-%m-%d') if self.created_at}"
  # Associations: "#{self.name} #{self.user ? self.user.disp_name : _('No user')}"
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2011-05-31 17:21:54 UTC
  # Status:: Validated


  def disp_name
    self.controller_name || ''
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      UncatchedException.new.params_to_attributes(values).each { |k,v|
        case k.to_sym
        when :created_at
          cmp = comps["comp_created_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :created_at : "created_at_#{date_h[cmp]}"
          cond[field] = val
        end
      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = UncatchedException.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.uncatchedexception_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    UncatchedException.first(:order => 'uncatched_exceptions.id DESC', :conditions => ["uncatched_exceptions.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    UncatchedException.first(:order => 'uncatched_exceptions.id', :conditions => ["uncatched_exceptions.id > ?", self.id])
  end

  # Author:: Sylvain Abélard
  # Version:: 3
  # Last Update:: 2011-05-13 14:25:00 UTC


  def self.named_scope_default_scope_method
    {:order => 'created_at DESC'}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      if [:exception_class, :controller_name, :action_name, :message, :backtrace, :environment, :request, :created_at
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })


# Stores an exception's log from an exception.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2010-06-16 15:10:21 UTC
# Status:: Validated


def self.create_from_exception(ctrl, exc, data)
message = exc.message.inspect
message << "\n* Extra Data\n\n#{data}" unless data.blank?
create( :exception_class => exc.class.name,
:controller_name => ctrl.controller_name,
:action_name     => ctrl.action_name,
:message         => message,
:backtrace       => exc.backtrace,
:request         => ctrl.request)
end


# Stores request's information.
#
# Author:: Yann Azoury
# Version:: 6
# Last Update:: 2013-03-31 15:00:16 UTC
# Status:: Requires Tests


def request=(req)
if req.is_a?(String)
  write_attribute :request, req
else
  max = req.env.keys.max { |a,b| a.length <=> b.length }
  env = req.env.keys.sort.inject [] do |env, key|
    env << '* ' + ("%-*s: %s" % [max.length, key, req.env[key].to_s.strip])
  end
  write_attribute(:environment, (env << "* Process: #{$$}" << "* Server : #{Socket.gethostname}") * "\n")
  write_attribute(:request, [
    "* URL:#{" #{req.method.to_s.upcase}" unless req.get?} #{req.protocol}#{req.env["HTTP_HOST"]}#{req.fullpath}",

    #"* Format: #{req.format.to_s}",

    "* IP: #{req.remote_ip}",
    "* Browser: #{req.env['HTTP_USER_AGENT']}",
    "* Rails Root: #{Pathname.new(Rails.root).cleanpath.to_s}"
  ] * "\n")
end
end


# Stores backtrace's information.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-03-31 21:31:16 UTC
# Status:: Validated


def backtrace=(bt)
unless bt.is_a?(String)
  reg = /\A#{Regexp.escape(Pathname.new(Rails.root).cleanpath.to_s)}/
  backtrace = bt.map { |line|
    Pathname.new(line.gsub(reg, "[Rails.root]")).cleanpath.to_s
  }
  bt = backtrace * "\n"
end
write_attribute :backtrace, bt
end

def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs
if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics
# BINARIES CONSTANTS


end
