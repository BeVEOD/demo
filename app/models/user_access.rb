# -*- encoding : utf-8 -*-
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##############
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Apr 04 13:52:39 +0200 2013
## It should be placed at 'app/models/user_access.rb'
## All manual modifications will be destroyed on next generation
################################################


class UserAccess < ActiveRecord::Base

  self.table_name = 'user_accesses'

  SEARCHABLE_FIELDS = [:read,:write].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:user => :bt_assoc, :access => :bt_assoc, :read => :boolean, :write => :boolean).freeze
  COMPARATORS = {:user => ActiveSupport::OrderedHash['=', ["user_accesses.user_id = ?"], '!=', ["user_accesses.user_id <> ?"], 'NULL', ["user_accesses.user_id IS NULL", ''], 'NOT_NULL', ["user_accesses.user_id IS NOT NULL", '']],
    :user_id => ActiveSupport::OrderedHash['=', ["user_accesses.user_id = ?"], '!=', ["user_accesses.user_id <> ?"], 'NULL', ["user_accesses.user_id IS NULL", ''], 'NOT_NULL', ["user_accesses.user_id IS NOT NULL", '']],
    :access => ActiveSupport::OrderedHash['=', ["user_accesses.access_id = ?"], '!=', ["user_accesses.access_id <> ?"], 'NULL', ["user_accesses.access_id IS NULL", ''], 'NOT_NULL', ["user_accesses.access_id IS NOT NULL", '']],
    :access_id => ActiveSupport::OrderedHash['=', ["user_accesses.access_id = ?"], '!=', ["user_accesses.access_id <> ?"], 'NULL', ["user_accesses.access_id IS NULL", ''], 'NOT_NULL', ["user_accesses.access_id IS NOT NULL", '']],
    :read => ActiveSupport::OrderedHash['=', ["user_accesses.read = ?"], '!=', ["user_accesses.read <> ?"], 'NULL', ["user_accesses.read IS NULL", ''], 'NOT_NULL', ["user_accesses.read IS NOT NULL", '']],
  :write => ActiveSupport::OrderedHash['=', ["user_accesses.write = ?"], '!=', ["user_accesses.write <> ?"], 'NULL', ["user_accesses.write IS NULL", ''], 'NOT_NULL', ["user_accesses.write IS NOT NULL", '']]}.freeze

  FILES_DEST = Rails.root.join('files', %q{user_accesses}).to_s


  # == Validations
  # == Triggers



  # == Relations
  #


  belongs_to :user, :foreign_key => "user_id", :class_name => "User"
  belongs_to :access, :foreign_key => "access_id", :class_name => "Access"


  # Associations through specific setters
  #
  # Virtual Fields

  attr_accessor :user_was
  attr_accessor :access_was


  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-03-22 09:46:46 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return UserAccess.new if att.blank?
    std_atts = att.reject{|k,v| %w(id user access).include?(k.to_s) }
    user_access = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      user_access = UserAccess.find(att[:id])
      user_access.attributes = std_atts
    else
      user_access = UserAccess.new(std_atts)
    end

    # clean associations

    val = att[:user]
    user_access.user_was = user_access.user if val
    case val
    when Hash, HashWithIndifferentAccess
      user_access.user = val.map {|k, v|
        if k[/\A(_|-)\d+/] # CREATE
          User.load_from_params(v)
        elsif v.is_a? String # UNCHANGED OR DESTROY
          if v == "-1" #DESTROY
            user_access.user.destroy(k) unless k.to_i == 0
            val.delete(k)
            nil
          else
            User.find(k) unless k.to_i == 0
          end
        else
          elt = User.load_from_params(v.merge(:id => k))
          if elt.valid?
            elt.save if elt.changed?
          else
            user_access.errors.add(:user, :user_invalid)
          end
          elt
        end
      }.compact.first
    when String, Fixnum
      user_access.user = val.blank? ? nil : User.find(val)
    when nil
    else logger.warn("Unexpected params type for 'user': #{val.class}")
    end
    val = att[:access]
    user_access.access_was = user_access.access if val
    case val
    when Hash, HashWithIndifferentAccess
      user_access.access = val.map {|k, v|
        if k[/\A(_|-)\d+/] # CREATE
          Access.load_from_params(v)
        elsif v.is_a? String # UNCHANGED OR DESTROY
          if v == "-1" #DESTROY
            user_access.access.destroy(k) unless k.to_i == 0
            val.delete(k)
            nil
          else
            Access.find(k) unless k.to_i == 0
          end
        else
          elt = Access.load_from_params(v.merge(:id => k))
          if elt.valid?
            elt.save if elt.changed?
          else
            user_access.errors.add(:access, :access_invalid)
          end
          elt
        end
      }.compact.first
    when String, Fixnum
      user_access.access = val.blank? ? nil : Access.find(val)
    when nil
    else logger.warn("Unexpected params type for 'access': #{val.class}")
    end

    #clean binaries


    return user_access
  end


  # The disp_name is how any record will appear in most use cases, such as lists of associated records during 'show', 'list'...
  #
  # Faveod will try to guess the best single field, based on SID, usually from fields containing "Title", "Name" or "Label".
  #
  # Customized code often will often look like these snippets:
  # Multiple key: "#{self.first_name} #{self.last_name}"
  # Date or time: "#{self.name} #{self.created_at.strftime('%H:%M %y-%m-%d') if self.created_at}"
  # Associations: "#{self.name} #{self.user ? self.user.disp_name : _('No user')}"
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2011-05-31 17:21:54 UTC
  # Status:: Validated


  def disp_name
    self.id.to_s
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      UserAccess.new.params_to_attributes(values).each { |k,v|
        case k.to_sym
        when :read
          cmp = comps["comp_read"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :read : "read_#{numb_h[cmp]}"
          cond[field] = val
        when :write
          cmp = comps["comp_write"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :write : "write_#{numb_h[cmp]}"
          cond[field] = val
        end
      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = UserAccess.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.useraccess_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    UserAccess.first(:order => 'user_accesses.id DESC', :conditions => ["user_accesses.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    UserAccess.first(:order => 'user_accesses.id', :conditions => ["user_accesses.id > ?", self.id])
  end

  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-11-01 16:01:43 UTC


  def self.named_scope_default_scope_method

    {}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      if [:user, :user_id, :access, :access_id, :read, :write
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })

# useful method


def user_human_display

return user ? user.disp_name : ""

end


# useful method


def access_human_display

return access ? access.disp_name : ""

end


def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs

h[:user_id] = h.delete(:user) if h.has_key?(:user)
h[:access_id] = h.delete(:access) if h.has_key?(:access)

if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics



# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def user__potential_values(options = {})
if options.has_key?(:page)
  User.paginate(options)
else
  User.all(options)
end
end


# Exporting associations: listing names of linked objects.
#
# Author:: Sylvain Abélard
# Version:: 8
# Last Update:: 2011-06-15 21:03:45 UTC
# Status:: Requires Tests


def user_to_spreadsheet(opts={})

(self.user.blank? ? '' : self.user.disp_name)

end


# Importing associations: this is way too tricky to let a machine do an educated guess, so you should specify according to your needs.
#
# Author:: Sylvain Abélard
# Version:: 9
# Last Update:: 2011-06-15 21:09:38 UTC
# Status:: Requires Tests


def user_from_spreadsheet(v, opts={})

if v.blank?
  nil
else
  nil
end

end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def access__potential_values(options = {})
if options.has_key?(:page)
  Access.paginate(options)
else
  Access.all(options)
end
end


# Exporting associations: listing names of linked objects.
#
# Author:: Sylvain Abélard
# Version:: 8
# Last Update:: 2011-06-15 21:03:45 UTC
# Status:: Requires Tests


def access_to_spreadsheet(opts={})

(self.access.blank? ? '' : self.access.disp_name)

end


# Importing associations: this is way too tricky to let a machine do an educated guess, so you should specify according to your needs.
#
# Author:: Sylvain Abélard
# Version:: 9
# Last Update:: 2011-06-15 21:09:38 UTC
# Status:: Requires Tests


def access_from_spreadsheet(v, opts={})

if v.blank?
  nil
else
  nil
end

end


# Importing boolean: accepts variants for true, yes and 1. Everything else is false.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 19:22:46 UTC
# Status:: Requires Tests


def read_from_spreadsheet(v, opts={})
if v.is_a?(Boolean)
  v
else
  ['true', 'vrai', _('true'), '1', 'yes', 'oui', _('yes')].include?(v.to_s.downcase)
end
end


# Exporting boolean: displays false as '0' and true as '1'.
# Use {:true => "OK", :false => "KO"} to customize display.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 18:42:20 UTC
# Status:: Validation Pending


def read_to_spreadsheet(opts={})

# self.read ? _('True') : _('False')

self.read ? (opts[:true] || '1') : (opts[:false] || '0')
end


# Importing boolean: accepts variants for true, yes and 1. Everything else is false.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 19:22:46 UTC
# Status:: Requires Tests


def write_from_spreadsheet(v, opts={})
if v.is_a?(Boolean)
  v
else
  ['true', 'vrai', _('true'), '1', 'yes', 'oui', _('yes')].include?(v.to_s.downcase)
end
end


# Exporting boolean: displays false as '0' and true as '1'.
# Use {:true => "OK", :false => "KO"} to customize display.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 18:42:20 UTC
# Status:: Validation Pending


def write_to_spreadsheet(opts={})

# self.write ? _('True') : _('False')

self.write ? (opts[:true] || '1') : (opts[:false] || '0')
end

end
