# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Fri Oct 18 12:04:12 +0200 2013
## It should be placed at 'app/models/file_import.rb'
## All manual modifications will be destroyed on next generation
################################################


class FileImport < ActiveRecord::Base

  self.table_name = 'file_imports'

  SEARCHABLE_FIELDS = [:user,:file_import,:re_imports,:started_at,:completed_at,:read_lines,:wrote_records,:expected_total,:error_count,:log].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:user => :bt_assoc, :file => :binary, :file_import => :bt_assoc, :re_imports => :hm_assoc, :started_at => :datetime, :completed_at => :datetime, :read_lines => :integer, :wrote_records => :integer, :expected_total => :integer, :error_count => :integer, :log => :text).freeze
  COMPARATORS = {:user => ActiveSupport::OrderedHash['=', ["file_imports.user_id = ?"], '!=', ["file_imports.user_id <> ?"], 'NULL', ["file_imports.user_id IS NULL", ''], 'NOT_NULL', ["file_imports.user_id IS NOT NULL", '']],
    :user_id => ActiveSupport::OrderedHash['=', ["file_imports.user_id = ?"], '!=', ["file_imports.user_id <> ?"], 'NULL', ["file_imports.user_id IS NULL", ''], 'NOT_NULL', ["file_imports.user_id IS NOT NULL", '']],
    :file => ActiveSupport::OrderedHash['=~', ["file_imports.file__name LIKE ?", '%%%s%'], '!~', ["file_imports.file__name NOT LIKE ?", '%%%s%'], '^=', ["file_imports.file__name LIKE ?", '%s%'], '$=', ["file_imports.file__name LIKE ?", '%%%s'], '=', ["file_imports.file__name = ?"], '!=', ["file_imports.file__name <> ?"], 'NULL', ["file_imports.file__name IS NULL", ''], 'NOT_NULL', ["file_imports.file__name IS NOT NULL", '']],
    :file_import => ActiveSupport::OrderedHash['=', ["file_imports.file_import_id = ?"], '!=', ["file_imports.file_import_id <> ?"], 'NULL', ["file_imports.file_import_id IS NULL", ''], 'NOT_NULL', ["file_imports.file_import_id IS NOT NULL", '']],
    :file_import_id => ActiveSupport::OrderedHash['=', ["file_imports.file_import_id = ?"], '!=', ["file_imports.file_import_id <> ?"], 'NULL', ["file_imports.file_import_id IS NULL", ''], 'NOT_NULL', ["file_imports.file_import_id IS NOT NULL", '']],
    :re_imports => ActiveSupport::OrderedHash['IN', ["file_imports.id IN (?)"], 'NOT_IN', ["file_imports.id NOT IN (?)"]],
    :started_at => ActiveSupport::OrderedHash['=', ["file_imports.started_at = ?"], '!=', ["file_imports.started_at <> ?"], '>', ["file_imports.started_at > ?"], '<', ["file_imports.started_at < ?"], '>=', ["file_imports.started_at >= ?"], '<=', ["file_imports.started_at <= ?"]],
    :started_at_min => ActiveSupport::OrderedHash['>=', ["file_imports.started_at >= ?"], '>', ["file_imports.started_at > ?"]],
    :started_at_max => ActiveSupport::OrderedHash['<=', ["file_imports.started_at <= ?"], '<', ["file_imports.started_at < ?"]],
    :completed_at => ActiveSupport::OrderedHash['=', ["file_imports.completed_at = ?"], '!=', ["file_imports.completed_at <> ?"], '>', ["file_imports.completed_at > ?"], '<', ["file_imports.completed_at < ?"], '>=', ["file_imports.completed_at >= ?"], '<=', ["file_imports.completed_at <= ?"]],
    :completed_at_min => ActiveSupport::OrderedHash['>=', ["file_imports.completed_at >= ?"], '>', ["file_imports.completed_at > ?"]],
    :completed_at_max => ActiveSupport::OrderedHash['<=', ["file_imports.completed_at <= ?"], '<', ["file_imports.completed_at < ?"]],
    :read_lines => ActiveSupport::OrderedHash['=', ["file_imports.read_lines = ?"], '!=', ["file_imports.read_lines <> ?"], '>', ["file_imports.read_lines > ?"], '<', ["file_imports.read_lines < ?"], '>=', ["file_imports.read_lines >= ?"], '<=', ["file_imports.read_lines <= ?"]],
    :read_lines_min => ActiveSupport::OrderedHash['>=', ["file_imports.read_lines >= ?"], '>', ["file_imports.read_lines > ?"]],
    :read_lines_max => ActiveSupport::OrderedHash['<=', ["file_imports.read_lines <= ?"], '<', ["file_imports.read_lines < ?"]],
    :wrote_records => ActiveSupport::OrderedHash['=', ["file_imports.wrote_records = ?"], '!=', ["file_imports.wrote_records <> ?"], '>', ["file_imports.wrote_records > ?"], '<', ["file_imports.wrote_records < ?"], '>=', ["file_imports.wrote_records >= ?"], '<=', ["file_imports.wrote_records <= ?"]],
    :wrote_records_min => ActiveSupport::OrderedHash['>=', ["file_imports.wrote_records >= ?"], '>', ["file_imports.wrote_records > ?"]],
    :wrote_records_max => ActiveSupport::OrderedHash['<=', ["file_imports.wrote_records <= ?"], '<', ["file_imports.wrote_records < ?"]],
    :expected_total => ActiveSupport::OrderedHash['=', ["file_imports.expected_total = ?"], '!=', ["file_imports.expected_total <> ?"], '>', ["file_imports.expected_total > ?"], '<', ["file_imports.expected_total < ?"], '>=', ["file_imports.expected_total >= ?"], '<=', ["file_imports.expected_total <= ?"]],
    :expected_total_min => ActiveSupport::OrderedHash['>=', ["file_imports.expected_total >= ?"], '>', ["file_imports.expected_total > ?"]],
    :expected_total_max => ActiveSupport::OrderedHash['<=', ["file_imports.expected_total <= ?"], '<', ["file_imports.expected_total < ?"]],
    :error_count => ActiveSupport::OrderedHash['=', ["file_imports.error_count = ?"], '!=', ["file_imports.error_count <> ?"], '>', ["file_imports.error_count > ?"], '<', ["file_imports.error_count < ?"], '>=', ["file_imports.error_count >= ?"], '<=', ["file_imports.error_count <= ?"]],
    :error_count_min => ActiveSupport::OrderedHash['>=', ["file_imports.error_count >= ?"], '>', ["file_imports.error_count > ?"]],
    :error_count_max => ActiveSupport::OrderedHash['<=', ["file_imports.error_count <= ?"], '<', ["file_imports.error_count < ?"]],
  :log => ActiveSupport::OrderedHash['=~', ["file_imports.log LIKE ?", '%%%s%'], '!~', ["file_imports.log NOT LIKE ?", '%%%s%'], '^=', ["file_imports.log LIKE ?", '%s%'], '$=', ["file_imports.log LIKE ?", '%%%s'], '=', ["file_imports.log = ?"], '!=', ["file_imports.log <> ?"], 'NULL', ["file_imports.log IS NULL", ''], 'NOT_NULL', ["file_imports.log IS NOT NULL", '']]}.freeze
  EXCEL_DATE_REGEXP = /\A\d{2,5}(\.\d*)?\Z/
  FRENCH_DATE_REGEXP = /(\d\d)\/(\d\d)\/(\d\d\d\d)/
  NUM_REGEXP = /\A[+-]?(((\d+(\.)?)|(\d*\.\d+))([eE][+-]?\d+)?)\Z/
  FILES_DEST = Rails.root.join('files', %q{file_imports}).to_s


  # == Validations



  # == Triggers


  after_create :file__after_create_trigger

  after_update :file__after_update_trigger

  after_destroy :file__after_destroy_trigger

  # == Relations
  #


  has_many :re_imports, :foreign_key => "file_import_id", :class_name => "FileImport"
  belongs_to :user, :foreign_key => "user_id", :class_name => "User"
  belongs_to :file_import, :foreign_key => "file_import_id", :class_name => "FileImport"


  # Associations through specific setters
  #
  # Virtual Fields

  attr_accessor :user_was
  attr_accessor :file_import_was
  attr_accessor :re_imports_was


  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-09-03 16:56:08 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return FileImport.new if att.blank?
    std_atts = att.reject{|k,v| %w(id user file_import re_imports file file_tmp file_name).include?(k.to_s) }
    file_import = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      file_import = FileImport.find(att[:id])
      file_import.attributes = std_atts
    else
      file_import = FileImport.new(std_atts)
    end

    # clean associations

    file_import.user_load_from_params(att[:user])
    file_import.file_import_load_from_params(att[:file_import])
    file_import.re_imports_load_from_params(att[:re_imports])

    #clean binaries

    file_import.file_load_from_params(att)

    #clean serialized data

    return file_import
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      FileImport.new.params_to_attributes(values).each { |k,v|
        case k.to_sym
        when :user_id
          cmp = comps["comp_user_id"]
          cmp ||= 'IN'
          vals  = val.is_a?(Enumerable) ? v : v.split(',').map(&:to_i)
          val   = cmp == 'IS NULL' ? nil : vals
          field = numb_h[cmp].nil? ? :user_id : "user_id_#{numb_h[cmp]}"
          cond[field] = val
        when :file_import_id
          cmp = comps["comp_file_import_id"]
          cmp ||= 'IN'
          vals  = val.is_a?(Enumerable) ? v : v.split(',').map(&:to_i)
          val   = cmp == 'IS NULL' ? nil : vals
          field = numb_h[cmp].nil? ? :file_import_id : "file_import_id_#{numb_h[cmp]}"
          cond[field] = val
        when :re_imports
          cmp = comps["comp_re_imports"]
          val = cmp == 'IS NULL' ? nil : v
          field = assoc_h[cmp].nil? ? 'file_import_id' : "re_imports_#{assoc_h[cmp]}"
          cond[field] = val
          inc << :re_imports
        when :started_at
          cmp = comps["comp_started_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :started_at : "started_at_#{date_h[cmp]}"
          cond[field] = val
        when :completed_at
          cmp = comps["comp_completed_at"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = date_h[cmp].nil? ? :completed_at : "completed_at_#{date_h[cmp]}"
          cond[field] = val
        when :read_lines
          cmp = comps["comp_read_lines"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :read_lines : "read_lines_#{numb_h[cmp]}"
          cond[field] = val
        when :wrote_records
          cmp = comps["comp_wrote_records"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :wrote_records : "wrote_records_#{numb_h[cmp]}"
          cond[field] = val
        when :expected_total
          cmp = comps["comp_expected_total"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :expected_total : "expected_total_#{numb_h[cmp]}"
          cond[field] = val
        when :error_count
          cmp = comps["comp_error_count"]
          cmp ||= '='
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',').map(&:to_i) : v.to_i)
          field = numb_h[cmp].nil? ? :error_count : "error_count_#{numb_h[cmp]}"
          cond[field] = val
        when :log
          cmp = comps["comp_log"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :log : "log_#{string_h[cmp]}"
          cond[field] = val
        end
      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Makes all kind of calculations for reports.
  #
  # Author:: Yann Azoury
  # Version:: 20
  # Last Update:: 2013-02-27 12:27:37 UTC
  # Status:: Should be optimized


  def self.report_calculation(op, field = :id, opts = {})
    scope	= opts[:scope]
    labels	= opts[:labels]	  || []
    step	= opts[:step]
    group	= opts[:group]
    ret_hash= opts[:ret_hash] || false
    opsym	= case op
    when :count, 'count'			then field = :id ; :count
    when :avg, 'avg', 'average', :average	then :avg
    when :value, 'value', :sum, 'sum'	then :sum
    when :min, 'min', :minimum, 'minimum'	then :min
    when :max, 'max', :maximum, 'maximum'	then :max
    else field = :id ; :count
    end
    case group
    when nil
      return scope.blank? ? self.calculate(opsym, field) : with_scope(:find => {:conditions => scope}) { self.calculate(opsym, field) }
    when :user, 'user'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :user_id)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :user_id)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :file_import, 'file_import'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :file_import_id)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :file_import_id)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :re_imports, 're_imports'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :file_import_id, :joins => :re_imports)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :file_import_id, :joins => :re_imports)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :"users.active", 'users.active'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.active', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.active', :joins => :user)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"users.login", 'users.login'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.login', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.login', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.first_name", 'users.first_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.first_name', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.first_name', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.last_name", 'users.last_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.last_name', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.last_name', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.email", 'users.email'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.email', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.email', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.telephone", 'users.telephone'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.telephone', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.telephone', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.language", 'users.language'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.language', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.language', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.password", 'users.password'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.password', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.password', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.hashed_password", 'users.hashed_password'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.hashed_password', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.hashed_password', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.salt", 'users.salt'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.salt', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.salt', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.last_session_id", 'users.last_session_id'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.last_session_id', :joins => :user)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.last_session_id', :joins => :user)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :read_lines, 'read_lines'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.read_lines >= ? AND file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.read_lines >= ? AND file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :wrote_records, 'wrote_records'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.wrote_records >= ? AND file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.wrote_records >= ? AND file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :expected_total, 'expected_total'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.expected_total >= ? AND file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.expected_total >= ? AND file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :error_count, 'error_count'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.error_count >= ? AND file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.error_count >= ? AND file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :read_lines, 'read_lines'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.read_lines >= ? AND file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.read_lines >= ? AND file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :wrote_records, 'wrote_records'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.wrote_records >= ? AND file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.wrote_records >= ? AND file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :expected_total, 'expected_total'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.expected_total >= ? AND file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.expected_total >= ? AND file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :error_count, 'error_count'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.error_count >= ? AND file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.error_count >= ? AND file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :read_lines, 'read_lines'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.read_lines >= ? AND file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.read_lines >= ? AND file_imports.read_lines < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :wrote_records, 'wrote_records'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.wrote_records >= ? AND file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.wrote_records >= ? AND file_imports.wrote_records < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :expected_total, 'expected_total'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.expected_total >= ? AND file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.expected_total >= ? AND file_imports.expected_total < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :error_count, 'error_count'
      h = {}
      labels.each_with_index { |l, idx|
        h[l] = if scope.blank?
          self.where(["file_imports.error_count >= ? AND file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.where(["file_imports.error_count >= ? AND file_imports.error_count < ?", l, labels[idx+1]]).calculate(opsym, field)
          }
        end
      }
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :started_at, 'started_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.started_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.started_at),'-', WEEK(file_imports.started_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.started_at),'-', MONTH(file_imports.started_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.started_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :completed_at, 'completed_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.completed_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.completed_at),'-', WEEK(file_imports.completed_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.completed_at),'-', MONTH(file_imports.completed_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.completed_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :"users.last_login", 'users.last_login'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(users.last_login)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(users.last_login),'-', WEEK(users.last_login))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(users.last_login),'-', MONTH(users.last_login))"
        when :year
          lab_format = '%Y'
          "YEAR(users.last_login)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'users.last_login', :joins => :user)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'users.last_login', :joins => :user)
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :started_at, 'started_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.started_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.started_at),'-', WEEK(file_imports.started_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.started_at),'-', MONTH(file_imports.started_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.started_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :completed_at, 'completed_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.completed_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.completed_at),'-', WEEK(file_imports.completed_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.completed_at),'-', MONTH(file_imports.completed_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.completed_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :started_at, 'started_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.started_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.started_at),'-', WEEK(file_imports.started_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.started_at),'-', MONTH(file_imports.started_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.started_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'started_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    when :completed_at, 'completed_at'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(file_imports.completed_at)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(file_imports.completed_at),'-', WEEK(file_imports.completed_at))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(file_imports.completed_at),'-', MONTH(file_imports.completed_at))"
        when :year
          lab_format = '%Y'
          "YEAR(file_imports.completed_at)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'completed_at')
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["file_imports.#{group} >= ? AND file_imports.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    else
      logger.debug("Unknown Group: #{group} (operation: #{opsym}, scope: #{scope})")
    end
    return []
  end


  # Creates the thumbnail and returns it.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2013-09-03 16:56:08 UTC
  # Status:: Validated


  def thumbnail(sid, opts={})

    maxwidth	= (opts[:maxwidth] || 128).to_f
    maxheight	= (opts[:maxheight] || 128).to_f
    aspectratio	= maxwidth / maxheight
    path		= nil
    dest_path	= nil
    pic		= nil
    case sid.to_sym
    when :file
      path		= self.file__path
      dest_path	= self.file__thumb_path
    end
    pic	   = path ? Magick::Image.read(path).first : Magick::Image.from_blob(pic).first
    imgwidth  = pic.columns
    imgheight = pic.rows
    imgratio  = imgwidth.to_f / imgheight.to_f
    scaleratio= imgratio > aspectratio ? maxwidth / imgwidth : maxheight / imgheight
    thumb	   = pic.thumbnail(scaleratio)
    thumb.write(dest_path) if dest_path
    return thumb.to_blob
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = FileImport.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.fileimport_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    FileImport.first(:order => 'file_imports.id DESC', :conditions => ["file_imports.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    FileImport.first(:order => 'file_imports.id', :conditions => ["file_imports.id > ?", self.id])
  end

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:29:54 UTC


  def self.named_scope_no_started_at_method
    {:conditions => "file_imports.started_at IS NULL"}
  end

  scope(:no_started_at, proc { named_scope_no_started_at_method })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:29:54 UTC


  def self.named_scope_having_started_at_method
    {:conditions => "file_imports.started_at IS NOT NULL"}
  end

  scope(:having_started_at, proc { named_scope_having_started_at_method })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:29:55 UTC


  def self.named_scope_no_completed_at_method
    {:conditions => "file_imports.completed_at IS NULL"}
  end

  scope(:no_completed_at, proc { named_scope_no_completed_at_method })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:29:55 UTC


  def self.named_scope_having_completed_at_method
    {:conditions => "file_imports.completed_at IS NOT NULL"}
  end

  scope(:having_completed_at, proc { named_scope_having_completed_at_method })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:29:55 UTC


  def self.named_scope_no_file_method
    {:conditions => "file_imports.file__name IS NULL OR file_imports.file__name = ''"}
  end

  scope(:no_file, proc { named_scope_no_file_method })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:29:55 UTC

  scope(:no_user, :conditions => {:user_id => nil})


  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:29:55 UTC


  def self.named_scope_having_user_method
    {:conditions => "file_imports.user_id IS NOT NULL"}
  end

  scope(:having_user, proc { named_scope_having_user_method })

  # Author:: Sylvain Abélard
  # Version:: 1
  # Last Update:: 2013-03-29 11:32:16 UTC


  def self.named_scope_having_file_method
    {:conditions => "file_imports.file__name IS NOT NULL AND file_imports.file__name <> ''"}
  end

  scope(:having_file, proc { named_scope_having_file_method })

  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-11-01 16:01:43 UTC


  def self.named_scope_default_scope_method

    {}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      case field.to_sym
      when :re_imports, :file_import_id
        joins_fields << :re_imports
      end
      if [:user, :user_id, :file, :file_import, :file_import_id, :re_imports, :started_at, :completed_at, :read_lines, :wrote_records, :expected_total, :error_count, :log
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })


# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2013-03-22 13:27:01 UTC
# Status:: In Progress


def import_xls

logger.debug("import_file begin")
res = {:ok => 0}
if self.file.blank?
  self.warn(_('File not found!'))
  return res
end
logger.info("import_file: " + self.file__name)
bilan = nil

# Spreadsheet.client_encoding = @encoding # apparently, forcing the choice is harmful

doc = Spreadsheet.open(self.file__path)
wss = doc.worksheets.map{|ws| ws.any? ? ["#{ws.name} (#{ws.row_count})", ws.name] : nil}.compact
s = _("%{n} %{records}: %{list}") %
{:n => wss.size, :records => _('worksheets'),
:list => wss.map{|ws| ws[0]}}
self.warn(s)
logger.debug("worksheets: #{s.inspect}")
doc.worksheets.each_with_index{|ws, wsi|
  logger.info(_("%{record} %{name}") % {:record => _('worksheet'), :name => ws.name})
  ws.each_with_index {|row, ri|
    self.auto_import(self.excel_line(row.to_a)) if ri != 0
  }
}
logger.debug("import_file ok: #{self.inspect}")

end


# Author:: Sylvain Abélard
# Version:: 1
# Last Update:: 2011-06-30 19:09:45 UTC
# Status:: In Progress


def excel_line

# logger.debug("excel_line: #{a.inspect}")

line = a.map{|c|
  if c.is_a?(String)
    if c.strip.tr(' ,', '_.') =~ NUM_REGEXP
      c.to_f
    elsif c =~ FRENCH_DATE_REGEXP
      m = c.match(FRENCH_DATE_REGEXP)
      begin
        Date.civil(m[3].to_i, m[2].to_i, m[1].to_i)
      rescue
        c
      end
    else
      c.strip
    end
  else

    #if c.is_a?(Numeric) && c.to_s =~ excel_date_regexp
    #  int = c.to_i
    #  d = Date.new(1900, 1, 1) + ((int > 58) ? int+1 : int)
    #  _("%{a} or %{b}") % {:a => "[#{c}]", :b => "[#{d}]"}
    #else

    c.respond_to?(:value) ?
    (c.value.respond_to?(:value) ?
    c.value.value :			# Spreadsheet::Excel::Error
    c.value				# Spreadsheet::Excel::Formula
    ) :
    c					# String, Fixnum, Date, Time...

    #end

  end
}

# logger.debug("excel_line: #{line.inspect}")

line
end


# The disp_name is how any record will appear in most use cases, such as lists of associated records during 'show', 'list'...
#
# Faveod will try to guess the best single field, based on SID, usually from fields containing "Title", "Name" or "Label".
#
# Customized code often will often look like these snippets:
# Multiple key: "#{self.first_name} #{self.last_name}"
# Date or time: "#{self.name} #{self.created_at.strftime('%H:%M %y-%m-%d') if self.created_at}"
# Associations: "#{self.name} #{self.user ? self.user.disp_name : _('No user')}"
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-30 19:12:20 UTC
# Status:: In Progress


def disp_name
self.file__name
end


#--
# DEPRECATED: this method would be removed
#++
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2013-03-29 12:46:35 UTC
# Status:: Deprecated


def auto_launch_import

logger.warn("Warning: Executing deprecated method 'auto_launch_import' from FileImport")

# self.import_file if self.file__name_changed?

true
end


# Author:: Sylvain Abélard
# Version:: 1
# Last Update:: 2011-07-07 17:31:45 UTC
# Status:: In Progress


def warn(s)
self.log ||= ""
self.log << "#{s}\n"
end


# Author:: Sylvain Abélard
# Version:: 1
# Last Update:: 2011-07-07 17:41:59 UTC
# Status:: In Progress


def self.excel_date(str)
return nil if str.blank?
return str if str.is_a?(Date)
if str.is_a?(Numeric)
  int = str.to_i
  d = Date.new(1900, 1, 1) + ((int > 58) ? int+1 : int)
  return d
end
begin
  ds = (str || '').split('/').map(&:to_i)
  date = Date.new(
  (ds[2] && (ds[2] > 1900)) ? ds[2] : 2000 + (ds[2] || 0),
  ds[1] || 1,
  ds[0] || 1)
  return date
rescue
  return nil
end
end


# Author:: Sylvain Abélard
# Version:: 1
# Last Update:: 2011-07-07 18:02:32 UTC
# Status:: In Progress


def import_excel

# Spreadsheet.client_encoding = @encoding # apparently, forcing the choice is harmful

doc = Spreadsheet.open(self.file__path)
wss = doc.worksheets.map{|ws| ws.any? ? ["#{ws.name} (#{ws.row_count})", ws.name] : nil}.compact
s = _("%{n} %{records}: %{list}") %
{:n => wss.size, :records => _('worksheets'),
:list => wss.map{|ws| ws[0]}}
self.warn(s)
logger.debug("worksheets: #{s.inspect}")
doc.worksheets.each_with_index{|ws, wsi|
  logger.info(_("%{record} %{name}") % {:record => _('worksheet'), :name => ws.name})
  ws.each_with_index {|row, ri|
    self.excel_line(row.to_a) if ri != 0
  }
}
end

# useful method


def user_human_display

return user ? user.disp_name : ""

end


# useful method


def file_import_human_display

return file_import ? file_import.disp_name : ""

end


# useful method


def re_imports_human_display

return re_imports.map(&:disp_name).to_sentence(:connector => _('and'))

end


def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs

h[:user_id] = h.delete(:user) if h.has_key?(:user)
h[:file_import_id] = h.delete(:file_import) if h.has_key?(:file_import)

if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics



# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def user__potential_values(options = {})
if options.has_key?(:page)
  User.paginate(options)
else
  User.all(options)
end
end


# Load association from different params formats.
#
# Version::
# Last Update:: 2013-08-17 13:22:16 UTC
# Status:: Validated


def user_load_from_params(val)

self.user_was = self.user if val
case val
when Hash, HashWithIndifferentAccess
  self.user = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = User.load_from_params(v)
      if !elt.valid?
        self.errors.add(:user, _("Invalid user: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.user.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        User.find(k) unless k.to_i == 0
      end
    else
      elt = User.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:user, _("Invalid user: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact.first
when String, Fixnum
  self.user = val.blank? ? nil : User.find(val)
when nil
else logger.warn("Unexpected params type for 'user': #{val.class}")
end
end


# Author:: Pierre Carrio
# Version:: 2
# Last Update:: 2012-11-29 17:07:41 UTC
# Status:: Validated


def file

if @file_cache && @file_cache[:tmp]
  @file_cache[:path] = File.join(FILES_DEST_FILE, 'cache', @file_cache[:tmp])
end
if @file_cache && File.exists?(@file_cache[:path])
  return File.read(@file_cache[:path])
else
  File.open(self.file__path, 'r').read unless self.new_record? || !File.exist?(self.file__path)
end
end


# Gives the file path.
#
# Author:: Pierre Carrio
# Version:: 3
# Last Update:: 2012-11-29 17:08:18 UTC
# Status:: Validated


def file__path
if !@file_cache.blank? && !@file_cache[:path].blank?
  @file_cache[:path]
else
  File.join(FILES_DEST_FILE, "#{self.id}_#{self.file__name}")
end
end


# Gives the file size.
#
# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-01-16 14:40:38 UTC
# Status:: Validated


def file__size
if File.exist?(self.file__path)
  return File.size(self.file__path)
else
  return self.file ? self.file.length : 0
end
end


# Sets everything up when saving a file field.
#
# Author:: Yann Azoury
# Version:: 9
# Last Update:: 2013-07-17 02:09:04 UTC
# Status:: Validated


def file=(val)

# make cache dir

cdir = File.join(FILES_DEST_FILE, 'cache')
FileUtils.makedirs(cdir) unless File.exist?(cdir)

# remove existing cache file (create) or file (update)

File.delete(@file_cache[:path]) if @file_cache && @file_cache[:path] && File.exist?(@file_cache[:path])
File.delete(self.file__path) if File.exist?(self.file__path)

#set cache, prepare for failed validation or after_create trigger

@file_cache ||= {}
@file_cache[:name] = self.attributes['file__name']
@file_cache[:tmp] = "#{UUID.new.generate}--#{@file_cache[:name]}"
@file_cache[:path] = File.join(cdir, @file_cache[:tmp])
File.open(@file_cache[:path], 'wb') {|f| f.write(val) }

#TODO

return val
end


# Returns thumbnails path for the current data.
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 00:31:32 UTC
# Status:: Validated


def file__thumb_path

File.join(FILES_DEST_FILE__THUMBS, File.basename(self.file__path))
end


# Returns the MIME Type of current file (based on its name).
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 00:43:35 UTC
# Status:: Validated


def file__mime_type
if !self.file__name.blank?
  mt = MIME::Types.of(File.extname(self.file__name)).first
  return mt ? mt.content_type : "application/octet-stream"
end
end


# Rename the file correctly on the file system after create.
#
# Author:: Pierre Carrio
# Version:: 4
# Last Update:: 2012-12-03 09:41:10 UTC
# Status:: Validated


def file__after_create_trigger

if !@file_cache.blank? && !@file_cache[:tmp].blank?
  @file_cache[:path] = File.join(FILES_DEST_FILE, 'cache', @file_cache[:tmp])
end
if !@file_cache.blank? && @file_cache[:path]
  if File.exist?(@file_cache[:path])
    File.rename(@file_cache[:path], File.join(FILES_DEST_FILE, "#{self.id}_#{self.file__name}"))
  else
    logger.warn("Should not happen! cache: #{@file_cache.inspect} - name: #{self.file__name}")
  end
end
@file_cache = {}
end


# Rename Files correctly after update.
#
# Author:: Pierre Carrio
# Version:: 5
# Last Update:: 2012-12-03 09:40:46 UTC
# Status:: Validated


def file__after_update_trigger

Dir[File.join(FILES_DEST_FILE__THUMBS, "#{self.id}_*")].each{|f| File.delete(f); break} #will be regenerated
if !@file_cache.blank? && !@file_cache[:tmp].blank?
  @file_cache[:path] = File.join(FILES_DEST_FILE, 'cache', @file_cache[:tmp])
end
if !@file_cache.blank? && @file_cache[:path] && File.exist?(@file_cache[:path])
  Dir[File.join(FILES_DEST_FILE, "#{self.id}_*")].each{|f| File.delete(f); break}
  dest = File.join(FILES_DEST_FILE, "#{self.id}_#{self.file__name}")
  logger.debug("=== CACHE [#{@file_cache[:path].inspect}] DEST [#{dest.inspect}]")
  FileUtils.mv(@file_cache[:path], File.join(FILES_DEST_FILE, "#{self.id}_#{self.file__name}"))
else
  src = self.file__path
  if !File.exists?(src) # bad name
    Dir[File.join(FILES_DEST_FILE, "#{self.id}_*")].each{|f| File.rename(f, src); break}
  end
end
@file_cache = {}
end


# Remove files of destroyed row.
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 01:12:31 UTC
# Status:: Validated


def file__after_destroy_trigger

Dir[File.join(FILES_DEST_FILE, "#{self.id}_*")].each{|f| File.delete(f)}
Dir[File.join(FILES_DEST_FILE__THUMBS, "#{self.id}_*")].each{|f| File.delete(f)}
end


# return current cache hash
#
# Author:: Yann Azoury
# Version:: 6
# Last Update:: 2012-11-30 10:43:55 UTC
# Status:: Validated


def file__cache
@file_cache ||= {}
end


# Load binary from params.
#
# Version::
# Last Update:: 2013-07-17 15:50:35 UTC
# Status:: Validated


def file_load_from_params(att)

val = att[:file]
if val
  if val == '_destroy'
    self.file__name = nil
    self.file = nil
  elsif val == '_forget'
  elsif val.size == 0
    att.delete(:file)
  else
    self.file__name = File.basename(val.original_filename).parameterize.sub(/(-)(\w+)\Z/, '.\2')
    self.file = val.read
  end
else
  if !att[:file_tmp].blank? && !att[:file_name].blank?
    self.file__name         = att[:file_name]
    self.file__cache[:name] = att[:file_name]
    self.file__cache[:tmp]  = att[:file_tmp]
  end
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def file_import__potential_values(options = {})
if options.has_key?(:page)
  FileImport.paginate(options)
else
  FileImport.all(options)
end
end


# Load association from different params formats.
#
# Version::
# Last Update:: 2013-08-17 13:22:16 UTC
# Status:: Validated


def file_import_load_from_params(val)

self.file_import_was = self.file_import if val
case val
when Hash, HashWithIndifferentAccess
  self.file_import = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = FileImport.load_from_params(v)
      if !elt.valid?
        self.errors.add(:file_import, _("Invalid file_import: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.file_import.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        FileImport.find(k) unless k.to_i == 0
      end
    else
      elt = FileImport.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:file_import, _("Invalid file_import: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact.first
when String, Fixnum
  self.file_import = val.blank? ? nil : FileImport.find(val)
when nil
else logger.warn("Unexpected params type for 'file_import': #{val.class}")
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def re_imports__potential_values(options = {})
if options.has_key?(:page)
  FileImport.paginate(options)
else
  FileImport.all(options)
end
end


# Load association from different params formats.
#
# Version::
# Last Update:: 2013-08-17 13:22:16 UTC
# Status:: Validated


def re_imports_load_from_params(val)

self.re_imports_was = self.re_imports.all if val
case val
when Hash, HashWithIndifferentAccess
  self.re_imports = val.map {|k, v|
    if k[/\A(_|-)\d+/] # CREATE
      elt = FileImport.load_from_params(v)
      elt.file_import_id ||= self.id
      if !elt.valid?
        self.errors.add(:re_imports, _("Invalid re_imports: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    elsif v.is_a? String # UNCHANGED OR DESTROY
      if v == "-1" #DESTROY
        self.re_imports.destroy(k) unless k.to_i == 0
        val.delete(k)
        nil
      else
        FileImport.find(k) unless k.to_i == 0
      end
    else
      elt = FileImport.load_from_params(v.merge(:id => k))
      if elt.valid?
        elt.save if elt.changed?
      else
        self.errors.add(:re_imports, _("Invalid re_imports: %{d}") % {:d => elt.errors.full_messages.join(',')})
      end
      elt
    end
  }.compact
when Array
  val = val.compact.map(&:to_i).reject{|v| v == 0}
  self.re_imports = (val.empty? ? [] : FileImport.find(val))
when String, Fixnum
  self.re_imports = val.blank? ? nil : [FileImport.find(val)]
when nil
else logger.warn("Unexpected params type for 're_imports': #{val.class}")
end
end

# BINARIES CONSTANTS



def self.file_folder

Rails.root.join(*('files/file_imports/').split('/'))

end

FILES_DEST_FILE = self.file_folder
FILES_DEST_FILE__THUMBS = FILES_DEST_FILE + '__thumbs'

FileUtils.makedirs(FILES_DEST_FILE) unless File.exist?(FILES_DEST_FILE)
FileUtils.makedirs(FILES_DEST_FILE__THUMBS) unless File.exist?(FILES_DEST_FILE__THUMBS)

after_create {|rec|
src = File.join(FILES_DEST_FILE, "_#{rec.file__name}")
src = File.join(FILES_DEST_FILE, "_") unless File.exists?(src)
File.rename(src, File.join(FILES_DEST_FILE, "#{rec.id}_#{rec.file__name}")) if File.exists?(src)

}
after_update {|rec|
src = rec.file__path
Dir[File.join(FILES_DEST_FILE__THUMBS, "#{rec.id}_*")].each{|f| File.delete(f); break}
if !File.exists?(src) # bad name
  Dir[File.join(FILES_DEST_FILE, "#{rec.id}_*")].each{|f| File.rename(f, src); break}

end
}
after_destroy {|rec|
Dir[File.join(FILES_DEST_FILE, "#{rec.id}_*")].each{|f| File.delete(f)}
Dir[File.join(FILES_DEST_FILE__THUMBS, "#{rec.id}_*")].each{|f| File.delete(f)}

}

end
