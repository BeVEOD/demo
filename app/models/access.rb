# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##############
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Mon Jul 08 14:03:08 +0200 2013
## It should be placed at 'app/models/access.rb'
## All manual modifications will be destroyed on next generation
################################################


class Access < ActiveRecord::Base

  self.table_name = 'accesses'

  SEARCHABLE_FIELDS = [:set_sid,:type_sid].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:app_sid => :string, :set_sid => :string, :table_sid => :string, :field_sid => :string, :action_sid => :string, :type_sid => :string, :home_page_profiles => :hm_assoc, :user_accesses => :hm_assoc, :profile_accesses => :hm_assoc).freeze
  COMPARATORS = {:app_sid => ActiveSupport::OrderedHash['=~', ["accesses.app_sid LIKE ?", '%%%s%'], '!~', ["accesses.app_sid NOT LIKE ?", '%%%s%'], '^=', ["accesses.app_sid LIKE ?", '%s%'], '$=', ["accesses.app_sid LIKE ?", '%%%s'], '=', ["accesses.app_sid = ?"], '!=', ["accesses.app_sid <> ?"], 'NULL', ["accesses.app_sid IS NULL", ''], 'NOT_NULL', ["accesses.app_sid IS NOT NULL", '']],
    :set_sid => ActiveSupport::OrderedHash['=~', ["accesses.set_sid LIKE ?", '%%%s%'], '!~', ["accesses.set_sid NOT LIKE ?", '%%%s%'], '^=', ["accesses.set_sid LIKE ?", '%s%'], '$=', ["accesses.set_sid LIKE ?", '%%%s'], '=', ["accesses.set_sid = ?"], '!=', ["accesses.set_sid <> ?"], 'NULL', ["accesses.set_sid IS NULL", ''], 'NOT_NULL', ["accesses.set_sid IS NOT NULL", '']],
    :table_sid => ActiveSupport::OrderedHash['=~', ["accesses.table_sid LIKE ?", '%%%s%'], '!~', ["accesses.table_sid NOT LIKE ?", '%%%s%'], '^=', ["accesses.table_sid LIKE ?", '%s%'], '$=', ["accesses.table_sid LIKE ?", '%%%s'], '=', ["accesses.table_sid = ?"], '!=', ["accesses.table_sid <> ?"], 'NULL', ["accesses.table_sid IS NULL", ''], 'NOT_NULL', ["accesses.table_sid IS NOT NULL", '']],
    :field_sid => ActiveSupport::OrderedHash['=~', ["accesses.field_sid LIKE ?", '%%%s%'], '!~', ["accesses.field_sid NOT LIKE ?", '%%%s%'], '^=', ["accesses.field_sid LIKE ?", '%s%'], '$=', ["accesses.field_sid LIKE ?", '%%%s'], '=', ["accesses.field_sid = ?"], '!=', ["accesses.field_sid <> ?"], 'NULL', ["accesses.field_sid IS NULL", ''], 'NOT_NULL', ["accesses.field_sid IS NOT NULL", '']],
    :action_sid => ActiveSupport::OrderedHash['=~', ["accesses.action_sid LIKE ?", '%%%s%'], '!~', ["accesses.action_sid NOT LIKE ?", '%%%s%'], '^=', ["accesses.action_sid LIKE ?", '%s%'], '$=', ["accesses.action_sid LIKE ?", '%%%s'], '=', ["accesses.action_sid = ?"], '!=', ["accesses.action_sid <> ?"], 'NULL', ["accesses.action_sid IS NULL", ''], 'NOT_NULL', ["accesses.action_sid IS NOT NULL", '']],
    :type_sid => ActiveSupport::OrderedHash['=~', ["accesses.type_sid LIKE ?", '%%%s%'], '!~', ["accesses.type_sid NOT LIKE ?", '%%%s%'], '^=', ["accesses.type_sid LIKE ?", '%s%'], '$=', ["accesses.type_sid LIKE ?", '%%%s'], '=', ["accesses.type_sid = ?"], '!=', ["accesses.type_sid <> ?"], 'NULL', ["accesses.type_sid IS NULL", ''], 'NOT_NULL', ["accesses.type_sid IS NOT NULL", '']],
    :home_page_profiles => ActiveSupport::OrderedHash['IN', ["profiles.id IN (?)"], 'NOT_IN', ["profiles.id NOT IN (?)"]],
    :user_accesses => ActiveSupport::OrderedHash['IN', ["user_accesses.id IN (?)"], 'NOT_IN', ["user_accesses.id NOT IN (?)"]],
  :profile_accesses => ActiveSupport::OrderedHash['IN', ["profile_accesses.id IN (?)"], 'NOT_IN', ["profile_accesses.id NOT IN (?)"]]}.freeze

  FILES_DEST = Rails.root.join('files', %q{accesses}).to_s


  # == Validations


  validates_presence_of(:table_sid)
  validates_uniqueness_of(:field_sid, :scope => :table_sid, :if => :field_sid)
  validates_uniqueness_of(:action_sid, :scope => :table_sid, :if => :action_sid)


  # == Triggers



  # == Relations
  #


  has_many :home_page_profiles, :foreign_key => "home_page_id", :class_name => "Profile"
  has_many :user_accesses, :foreign_key => "access_id", :dependent => :destroy, :class_name => "UserAccess"
  has_many :profile_accesses, :foreign_key => "access_id", :dependent => :destroy, :class_name => "ProfileAccess"
  has_many :users, :source => :user, :through => :user_accesses
  has_many :profiles, :source => :profile, :through => :profile_accesses


  # Associations through specific setters
  #



  def users=(array)
    ids = array.map(&:id)
    UserAccess.where(['user_accesses.access_id = ? AND user_accesses.user_id NOT IN (?)', self.id, ids]).select(:id).each(&:destroy)
    user_access_ids = UserAccess.all(:conditions => {:access_id => self.id, :user_id => ids}, :select => 'user_id').map(&:user_id)
    (ids - user_access_ids).each{|i|
      UserAccess.create(:access_id => self.id, :user_id => i)
    }
    self.users.reload
  end


  def profiles=(array)
    ids = array.map(&:id)
    ProfileAccess.where(['profile_accesses.access_id = ? AND profile_accesses.profile_id NOT IN (?)', self.id, ids]).select(:id).each(&:destroy)
    profile_access_ids = ProfileAccess.all(:conditions => {:access_id => self.id, :profile_id => ids}, :select => 'profile_id').map(&:profile_id)
    (ids - profile_access_ids).each{|i|
      ProfileAccess.create(:access_id => self.id, :profile_id => i)
    }
    self.profiles.reload
  end

  # Virtual Fields

  attr_accessor :home_page_profiles_was
  attr_accessor :user_accesses_was
  attr_accessor :profile_accesses_was
  attr_accessor :users_was
  attr_accessor :profiles_was


  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain AbÃ©lard
  # Version:: 53
  # Last Update:: 2013-03-22 09:46:46 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return Access.new if att.blank?
    std_atts = att.reject{|k,v| %w(id home_page_profiles user_accesses profile_accesses users profiles).include?(k.to_s) }
    access = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      access = Access.find(att[:id])
      access.attributes = std_atts
    else
      access = Access.new(std_atts)
    end

    # clean associations

    val = att[:home_page_profiles]
    access.home_page_profiles_was = access.home_page_profiles if val
    case val
    when Hash, HashWithIndifferentAccess
      access.home_page_profiles = val.map {|k, v|
        if k[/\A(_|-)\d+/] # CREATE
          Profile.load_from_params(v)
        elsif v.is_a? String # UNCHANGED OR DESTROY
          if v == "-1" #DESTROY
            access.home_page_profiles.destroy(k) unless k.to_i == 0
            val.delete(k)
            nil
          else
            Profile.find(k) unless k.to_i == 0
          end
        else
          elt = Profile.load_from_params(v.merge(:id => k))
          if elt.valid?
            elt.save if elt.changed?
          else
            access.errors.add(:home_page_profiles, :home_page_profiles_invalid)
          end
          elt
        end
      }.compact
    when Array
      val = val.compact.map(&:to_i).reject{|v| v == 0}
      access.home_page_profiles = (val.empty? ? [] : Profile.find(val))
    when String, Fixnum
      access.home_page_profiles = val.blank? ? nil : [Profile.find(val)]
    when nil
    else logger.warn("Unexpected params type for 'home_page_profiles': #{val.class}")
    end
    val = att[:user_accesses]
    access.user_accesses_was = access.user_accesses if val
    case val
    when Hash, HashWithIndifferentAccess
      access.user_accesses = val.map {|k, v|
        if k[/\A(_|-)\d+/] # CREATE
          UserAccess.load_from_params(v)
        elsif v.is_a? String # UNCHANGED OR DESTROY
          if v == "-1" #DESTROY
            access.user_accesses.destroy(k) unless k.to_i == 0
            val.delete(k)
            nil
          else
            UserAccess.find(k) unless k.to_i == 0
          end
        else
          elt = UserAccess.load_from_params(v.merge(:id => k))
          if elt.valid?
            elt.save if elt.changed?
          else
            access.errors.add(:user_accesses, :user_accesses_invalid)
          end
          elt
        end
      }.compact
    when Array
      val = val.compact.map(&:to_i).reject{|v| v == 0}
      access.user_accesses = (val.empty? ? [] : UserAccess.find(val))
    when String, Fixnum
      access.user_accesses = val.blank? ? nil : [UserAccess.find(val)]
    when nil
    else logger.warn("Unexpected params type for 'user_accesses': #{val.class}")
    end
    val = att[:profile_accesses]
    access.profile_accesses_was = access.profile_accesses if val
    case val
    when Hash, HashWithIndifferentAccess
      access.profile_accesses = val.map {|k, v|
        if k[/\A(_|-)\d+/] # CREATE
          ProfileAccess.load_from_params(v)
        elsif v.is_a? String # UNCHANGED OR DESTROY
          if v == "-1" #DESTROY
            access.profile_accesses.destroy(k) unless k.to_i == 0
            val.delete(k)
            nil
          else
            ProfileAccess.find(k) unless k.to_i == 0
          end
        else
          elt = ProfileAccess.load_from_params(v.merge(:id => k))
          if elt.valid?
            elt.save if elt.changed?
          else
            access.errors.add(:profile_accesses, :profile_accesses_invalid)
          end
          elt
        end
      }.compact
    when Array
      val = val.compact.map(&:to_i).reject{|v| v == 0}
      access.profile_accesses = (val.empty? ? [] : ProfileAccess.find(val))
    when String, Fixnum
      access.profile_accesses = val.blank? ? nil : [ProfileAccess.find(val)]
    when nil
    else logger.warn("Unexpected params type for 'profile_accesses': #{val.class}")
    end
    val = att[:users]
    access.users_was = access.users if val
    case val
    when Hash, HashWithIndifferentAccess
      access.users = val.map {|k, v|
        if k[/\A(_|-)\d+/] # CREATE
          User.load_from_params(v)
        elsif v.is_a? String # UNCHANGED OR DESTROY
          if v == "-1" #DESTROY
            access.users.destroy(k) unless k.to_i == 0
            val.delete(k)
            nil
          else
            User.find(k) unless k.to_i == 0
          end
        else
          elt = User.load_from_params(v.merge(:id => k))
          if elt.valid?
            elt.save if elt.changed?
          else
            access.errors.add(:users, :users_invalid)
          end
          elt
        end
      }.compact
    when Array
      val = val.compact.map(&:to_i).reject{|v| v == 0}
      access.users = (val.empty? ? [] : User.find(val))
    when String, Fixnum
      access.users = val.blank? ? nil : [User.find(val)]
    when nil
    else logger.warn("Unexpected params type for 'users': #{val.class}")
    end
    val = att[:profiles]
    access.profiles_was = access.profiles if val
    case val
    when Hash, HashWithIndifferentAccess
      access.profiles = val.map {|k, v|
        if k[/\A(_|-)\d+/] # CREATE
          Profile.load_from_params(v)
        elsif v.is_a? String # UNCHANGED OR DESTROY
          if v == "-1" #DESTROY
            access.profiles.destroy(k) unless k.to_i == 0
            val.delete(k)
            nil
          else
            Profile.find(k) unless k.to_i == 0
          end
        else
          elt = Profile.load_from_params(v.merge(:id => k))
          if elt.valid?
            elt.save if elt.changed?
          else
            access.errors.add(:profiles, :profiles_invalid)
          end
          elt
        end
      }.compact
    when Array
      val = val.compact.map(&:to_i).reject{|v| v == 0}
      access.profiles = (val.empty? ? [] : Profile.find(val))
    when String, Fixnum
      access.profiles = val.blank? ? nil : [Profile.find(val)]
    when nil
    else logger.warn("Unexpected params type for 'profiles': #{val.class}")
    end

    #clean binaries


    return access
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      Access.new.params_to_attributes(values).each { |k,v|
        case k.to_sym
        when :set_sid
          cmp = comps["comp_set_sid"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :set_sid : "set_sid_#{string_h[cmp]}"
          cond[field] = val
        when :type_sid
          cmp = comps["comp_type_sid"]
          cmp ||= 'STARTS WITH'
          val = cmp == 'IS NULL' ? nil : (cmp == 'IN' ? v.split(',') : v)
          field = string_h[cmp].nil? ? :type_sid : "type_sid_#{string_h[cmp]}"
          cond[field] = val
        end
      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Makes all kind of calculations for reports.
  #
  # Author:: Yann Azoury
  # Version:: 20
  # Last Update:: 2013-02-27 12:27:37 UTC
  # Status:: Should be optimized


  def self.report_calculation(op, field = :id, opts = {})
    scope	= opts[:scope]
    labels	= opts[:labels]	  || []
    step	= opts[:step]
    group	= opts[:group]
    ret_hash= opts[:ret_hash] || false
    opsym	= case op
    when :count, 'count'			then field = :id ; :count
    when :avg, 'avg', 'average', :average	then :avg
    when :value, 'value', :sum, 'sum'	then :sum
    when :min, 'min', :minimum, 'minimum'	then :min
    when :max, 'max', :maximum, 'maximum'	then :max
    else field = :id ; :count
    end
    case group
    when nil
      return scope.blank? ? self.calculate(opsym, field) : with_scope(:find => {:conditions => scope}) { self.calculate(opsym, field) }
    when :home_page_profiles, 'home_page_profiles'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :home_page_id, :joins => :home_page_profiles)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :home_page_id, :joins => :home_page_profiles)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :user_accesses, 'user_accesses'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :access_id, :joins => :user_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :access_id, :joins => :user_accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :profile_accesses, 'profile_accesses'
      h = if scope.blank?
        self.calculate(opsym, field, :group => :access_id, :joins => :profile_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => :access_id, :joins => :profile_accesses)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :users, 'users'
      h = if scope.blank?
        self.calculate(opsym, field, :group => "accesses.id", :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => "accesses.id", :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :profiles, 'profiles'
      h = if scope.blank?
        self.calculate(opsym, field, :group => "accesses.id", :joins => :profiles)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => "accesses.id", :joins => :profiles)
        }
      end
      return ret_hash ? h : labels.map{|l| (l.is_a?(Fixnum) ? h[l] : (h[l.id] || h[l.id.to_s])) || 0}
    when :"user_accesses.read", 'user_accesses.read'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'user_accesses.read', :joins => :user_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'user_accesses.read', :joins => :user_accesses)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"user_accesses.write", 'user_accesses.write'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'user_accesses.write', :joins => :user_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'user_accesses.write', :joins => :user_accesses)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"profile_accesses.read", 'profile_accesses.read'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'profile_accesses.read', :joins => :profile_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'profile_accesses.read', :joins => :profile_accesses)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"profile_accesses.write", 'profile_accesses.write'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'profile_accesses.write', :joins => :profile_accesses)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'profile_accesses.write', :joins => :profile_accesses)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :"users.active", 'users.active'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.active', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.active', :joins => :users)
        }
      end
      if ret_hash
        return h
      else
        serie = []
        labels.each_with_index{|l,idx| serie << (h[idx+1] || 0)}
        return serie
      end
    when :app_sid, 'app_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'app_sid')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'app_sid')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :set_sid, 'set_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'set_sid')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'set_sid')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :table_sid, 'table_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'table_sid')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'table_sid')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :field_sid, 'field_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'field_sid')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'field_sid')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :action_sid, 'action_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'action_sid')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'action_sid')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :type_sid, 'type_sid'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'type_sid')
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'type_sid')
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"profiles.name", 'profiles.name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'profiles.name', :joins => :profiles)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'profiles.name', :joins => :profiles)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.login", 'users.login'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.login', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.login', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.first_name", 'users.first_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.first_name', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.first_name', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.last_name", 'users.last_name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.last_name', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.last_name', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.email", 'users.email'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.email', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.email', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.language", 'users.language'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.language', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.language', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.password", 'users.password'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.password', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.password', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.hashed_password", 'users.hashed_password'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.hashed_password', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.hashed_password', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.salt", 'users.salt'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.salt', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.salt', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.last_session_id", 'users.last_session_id'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'users.last_session_id', :joins => :users)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'users.last_session_id', :joins => :users)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"profiles.name", 'profiles.name'
      h = if scope.blank?
        self.calculate(opsym, field, :group => 'profiles.name', :joins => :profiles)
      else
        self.with_scope(:find => {:conditions => scope}) {
          self.calculate(opsym, field, :group => 'profiles.name', :joins => :profiles)
        }
      end
      return ret_hash ? h : labels.map{|l| h[l] || 0}
    when :"users.last_login", 'users.last_login'
      if opts[:period]
        lab_format = ""
        pgroup = case opts[:period].to_sym
        when :day
          lab_format = '%Y-%m-%d'
          "DATE(users.last_login)"
        when :week
          lab_format = '%Y-%W'
          "CONCAT(YEAR(users.last_login),'-', WEEK(users.last_login))"
        when :month
          lab_format = '%Y-%m'
          "CONCAT(YEAR(users.last_login),'-', MONTH(users.last_login))"
        when :year
          lab_format = '%Y'
          "YEAR(users.last_login)"
        end
        h = if scope.blank?
          self.calculate(opsym, field, :group => pgroup, :order => 'users.last_login', :joins => :users)
        else
          self.with_scope(:find => {:conditions => scope}) {
            self.calculate(opsym, field, :group => pgroup, :order => 'users.last_login', :joins => :users)
          }
        end
        return ret_hash ? h : labels.map{|l| h[l.strftime(lab_format)] || 0}
      else
        h = {}
        labels.each_with_index { |l, idx|
          h[l] = if scope.blank?
            self.where(["accesses.#{group} >= ? AND accesses.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
          else
            self.with_scope(:find => {:conditions => scope}) {
              self.where(["accesses.#{group} >= ? AND accesses.#{group} < ?", l, labels[idx+1]]).calculate(opsym, field)
            }
          end
        }
        return ret_hash ? h : labels.map{|l| h[l] || 0}
      end
    else
      logger.debug("Unknown Group: #{group} (operation: #{opsym}, scope: #{scope})")
    end
    return []
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = Access.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.access_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    Access.first(:order => 'accesses.id DESC', :conditions => ["accesses.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    Access.first(:order => 'accesses.id', :conditions => ["accesses.id > ?", self.id])
  end

  # Author:: Yann Azoury
  # Version:: 4
  # Last Update:: 2012-08-05 03:20:31 UTC

  scope(:tables, :conditions => {:field_sid => nil, :action_sid => nil})


  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2013-01-09 14:32:57 UTC


  def self.named_scope_actions_method(mav = nil)
    case mav
    when nil
      where('action_sid IS NOT NULL AND field_sid IS NULL')
    when Access
      where(["action_sid IS NOT NULL AND field_sid IS NULL AND table_sid = ?", mav.table_sid])
    when String, Symbol
      where(["action_sid IS NOT NULL AND field_sid IS NULL AND table_sid = ?", mav.to_s])
    end
  end

  scope(:actions, proc {|mav| named_scope_actions_method(mav) })

  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2009-06-25 12:55:28 UTC


  def self.named_scope_fields_method(mav = nil)
    case mav
    when nil
      {:conditions => 'action_sid IS NULL AND field_sid IS NOT NULL'}
    when Access
      {:conditions => ["action_sid IS NULL AND field_sid IS NOT NULL AND table_sid = ?", mav.table_sid]}
    when String, Symbol
      {:conditions => ["action_sid IS NULL AND field_sid IS NOT NULL AND table_sid = ?", mav.to_s]}
    end
  end

  scope(:fields, proc {|mav| named_scope_fields_method(mav) })

  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-11-01 16:01:43 UTC


  def self.named_scope_default_scope_method

    {}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      case field.to_sym
      when :home_page_profiles, :home_page_id
        joins_fields << :home_page_profiles
      when :user_accesses, :access_id
        joins_fields << :user_accesses
      when :profile_accesses, :access_id
        joins_fields << :profile_accesses
      end
      if [:app_sid, :set_sid, :table_sid, :field_sid, :action_sid, :type_sid, :home_page_profiles, :home_page_id, :user_accesses, :access_id, :profile_accesses
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })


# Checks per-field accesses.
#
# Author:: Yann Azoury
# Version:: 6
# Last Update:: 2011-01-22 17:09:47 UTC
# Status:: Validated


def self.restricted_fields(page=nil)
case page
when nil

  #	model_classes.const_get('RESTRICTED_FIELDS')

  []
when Fixnum
  return self.restricted_fields(Access.find_by_id(page).table_sid)
when Access
  return self.restricted_fields(page.table_sid)
when String, Symbol
  begin
    klass = page.classify.constantize
    restr = klass.const_defined?('RESTRICTED_FIELDS') ? klass::RESTRICTED_FIELDS : []
    all(:conditions => {:table_sid => page.to_s, :field_sid => restr.map(&:to_s)})
  rescue => e
    logger.warn("Error during retrieve of restricted fields: #{e}")
    []
  end
end
end


# User display default
#
# Author:: Yann Azoury
# Version:: 2
# Last Update:: 2009-09-23 15:00:18 UTC
# Status:: Validated


def disp_name
if self.field_sid.blank?
  if self.action_sid.blank?
    return "Page #{self.table_sid.titleize}"
  else
    return "Action #{self.action_sid.titleize} for #{self.table_sid.titleize}"
  end
else
  return "Field #{self.field_sid.titleize} for #{self.table_sid.titleize}"
end
end


# Removes useless duplicates.
#
# Author:: Sylvain AbÃ©lard
# Version:: 3
# Last Update:: 2010-06-15 19:22:14 UTC
# Status:: Validation Pending


def self.clean_duplicates
count(:action_sid, :group => :table_sid).keys.map { |t|
  actions(nil).count(:id, :group => :action_sid, :conditions => {:table_sid => t}).select{|k,v| k && v > 1}.each { |k,v|
    actions.all(:conditions => {:action_sid => k, :table_sid => t}).last.destroy
  }
  fields(nil).count(:id, :group => :field_sid, :conditions => {:table_sid => t}).select{|k,v| k && v > 1}.each { |k,v|
    fields.all(:conditions => {:field_sid => k, :table_sid => t}).last.destroy
  }
}
end


# Author:: Sylvain AbÃ©lard
# Version:: 2
# Last Update:: 2011-06-16 19:38:34 UTC
# Status:: In Progress


def global_searchable_models
self.tables.map(&:table_sid).map(&:classify).map{|s|
  begin
    m = s.constantize
    m.const_defined?('SEARCHABLE_FIELDS') && m::SEARCHABLE_FIELDS.any? ? m : nil
  rescue NameError => e
    nil
  end
}.compact
end

# useful method


def home_page_profiles_human_display

return home_page_profiles.map(&:disp_name).to_sentence(:connector => _('and'))

end


# useful method


def user_accesses_human_display

return user_accesses.map(&:disp_name).to_sentence(:connector => _('and'))

end


# useful method


def profile_accesses_human_display

return profile_accesses.map(&:disp_name).to_sentence(:connector => _('and'))

end


# useful method


def users_human_display

return users ? users.disp_name : ""

end


# useful method


def profiles_human_display

return profiles ? profiles.disp_name : ""

end


def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs
if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics



# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def app_sid_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain AbÃ©lard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def app_sid_to_spreadsheet(opts={})
self.app_sid
end


# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def set_sid_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain AbÃ©lard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def set_sid_to_spreadsheet(opts={})
self.set_sid
end


# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def table_sid_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain AbÃ©lard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def table_sid_to_spreadsheet(opts={})
self.table_sid
end


# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def field_sid_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain AbÃ©lard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def field_sid_to_spreadsheet(opts={})
self.field_sid
end


# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def action_sid_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain AbÃ©lard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def action_sid_to_spreadsheet(opts={})
self.action_sid
end


# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def type_sid_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain AbÃ©lard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def type_sid_to_spreadsheet(opts={})
self.type_sid
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def home_page_profiles__potential_values(options = {})
if options.has_key?(:page)
  Profile.paginate(options)
else
  Profile.all(options)
end
end


# Exporting associations: listing names of linked objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 8
# Last Update:: 2011-06-15 21:03:45 UTC
# Status:: Requires Tests


def home_page_profiles_to_spreadsheet(opts={})

self.home_page_profiles.map(&:disp_name).join(opts[:join] || ', ')

end


# Importing associations: this is way too tricky to let a machine do an educated guess, so you should specify according to your needs.
#
# Author:: Sylvain AbÃ©lard
# Version:: 9
# Last Update:: 2011-06-15 21:09:38 UTC
# Status:: Requires Tests


def home_page_profiles_from_spreadsheet(v, opts={})

if v.blank?
  []
else
  Profile.find_all_by_app_sid(v)
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def user_accesses__potential_values(options = {})
if options.has_key?(:page)
  UserAccess.paginate(options)
else
  UserAccess.all(options)
end
end


# Exporting associations: listing names of linked objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 8
# Last Update:: 2011-06-15 21:03:45 UTC
# Status:: Requires Tests


def user_accesses_to_spreadsheet(opts={})

self.user_accesses.map(&:disp_name).join(opts[:join] || ', ')

end


# Importing associations: this is way too tricky to let a machine do an educated guess, so you should specify according to your needs.
#
# Author:: Sylvain AbÃ©lard
# Version:: 9
# Last Update:: 2011-06-15 21:09:38 UTC
# Status:: Requires Tests


def user_accesses_from_spreadsheet(v, opts={})

if v.blank?
  []
else
  UserAccess.find_all_by_app_sid(v)
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def profile_accesses__potential_values(options = {})
if options.has_key?(:page)
  ProfileAccess.paginate(options)
else
  ProfileAccess.all(options)
end
end


# Exporting associations: listing names of linked objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 8
# Last Update:: 2011-06-15 21:03:45 UTC
# Status:: Requires Tests


def profile_accesses_to_spreadsheet(opts={})

self.profile_accesses.map(&:disp_name).join(opts[:join] || ', ')

end


# Importing associations: this is way too tricky to let a machine do an educated guess, so you should specify according to your needs.
#
# Author:: Sylvain AbÃ©lard
# Version:: 9
# Last Update:: 2011-06-15 21:09:38 UTC
# Status:: Requires Tests


def profile_accesses_from_spreadsheet(v, opts={})

if v.blank?
  []
else
  ProfileAccess.find_all_by_app_sid(v)
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def users__potential_values(options = {})
if options.has_key?(:page)
  User.paginate(options)
else
  User.all(options)
end
end


# Exporting associations: listing names of linked objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 8
# Last Update:: 2011-06-15 21:03:45 UTC
# Status:: Requires Tests


def users_to_spreadsheet(opts={})

self.users.map(&:disp_name).join(opts[:join] || ', ')

end


# Importing associations: this is way too tricky to let a machine do an educated guess, so you should specify according to your needs.
#
# Author:: Sylvain AbÃ©lard
# Version:: 9
# Last Update:: 2011-06-15 21:09:38 UTC
# Status:: Requires Tests


def users_from_spreadsheet(v, opts={})

if v.blank?
  []
else
  User.find_all_by_app_sid(v)
end
end


# Author:: Yann Azoury
# Version:: 3
# Last Update:: 2012-03-19 01:57:30 UTC
# Status:: Validated


def profiles__potential_values(options = {})
if options.has_key?(:page)
  Profile.paginate(options)
else
  Profile.all(options)
end
end


# Exporting associations: listing names of linked objects.
#
# Author:: Sylvain AbÃ©lard
# Version:: 8
# Last Update:: 2011-06-15 21:03:45 UTC
# Status:: Requires Tests


def profiles_to_spreadsheet(opts={})

self.profiles.map(&:disp_name).join(opts[:join] || ', ')

end


# Importing associations: this is way too tricky to let a machine do an educated guess, so you should specify according to your needs.
#
# Author:: Sylvain AbÃ©lard
# Version:: 9
# Last Update:: 2011-06-15 21:09:38 UTC
# Status:: Requires Tests


def profiles_from_spreadsheet(v, opts={})

if v.blank?
  []
else
  Profile.find_all_by_app_sid(v)
end
end

# BINARIES CONSTANTS


end
