# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##############
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Mon Jul 08 14:03:11 +0200 2013
## It should be placed at 'app/models/smart_query.rb'
## All manual modifications will be destroyed on next generation
################################################


class SmartQuery < ActiveRecord::Base

  self.table_name = 'smart_queries'

  SEARCHABLE_FIELDS = [].freeze
  RESTRICTED_FIELDS = [].freeze
  FIELDS = HashWithIndifferentAccess.new(:name => :string, :table_sid => :string, :joining_criteria => :static_list, :criteria => :any_object).freeze
  COMPARATORS = {:name => ActiveSupport::OrderedHash['=~', ["smart_queries.name LIKE ?", '%%%s%'], '!~', ["smart_queries.name NOT LIKE ?", '%%%s%'], '^=', ["smart_queries.name LIKE ?", '%s%'], '$=', ["smart_queries.name LIKE ?", '%%%s'], '=', ["smart_queries.name = ?"], '!=', ["smart_queries.name <> ?"], 'NULL', ["smart_queries.name IS NULL", ''], 'NOT_NULL', ["smart_queries.name IS NOT NULL", '']],
    :table_sid => ActiveSupport::OrderedHash['=~', ["smart_queries.table_sid LIKE ?", '%%%s%'], '!~', ["smart_queries.table_sid NOT LIKE ?", '%%%s%'], '^=', ["smart_queries.table_sid LIKE ?", '%s%'], '$=', ["smart_queries.table_sid LIKE ?", '%%%s'], '=', ["smart_queries.table_sid = ?"], '!=', ["smart_queries.table_sid <> ?"], 'NULL', ["smart_queries.table_sid IS NULL", ''], 'NOT_NULL', ["smart_queries.table_sid IS NOT NULL", '']],
    :joining_criteria => ActiveSupport::OrderedHash['=', ["smart_queries.joining_criteria = ?"], '!=', ["smart_queries.joining_criteria <> ?"], 'NULL', ["smart_queries.joining_criteria IS NULL", ''], 'NOT_NULL', ["smart_queries.joining_criteria IS NOT NULL", '']],
  :criteria => ActiveSupport::OrderedHash['=~', ["smart_queries.criteria LIKE ?", '%%%s%'], '!~', ["smart_queries.criteria NOT LIKE ?", '%%%s%']]}.freeze
  JOINING_CRITERIA = ["AND - matching all criteria", "OR - matching one of the criteria"]
  LOCALIZED_JOINING_CRITERIA = [_("AND - matching all criteria"), _("OR - matching one of the criteria")]
  FILES_DEST = Rails.root.join('files', %q{smart_queries}).to_s

  serialize(:criteria)


  # == Validations



  # == Triggers



  # == Relations
  #
  # Associations through specific setters
  #
  # Virtual Fields


  attr_accessor :joining_criteria__index_was

  def self.attribute_condition(quoted_column_name, argument)
    if quoted_column_name[/\.(\'|\`){0,1}(joining_criteria)(__index){0,1}(\'|\`){0,1}\Z/]
      %Q[#{quoted_column_name.sub('__index', '')} = ?]
    else
      case argument
      when nil   then "#{quoted_column_name} IS ?"
      when Array, ActiveRecord::Associations::AssociationCollection, ActiveRecord::NamedScope::Scope then "#{quoted_column_name} IN (?)"
      when Range
        if argument.exclude_end?
          "#{quoted_column_name} >= ? AND #{quoted_column_name} < ?"
        else
          "#{quoted_column_name} BETWEEN ? AND ?"
        end
      else            "#{quoted_column_name} = ?"
      end
    end
  end


  # == Methods
  #



  # Load the matching object with right attributes.
  #
  # Author:: Sylvain Abélard
  # Version:: 53
  # Last Update:: 2013-03-22 09:46:46 UTC
  # Status:: Validated


  def self.load_from_params(att)
    return SmartQuery.new if att.blank?
    std_atts = att.reject{|k,v| %w(id).include?(k.to_s) }
    smart_query = nil
    if att.has_key?(:id) && att[:id].to_i != 0 # Useful for HasOne (ho_assoc)
      smart_query = SmartQuery.find(att[:id])
      smart_query.attributes = std_atts
    else
      smart_query = SmartQuery.new(std_atts)
    end

    # clean associations
    #clean binaries
    ## clean binaries

    if att[:criteria] && att[:criteria].is_a?(String)
      smart_query.criteria = ActiveSupport::JSON.decode(att[:criteria])
    end
    return smart_query
  end


  # The disp_name is how any record will appear in most use cases, such as lists of associated records during 'show', 'list'...
  #
  # Faveod will try to guess the best single field, based on SID, usually from fields containing "Title", "Name" or "Label".
  #
  # Customized code often will often look like these snippets:
  # Multiple key: "#{self.first_name} #{self.last_name}"
  # Date or time: "#{self.name} #{self.created_at.strftime('%H:%M %y-%m-%d') if self.created_at}"
  # Associations: "#{self.name} #{self.user ? self.user.disp_name : _('No user')}"
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2011-05-31 17:21:54 UTC
  # Status:: Validated


  def disp_name
    self.name || ''
  end


  # Search
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2011-08-09 11:16:42 UTC
  # Status:: Validation Pending


  def self.search(values, comps=nil, opts={})
    ar_opts = {}
    if values.is_a?(SmartQuery)
      ar_opts = values.to_ar_opts
    else
      cond = {}
      inc = []
      string_h = {'=' => nil, '<>' => :ne, '=~' => :like, '!=~' => :not,
        'LIKE' => :eq, 'NOT LIKE' => :ne, 'STARTS WITH' => :starts_with, 'ENDS WITH' => :ends_with,
      'IS NULL' => nil, 'IN' => nil}
      numb_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      date_h = {'=' => nil, '<>' => :ne, '>' => :gt, '<' => :lt, '>=' => :gte, '<=' => :lte, 'IS NULL' => nil, 'IN' => nil}
      bin_h = {'is named' => :eq, 'size larger than' => :gte, 'size smaller than' => :lte, 'is not set' => nil}
      assoc_h = {'<>' => :ne, '=' => nil, 'IN' => nil, 'IS NULL' => nil}
      SmartQuery.new.params_to_attributes(values).each { |k,v|

      }
      ar_opts = {:conditions => cond}
      ar_opts[:include] = inc unless inc.blank?
    end
    ar_opts[:per_page] = opts[:per_page] ? opts[:per_page] : count(:all, ar_opts)
    ar_opts[:per_page] = 1 if ar_opts[:per_page] == 0
    ar_opts[:page]	   = opts[:page] ? opts[:page] : 1
    paginate(ar_opts)
  end


  # Import maps elements from KML format.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-10-18 22:14:54 UTC
  # Status:: Validated


  def self.from_kml(path)
    doc = Nokogiri::XML(File.read(path))
    doc.css('Placemark').each {|l|
      pi = l.css('Data[name=Name] value')[0].content.strip
      country = SmartQuery.find_by_name(pi)
      poly = l.css('Polygon').to_a.flatten.map{|p|
        p.content.gsub(/,0\.0/, ',').split(',').map(&:to_f)
      }.flatten
      (poly.length / 2).times{
        country.smartquery_borders.create(:lat => poly.shift, :lng => poly.shift)
      }
    }
  end


  # Return the previous element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2009-09-14 14:48:02 UTC
  # Status:: Validated


  def previous

    SmartQuery.first(:order => 'smart_queries.id DESC', :conditions => ["smart_queries.id < ?", self.id])
  end


  # Returns next element.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2010-04-02 13:10:22 UTC
  # Status:: Validated


  def next

    SmartQuery.first(:order => 'smart_queries.id', :conditions => ["smart_queries.id > ?", self.id])
  end

  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2009-11-10 19:37:36 UTC


  def self.named_scope_for_table_method(table)

  end

  scope(:for_table, proc {|table| named_scope_for_table_method(table) })

  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-11-01 16:01:43 UTC


  def self.named_scope_default_scope_method

    {}
  end

  default_scope(named_scope_default_scope_method())

  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-03 20:51:21 UTC


  def self.named_scope_active_filter_method(hash)

    #hash looks like {'field1' => {'op' => value}, 'field2' => ... }
    #op could be =, !=, ^=, $=, =~, !~, >, <, >=, <=, IN, FTS...

    hash ||= {}
    values = []
    joins_fields = []
    _scopes = nil
    if !hash['_scopes'].blank?
      (%w() & hash['_scopes']).each{|s|
        _scopes = (_scopes || self).send(s.to_sym)
      }
    end
    str = hash.map{|field, pairs|
      if [:name, :table_sid, :joining_criteria, :criteria
      ].include?(field.to_sym)
      Array(pairs).map do |op,val|
        cmp = COMPARATORS[field.to_sym][op]
        values << (cmp.length == 1 ? val : (cmp[1] % val)) unless cmp[1] && cmp[1] == ''
        cmp[0]
      end
    elsif [
    ].include?(field.to_sym)
    Array(pairs).map do |op,val|
      cmp = COMPARATORS[field.to_sym][op]
      values += Array(val)
      "(%s)" % val.map{|v| cmp[0] }.join(' OR ')
    end
  end
}.compact.flatten.join(' AND ')
if _scopes
  return _scopes.proxy_options if values.blank?
  return _scopes.joins(joins_fields).where(values.insert(0, str)).proxy_options
else
  res = joins_fields.blank? ? {} : {:joins => joins_fields}
  res[:conditions] = values.insert(0, str)
  return res
end
end

scope(:active_filter, proc {|hash| named_scope_active_filter_method(hash) })


# Transforms query hash in ActiveRecord conditions.
#
# Author:: Sylvain Abélard
# Version:: 38
# Last Update:: 2011-05-19 11:50:52 UTC
# Status:: Validated


def to_ar_opts
return {} if self.criteria.blank?
cond1 = ""
cond2 = []
joins = []
incs  = []

# TODO : case sensitive, IS et NULL séparés, manage date and times correctly for < and >

self.criteria.flatten.each do |c|
  if c.is_a?(Hash) || c.is_a?(HashWithIndifferentAccess)

    # FIELD

    field = c[:field].to_sym
    c_field = case my_model::FIELDS[field]
    when :bt_assoc
      assoc = my_model.reflect_on_association(field)
      assoc.primary_key_name
    when :hm_assoc, :ho_assoc
      assoc = my_model.reflect_on_association(field)
      table = assoc.klass.table_name
      joins << table
      "`#{table}`.`id`"
    when :habtm_assoc
      assoc = my_model.reflect_on_association(field)
      table = assoc.klass.table_name
      joins << table
      join_table = assoc.options[:join_table] || join_table_name(table, undecorated_table_name(my_model.table_name, reflection.class_name))
      "`#{join_table}`.`#{assoc.primary_key_name}`"
    else field
    end
    c_field = "`#{c_field}`" unless c_field.to_s[/\A\`.*\`\Z/]

    # VALUE

    c_val = 'NULL' if c[:value] == 'NULL'
    c_val ||= case my_model::FIELDS[field]
    when :date
      d = Chronic.parse(c[:value])
      d ? d.to_date.to_s(:db) : next
    when :datetime, :timestamp
      d = Chronic.parse(c[:value])
      d ? d.to_s(:db) : next
    when :boolean
      c[:value] == 'true' || c[:value] == true || c[:value] == 1
    when :static_list
      idx = my_model.const_get(field.to_s.pluralize.upcase).index(c[:value])
      idx ? idx + 1 : c[:value].to_i
    when :hm_assoc, :ho_assoc, :habtm_assoc, :bt_assoc
      c[:value].is_a?(Enumerable) ? c[:value].map(&:to_i) : c.to_i
    else c[:value] || ''
    end

    # COMPARISON

    c[:compare] = 'IN' if c_val.is_a?(Array)
    if c[:compare] == 'LIKE2' || c[:compare] == 'NOT LIKE2'
      c_comp = c[:compare].sub(/2/, '')
      cond1 << "(#{c_field} #{c_comp} ?)"
      cond2 << '%' + c_val + '%'
    elsif c[:compare] == 'IS NULL' || (c[:compare] == 'IS' && c_val == 'NULL')
      cond1 << "#{c_field} IS NULL "
    else
      cond1 << "(#{c_field} #{c[:compare]} (?))"
      cond2 << c_val
    end
  else
    cond1 << c + " "
  end

  # JOINING

  cond1 << " #{self.joining_criteria__index == 2 ? 'OR' : 'AND'} "
end
cond1.sub!(/(OR|AND)\s\Z/, '')
ret = cond1.blank? ? {} : {:conditions => ([cond1] + cond2)}
ret[:joins] = joins.map(&:to_sym) unless joins.empty?
ret[:include] = incs.map(&:to_sym) unless incs.empty?
return ret
end


# Get fields eligible for search.
#
# Author:: Pierre Carrio
# Version:: 6
# Last Update:: 2013-03-21 17:32:02 UTC
# Status:: Validation Pending


def self.search_fields_of(model)
kl = case model
when Class then model
when String then model.classify.constantize
when Symbol then model.to_s.classify.constantize
end
return kl::SEARCHABLE_FIELDS

# return kl::FIELDS.reject{|k,v|
#  [:binary, :any_object, :color].include?(v) || !fields.include?(k.to_s)}.keys

end


# Takes raw query parameters and makes a more usable conditions hash.
#
# Author:: Sylvain Abélard
# Version:: 8
# Last Update:: 2010-06-16 14:51:43 UTC
# Status:: Validation Pending


def self.clean_criteria(criteria)
crits = criteria.is_a?(Hash) ? criteria.values : criteria
return [] if crits.blank?
res = crits.reject{|v| v[:compare].blank? || (v[:value].blank? && !v[:compare].include?('NULL'))}.map{|v|
  if v[:value].is_a?(Hash)
    t  = v[:value]
    if t[:year].blank?
      dt = Time.parse("#{t[:hour]}:#{t[:minute]}")
      v[:value] = dt.strftime("%H:%M") if dt
    else
      dt = DateTime.civil(t[:year].to_i, t[:month].to_i, t[:day].to_i, t[:hour].to_i, t[:minute].to_i, t[:second].to_i)
      dt = dt.to_date if dt && t[:hour].blank?
      v[:value] = dt.to_formatted_s(:db) if dt
    end
  end
  v
}
return res
end


# Gets model class from name
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2010-06-16 14:51:54 UTC
# Status:: Validation Pending


def my_model(name=nil)
Kernel.const_get((name || self.table_sid).classify)
end

def self.assoc_sids_to_columns(attrs)
h = attrs.has_key?(:conditions) ? attrs[:conditions] : attrs
if attrs.has_key?(:conditions)
  attrs[:conditions] = h
  attrs
else
  h
end
end


#== Field Logics



# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def name_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def name_to_spreadsheet(opts={})
self.name
end


# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def table_sid_from_spreadsheet(v, opts={})
v
end


# Exporting: displays raw value
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def table_sid_to_spreadsheet(opts={})
self.table_sid
end


# Returns translated string value.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2013-03-21 11:35:21 UTC
# Status:: Validated


def joining_criteria(t = false)
return nil if read_attribute(:joining_criteria).nil? || read_attribute(:joining_criteria) == 0
return t ? _(JOINING_CRITERIA[(read_attribute(:joining_criteria)) - 1].to_s) : JOINING_CRITERIA[(read_attribute(:joining_criteria)) - 1].to_s
end


# Returns the 1-based index(es).
#
# Author:: Yann Azoury
# Version:: 1
# Last Update:: 2010-01-18 00:13:42 UTC
# Status:: Validated


def joining_criteria__index
return read_attribute(:joining_criteria)
end


# Returns the potential values for this list.
#
# Author:: Yann Azoury
# Version:: 2
# Last Update:: 2011-08-09 11:09:07 UTC
# Status:: Validated


def joining_criteria__potential_values(current_user = nil)
JOINING_CRITERIA
end


# Flexible setter for the static list.
#
# Author:: Yann Azoury
# Version:: 12
# Last Update:: 2013-04-18 16:26:46 UTC
# Status:: Validated


def joining_criteria=(val)

self.joining_criteria__index_was = self.joining_criteria__index
case val
when nil
  write_attribute(:joining_criteria, nil)
when 1..2 # index
  write_attribute(:joining_criteria, val)
when "1", "2" # index as string
  write_attribute(:joining_criteria, val.to_i)
else String # value
  write_attribute(:joining_criteria, (self.joining_criteria__potential_values.index(val)))
end
end


# Author:: Yann Azoury
# Version:: 5
# Last Update:: 2011-08-09 11:20:02 UTC
# Status:: In Progress


def joining_criteria_report_color_for(value)

colors = Faveod::DistributedColors.n_colors(2)
case value
when "AND - matching all criteria", 1
  return colors[0]
when "OR - matching one of the criteria", 2
  return colors[1]
end
end


# Exporting: displays raw value
#
# Author:: Sylvain Abélard
# Version:: 4
# Last Update:: 2011-06-09 19:52:49 UTC
# Status:: Validation Pending


def joining_criteria_to_spreadsheet(opts={})
self.joining_criteria
end


# Importing static lists: if inputs are not sanitized, you will probably have to specify this method.
#
# Author:: Yann Azoury
# Version:: 4
# Last Update:: 2011-08-09 11:18:36 UTC
# Status:: Requires Tests


def joining_criteria_from_spreadsheet(v, opts={})

# Getting potential values

po_values = SmartQuery::JOINING_CRITERIA
if v.is_a?(Numeric)
  v				# index
elsif po_values.include?(v)
  po_values.index(c) + 1	# value
elsif c.to_i == 0 && c == '0'	# 0 index
  1
elsif c.to_i > 0		# string as an index
  c.to_i
else
  nil				# could not match
end
end


# Importing raw data: string, text, color and any_objects.
#
# Author:: Sylvain Abélard
# Version:: 2
# Last Update:: 2011-06-08 19:24:00 UTC
# Status:: Requires Tests


def criteria_from_spreadsheet(v, opts={})
v
end


# Exporting data: try to dump data as a string
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2011-06-08 18:34:24 UTC
# Status:: Requires Tests


def criteria_to_spreadsheet(opts={})
self.criteria.to_s
end


# Exporting no data: displays the field name
#
# Author:: Sylvain Abélard
# Version:: 3
# Last Update:: 2011-06-08 18:34:35 UTC
# Status:: Validation Pending


def test_query_to_spreadsheet(opts={})
_(%q{Test Query})
end

# BINARIES CONSTANTS


end
