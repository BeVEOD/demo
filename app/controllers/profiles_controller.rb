# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:40:24 +0100 2013
## It should be placed at 'app/controllers/profiles_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class ProfilesController < ApplicationController
  layout 'application_jquery_horizontal'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :create) do
    request.request_method_symbol == :post
  end
  before_filter(:only => :update) do
    request.request_method_symbol == :put
  end

  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])

  # AJAX association management.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2011-06-23 17:57:01 UTC
  # Status:: Requires Tests


  def linker

    render(:text => _('AJAX only')) and return if !request.xhr?
    render(:text => _('Missing required parameter')) and return if params[:id].blank? || params[:sid].blank?
    params[:page] = 1 if params[:page].to_i == 0
    params[:per_page] = 15 if params[:per_page].to_i == 0
    @profile   = Profile.find_by_id(params[:id])
    @profile ||= Profile.new
    case params[:sid].to_sym
    when :users
      val = params["user"] ? params["user"]["0"] : {}
      @users = User.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/users/list_for_linker', :locals => {:assoc_sid => :profiles, :assoc_type => :has_and_belongs_to_many}
    when :home_page
      val = params["home_page"] ? params["home_page"]["0"] : {}
      @home_page = Access.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/accesses/list_for_linker', :locals => {:assoc_sid => :home_page_profiles, :assoc_type => :belongs_to}
    when :accesses
      val = params["access"] ? params["access"]["0"] : {}
      @accesses = Access.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/accesses/list_for_linker', :locals => {:assoc_sid => :profiles, :assoc_type => :has_many_through}
    when :profile_accesses
      val = params["profile_access"] ? params["profile_access"]["0"] : {}
      @profile_accesses = ProfileAccess.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/profile_accesses/list_for_linker', :locals => {:assoc_sid => :profile, :assoc_type => :has_many}
    end
  end


  # Index of all <%= model.sid %>.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-05-20 16:26:24 UTC
  # Status:: Validation Pending


  def index

    list
    unless(%w(json xml).include?(params[:format]))
      render(:action => :list)
    end
  end


  # This gives the list of all records
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-01-29 17:02:44 UTC
  # Status:: Validation Pending


  def list

    @restricted_fields = []
    pagin_opts = {:include => [:users,:home_page,:profile_accesses]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:profiles_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'profiles.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @profiles = Profile.paginate(pagin_opts)
    render(:xml => @profiles.to_xml(:dasherize => false, :only => [:id,:name], :methods => [:users_human_display,:home_page_human_display,:accesses_human_display,:profile_accesses_human_display])) and return if params[:format] == 'xml'
    render(:json => @profiles) and return if params[:format] == 'json'
    render(:pdf => @profiles, :action => :list) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["name", "home_page"].include?(params[:group_by])
      @profiles_groups = @profiles.inject({}) { |acc,elt|
        crit = nil
        if ["home_page"].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # Loads a new record.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-03-25 18:26:30 UTC
  # Status:: Validation Pending


  def new

    @profile_attributes = params[:profile] ? params[:profile]['0'].clone : {}

    @profile = Profile.load_from_params(@profile_attributes)

    render(:layout => !request.xhr?)
  end


  # Inserts the record in the database.
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2013-10-31 16:38:41 UTC
  # Status:: Validation Pending


  def create

    redirect_to(:action => :index) and return unless request.post?
    redirect_to(:action => :index) and return if params[:profile].blank? || !params[:profile].is_a?(Hash)
    @profile_attributes = params[:profile] ? params[:profile]['0'].clone : {}

    @profile = Profile.load_from_params(@profile_attributes)
    if @profile.errors.empty? && @profile.save
      flash[:notice] = _("%{page} was successfully created.") % {:page => _("Profile")}
      if request.xhr? # && params[:format] == 'json'
        render(:json => {:id => @profile.id}.merge(@profile.attributes).to_json)
        return
      end
    else
      if request.xhr? # && params[:format] == 'json'
        render(:json => ({:errors => @profile.errors.full_messages}.merge(@profile.attributes)).to_json)
      else
        render(:action => :new)
      end
      return
    end
    if params[:go_to].blank?
      redirect_to :action => (params[:commit_and_new] ? :new : :index)
    else
      redirect_to(params[:go_to])
    end
  end


  # Display the record.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2012-03-26 04:12:53 UTC
  # Status:: Validation Pending


  def show

    @profile_attributes = params[:profile] ? params[:profile][params[:id]].clone : {}
    @profile_attributes.merge!(:id => params[:id]) if @profile_attributes

    @profile = Profile.load_from_params(@profile_attributes)
    if @profile.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'profile', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    respond_to do |format|
      format.html {
      render :layout => !request.xhr? }
      format.pdf {
      render :layout => false }
      format.xml {
      render :xml => @profile.to_xml }
      format.json {
      render :json => @profile.to_json }
    end
  end


  # Load the data to fill the edit form.
  #
  # Author:: Yann Azoury
  # Version:: 11
  # Last Update:: 2012-03-25 20:53:17 UTC
  # Status:: Validation Pending


  def edit

    @profile_attributes = params[:profile] ? params[:profile][params[:id]].clone : {}
    @profile_attributes.merge!(:id => params[:id]) if @profile_attributes

    @profile = Profile.load_from_params(@profile_attributes)
    if @profile.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'profile', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    render(:layout => !request.xhr?)
  end


  # Updates the current row in database from the sent form.
  #
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2012-12-13 11:53:56 UTC
  # Status:: Validation Pending


  def update

    redirect_to(:action => :index) and return unless request.put?
    redirect_to(:action => :index) and return if params[:profile].blank? || !params[:profile].is_a?(Hash)
    @profile_attributes = params[:profile] ? params[:profile][params[:id]].clone : {}
    @profile_attributes.merge!(:id => params[:id]) if @profile_attributes

    @profile = Profile.load_from_params(@profile_attributes)
    if @profile.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'profile', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end
    if @profile.save
      flash[:notice] = _("%{page} was successfully updated.") % {:page => _("Profile")}
    else
      if request.xhr?
        render(:json => {:errors =>
        @profile.errors.full_messages})
      else
        render(:action => :edit, :id => @profile.id)
      end
      return
    end
    render(:json => "OK") and return if request.xhr?
    if params[:profile].length == 1 # single edit
      redirect_to :action => :show, :id => @profile.id
    else
      redirect_to :action => :index
    end
  end


  # Deletes an object or list of objects from the database.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2011-03-08 15:34:31 UTC
  # Status:: Validation Pending


  def destroy

    if params[:id].is_a?(Array)
      @success = Profile.destroy(params[:id])
    else
      @profile = Profile.find_by_id(params[:id])
      @profile.destroy unless @profile.nil?
      @success = @profile && @profile.destroyed?
    end
    if @success
      flash[:notice] = _("%{model} %{name} successfully deleted.") % {:model => _("Profile"), :name => @profile.disp_name}
    else
      flash[:warning] = _("%{model} %{name} could not be deleted.") % {:model => _("Profile"), :name => params[:name]}
    end
    if params[:format] != "json"
      if request.xhr?
        render :action => 'ajax_update', :layout => false
      else
        if params[:go_to].blank?
          redirect_to :action => :index
        else
          redirect_to(params[:go_to])
        end
      end
    else
      resp = {}
      if @success
        resp[:success] = true
      else
        resp[:success] = false
        resp[:error] = flash[:warning]
      end
      render :json => resp.to_json, :layout => false
    end
  end


  # Search and filter data.
  #
  # Author:: Sylvain Abélard
  # Version:: 44
  # Last Update:: 2010-06-15 18:38:22 UTC
  # Status:: Requires Tests


  def search

    @profile = Profile.load_from_params(params[:profile]["0"]) if params[:profile]
    @profile ||= Profile.new
    page	   = params[:page].to_i > 0 ? params[:page].to_i : 1
    per_page   = params[:per_page]
    per_page ||= Profile.count if params[:format] && %w(xml xls csv).include?(params[:format])
    per_page   = 50 if !per_page || per_page == 0

    # GET RESULTS FROM SMART_QUERY OR PARAMS

    if params[:profile]
      my_p = params[:profile]["0"].reject{|k, v|
        params["comp_#{k}"].blank? || (v.blank? && !params["comp_#{k}"].include?('NULL'))
      } if params[:profile]["0"]
      @profiles = Profile.search(my_p, params.reject{|k,v| !k[/comp_/]}, :page => page, :per_page => per_page)
    elsif params[:query]
      @profiles = Profile.active_filter(ActiveSupport::JSON.decode(params[:query])).paginate(:page => page, :per_page => per_page)
    elsif params[:fts_query]
      l = params[:limit] ? params[:limit] : :all
      @profiles = Profile.find_with_ferret(params[:fts_query], :limit => l)
    elsif (params[:id] || params[:smart_query])
      if params[:id]
        @smart_query = SmartQuery.find_by_id(params[:id])
      else
        attr = params[:smart_query].first[1] if params[:smart_query].first
        attr[:criteria] = SmartQuery.clean_criteria(attr[:criteria])
        @smart_query = SmartQuery.new(attr)
      end
      @profiles = Profile.search(@smart_query, :page => page, :per_page => per_page)
    else
      opts = {:include => [:users,:home_page,:profile_accesses]}
      opts[:page]		  = page
      opts[:per_page]	  = per_page
      opts[:order]		  = @default_order
      opts[:order]		||= 'profiles.' +params[:sort_by] if !params[:sort_by].blank?
      opts[:conditions]	||= @default_filter
      opts[:joins] 		||= @joins_fields  || []
      @profiles = Profile.paginate(opts)
    end

    # RENDER SOMETHING

    if !@profiles.blank? && params[:format] # GET
      if params[:format] == 'xml'
        send_data(@profiles.to_xml,
        :filename => ('profiles.xml'),
        :disposition => 'attachment',
        :type => 'text/xml;charset=utf-8')
        return
      elsif params[:format] == 'xls'
        cols = []
        Profile::FIELDS.each{|k,v|
        cols << k if [:string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
        book = Spreadsheet::Workbook.new
        sheet = book.create_worksheet(:name => "profiles")
        sheet.row(0).concat(cols)
        @profiles.each_with_index do |row,i|
          sheet.row(i+1).replace(cols.map{|c|
            if [:ho_assoc, :bt_assoc].include?(Profile::FIELDS[c])
              v = row.send(c)
              v ? v.disp_name : ''
            else
              row.send(c)
            end
          })
        end
        fname = "profiles.xls"
        tmp = Tempfile.new(fname)
        book.write(tmp.path)
        tmp.close
        send_file(tmp.path, :filename => fname)
        return
      elsif params[:format] == 'csv'
        cols = Profile::FIELDS.inject([]) {|a,v|
        a << v[0] if [:ho_assoc, :bt_assoc, :string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp].include?(v[1]) ; a}
        @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';') }) do |csv|
          csv << cols
          for row in @profiles
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(Profile::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
        end
        @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
        conv = Iconv.new(@export_encoding, 'UTF-8')
        send_data(conv.iconv(@csv_string), :filename => "profiles.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        return
      end
    end
    if request.xhr? || request.post?
      render :partial => 'result_list' and return
    end
  end


  # Rights management: display graph.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:39:07 UTC
  # Status:: Requires Tests


  def access_graph

    @profile = Profile.find_by_id(params[:id])
    if params[:format] && @profile
      @accesses = @profile.accesses
      @graph = render_graph('profiles/access_graph.dot', params[:format], 'fdp')
      send_data @graph, :disposition => 'inline'
    end
  end


  # Rights management: graph per fields.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:39:16 UTC
  # Status:: Requires Tests


  def field_access_graph

    @profile = Profile.find_by_id(params[:id])
    if params[:format] && @profile
      @accesses = @profile.accesses.all(:conditions => ["field_sid IS NOT NULL AND (profile_accesses.write = ? OR profile_accesses.read = ?)", true, true])
      @graph = render_graph('profiles/field_access_graph.dot', params[:format], 'fdp')
      send_data @graph, :disposition => 'inline'
    end
  end
  protected
  private


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1

    ckie = (RUBY_VERSION =~ /^1.8/) ? Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "") :  (cookies[:active_filters] || "").force_encoding(Encoding::ISO_8859_1).encode!(Encoding::UTF_8)
    if !ckie.blank?
      find_hash = Profile.named_scope_active_filter_method(ActiveSupport::JSON.decode(ckie))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      Profile.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_profiles_pres_mode"].to_sym unless cookies["#{APP_SID}_profiles_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_profiles_pres_mode"].to_sym unless params["#{APP_SID}_profiles_pres_mode"].blank?
  end

end
