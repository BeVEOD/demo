# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:38:01 +0100 2013
## It should be placed at 'app/controllers/bg_workers_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class BgWorkersController < ApplicationController
  layout 'application_jquery_horizontal'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :create) do
    request.request_method_symbol == :post
  end
  before_filter(:only => :update) do
    request.request_method_symbol == :put
  end
  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end

  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])

  # Reporting: displays preset reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 19:23:13 UTC
  # Status:: Requires Tests


  def report_chooser

    @data_sets = SmartQuery.all(:conditions => {:table_sid => ['bg_workers', '']})
    m_par = params[:bg_workers] || {}
    @data_set = SmartQuery.find_by_id(m_par[:data_set]) || @data_sets.first
    logger.debug("m_par #{m_par.inspect}")
  end


  # Reporting: global steps to rendering reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:24:32 UTC
  # Status:: Could be optimized


  def report_generate

    report_check_params

    #logger.debug("BEGIN report_load_labels")

    report_load_labels

    #logger.debug("END report_load_labels")
    #logger.debug("BEGIN report_load_datasets")

    report_load_datasets

    #logger.debug("END report_load_datasets")
    #logger.debug("BEGIN report_load_title")

    report_load_title

    #logger.debug("END report_load_title")

    respond_to do |format|
      format.html {report_convert_to_html}
      format.json {report_convert_to_ofc}

      #  format.pdf {report_convert_to_pdf }

    end
  end


  # Reporting: checks sent params for security and consistency.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:23:42 UTC
  # Status:: Could be optimized


  def report_check_params


    # logger.debug("BEGIN report_check_params")

    @report_type = params[:format] == 'html' ? :table : :chart
    @x_type = BgWorker::FIELDS[params[:x_field]]
    render(:text => "No correct x_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@x_type)

    # logger.debug("\t\t x_field: #{params[:x_field]} (#{@x_type})")

    if params[:y_field]
      @y_type = BgWorker::FIELDS[params[:y_field]]
      render(:text => "No correct y_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@y_type)
    end
    render(:text => "No correct serie parameter") and return if params[:serie_1].blank? || !params[:serie_1].is_a?(Hash) || (params[:serie_1][:field].blank? && params[:serie_1][:operation].blank?)
    f = params["serie_1"][:field] ||= 'id'
    o = params["serie_1"][:operation] ||= [:integer, :float, :double].include?(BgWorker::FIELDS[params["serie_1"][:field]]) ? :value : :count

    # TODO manage field is a model_method

    render(:text => "No correct serie[:field] parameter") and return if !BgWorker::FIELDS.has_key?(f) && (o != 'count')
    render(:text => "No correct serie[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(BgWorker::FIELDS[f]) && params[:serie_1][:operation].blank?)
    (2..5).each {|i|
      break if params["serie_#{i}"].blank? || !params["serie_#{i}"].is_a?(Hash)
      f = params["serie_#{i}"][:field]
      render(:text => "No correct serie_#{i}[:field] parameter") and return if f.blank? || !BgWorker::FIELDS.has_key?(f)
      render(:text => "No correct serie_#{i}[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(BgWorker::FIELDS[f]) && params["serie_#{i}"][:operation].blank?)
    }
    @x_field = params[:x_field]
    @y_field = params[:y_field] unless params[:y_field].blank?

    # logger.debug("END report_check_params")

  end


  # Reporting: extracts labels and categories to display axes.
  #
  # Author:: Yann Azoury
  # Version:: 6
  # Last Update:: 2011-01-22 17:12:57 UTC
  # Status:: Could be optimized


  def report_load_labels

    case @x_type
    when :string
      return @x_labels = BgWorker.all(:select => "DISTINCT(`#{@x_field}`)").map{|r| r.send(@x_field)}
    when :static_list
      return @x_labels = BgWorker.const_get(@x_field.pluralize.upcase)
    when :bt_assoc
      return @x_labels = BgWorker.reflect_on_association(@x_field.to_sym).klass.all
    end
    @x_range = if params[:x_range] # range is given
      case @x_type
      when :integer
        params[:x_range].split('..').map(&:to_i)
      when :float, :double
        params[:x_range].split('..').map(&:to_f)
      when :date, :datetime
        rg = params[:x_range].split('..').map(&:to_i)
        @x_min = Time.now + rg.first.days
        @x_max = Time.now + rg.last.days
        rg
      end
    else
      @x_min = BgWorker.minimum(@x_field)
      @x_max = BgWorker.maximum(@x_field)
      case @x_type
      when :integer, :float, :double
      when :date, :datetime
        [((@x_min - Time.now) / 86400).round, ((@x_max - Time.now) / 86400).round]
      end
    end
    if true
      case @x_type
      when :integer, :float, :double
        @x_min, @x_max = @x_range
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10.0
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
        @x_labels = [@x_min]
        while(@x_labels.last <= @x_max) do
          @x_labels << @x_labels.last + @x_steps
        end
      when :date, :datetime
        @x_steps = case params[:x_steps]
        when "month"
          30
        when "week"
          7
        else
          if !params[:x_steps] || params[:x_steps].to_i == 0
            (@x_range.last - @x_range.first).round / 10.0
          else
            params[:x_steps].to_i
          end
        end
        @x_steps = 1 if @x_steps == 0
        @x_min ||= Time.now + @x_range.first.days
        @x_max ||= Time.now + @x_range.last.days
        @x_labels = [@x_min]
        logger.debug("\t (#{@x_min})..(#{@x_max}) - #{@x_steps} days step")
        200.times {
          break if @x_labels.last > @x_max
          @x_labels << @x_labels.last + @x_steps.days
        }
      end
    else  # no params[:x_range] => need to guess range
      case @x_type
      when :integer, :float, :double
        @datasets.each_with_index { |h,i|
          d = h[:values]
          if !@x_min
            @x_min = d.min
          else
            d_min = d.min
            @x_min = d_min if d_min < @x_min
          end
          if !@x_max
            @x_max = d.max
          else
            d_max = d.max
            @x_max = d_max if d_max > @x_max
          end
        }
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
      end
      case @x_type
      when :integer, :float, :double
        if params[:x_ticks]
        end
      when :static_list
      when :date, :datetime
      end
    end
  end


  # Reporting: loads datasets.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:20:49 UTC
  # Status:: Could be optimized


  def report_load_datasets

    @datasets = []
    i = 1
    if @y_field
      case @y_type
      when :string
        @y_labels = BgWorker.all(:select => BgWorker.connection.distinct(@y_field, nil)).map{|r| r.send(@y_field)}
      when :static_list
        @y_labels = BgWorker.const_get(@y_field.pluralize.upcase)
      when :ho_assoc, :bt_assoc, :habtm_assoc
        @y_labels = BgWorker.all(:include => @y_field).map{|r| r.send(@y_field)}
      end
      while(params["serie_#{i}"]) do
        ds = {}
        @y_labels.each_with_index { |l,idx|
          next if l.nil?
          case @y_type
          when :string
            ds["values_for_#{l}"] = BgWorker.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => l}, :data_set => @data_set)
          when :static_list
            ds["values_for_#{l}"] = BgWorker.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => (@y_labels.index(l)+1)}, :data_set => @data_set)
          when :bt_assoc
            fk = BgWorker.reflect_on_association(@y_field.to_sym).primary_key_name

            #        BgWorker.send(:with_scope, :find => {:conditions => {fk => l.id}}) {
            #        ds["values_for_#{l.id}"] = report_retrieve_data(params["serie_#{i}"][:operation].to_s, params["serie_#{i}"][:field])

            ds["values_for_#{l.id}"] = BgWorker.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {fk => l.id}, :data_set => @data_set)

            #        }

          end
        }
        i += 1 ; @datasets << ds
      end
      return
    end
    while(params["serie_#{i}"]) do
      ds = {:values => BgWorker.report_calculation(params["serie_#{i}"][:operation],
        params["serie_#{i}"][:field],
      :group => @x_field, :labels => @x_labels, :data_set => @data_set)}
      ds[:type] = params["serie_#{i}"][:type] || 'bar'
      @y_min = 0
      y_min = ds[:values].min || 0
      @y_min = y_min if y_min < @y_min
      if !@y_max
        @y_max = ds[:values].max || 0
      else
        y_max = ds[:values].max || 0
        @y_max = y_max if y_max > @y_max
      end
      i += 1 ; @datasets << ds
    end
    case @y_max
    when 0...5 then @y_max = 5 ; @y_step = 1
    when 5..10 then @y_max = 10 ; @y_step = 1
    when 10..50 then @y_max = 50 ; @y_step = 5
    when 50..100 then @y_max = 100 ; @y_step = 10
    when 100..500 then @y_max = 500 ; @y_step = 50
    when 500..1000 then @y_max = 1000 ; @y_step = 50
    when 1000..5000 then @y_max = 5000 ; @y_step = 100
    end
  end


  # Reporting: displays selected title or guess an appropriate one.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:19:56 UTC
  # Status:: Could be optimized


  def report_load_title

    @title = _(params[:title]) and return unless params[:title].blank?
    op_nm = case params[:serie_1][:operation].to_s
    when "avg" then "Average"
    when "min" then "Minimum"
    when "max" then "Maximum"
    else params[:serie_1][:operation].to_s.titleize
    end
    @title = "#{op_nm} of " + (params[:serie_1][:operation].to_s == 'count' ? 'records' : params[:serie_1][:field].to_s)
    @title << " by " + @x_field
    case @x_type
    when :date, :datetime
      @title << " from " + @x_labels.first.strftime("%D") + " to " + @x_labels.last.strftime("%D")
    end
    @datasets.each_with_index do |ds,idx|
      ds[:text] ||= params["serie_#{idx+1}"][:operation].to_s.titleize + " of " + (params["serie_#{idx+1}"][:operation].to_s == 'count' ? 'records' : params["serie_#{idx+1}"][:field].to_s)
    end if @report_type == :chart
  end


  # Reporting: renders data in HTML tables.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:18:50 UTC
  # Status:: Could be optimized


  def report_convert_to_html

    title = "<caption>#{@title}</caption>"
    if @y_labels # matrix
      @report = @datasets.map {|ds|
        logger.debug("ds: #{ds.inspect}")
        trs = [['<th></th>'] + @x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        case @y_type
        when :ho_assoc, :bt_assoc
          trs += @y_labels.uniq.map{ |l| l ? (["<th>#{l.disp_name}</th>"] + ds["values_for_#{l.id}"].map { |v| "<td>#{v}</td>" }) : [] }
        else
          trs += @y_labels.uniq.map{ |l| ["<th>#{l}</th>"] + ds["values_for_#{l}"].map { |v| "<td>#{v}</td>" } }
        end
        "<table>#{title}%s</table>" % trs.map{|t| "<tr>#{t}</tr>"}.join
      }
    else
      @report = @datasets.map {|ds|
        trs = [@x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        trs << ds[:values].map { |v| "<td>#{v}</td>" }
        "<table>#{title}#{trs.map{|t| "<tr>#{t}</tr>"}}</table>"
      }
    end
    render :text => @report
  end


  # Reporting: adds OFC styles and renders appropriate JSON.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 12:18:04 UTC
  # Status:: Could be optimized


  def report_convert_to_ofc

    colors = %w(2222FF 7FFFD4 D2691E A9A9A9 BDB76B DCDCDC ADFF2F F4A460 F5DEB3)
    @datasets.each_with_index { |d,idx|
      d[:type] ||= "bar"
      d[:colour] ||= colors[idx]
    }
    @report = {:elements => @datasets, :title => {:text => @title}, :bg_colour => "#FFFFFF"}
    case @x_type
    when :date, :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d, :format => :short)}, :rotate => '45' }}
    when :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d.to_date, :format => :short)}, :rotate => '45' }}
    when :integer, :float, :decimal, :static_list
      @report[:x_axis] = {:labels => {:labels => @x_labels, :rotate => '45'} }
    when :bt_assoc
      @report[:x_axis] = {:labels => {:labels => @x_labels.map(&:disp_name), :rotate => '45'} }
    end
    @report[:y_axis] = {:min => @y_min, :max => @y_max}
    @report[:y_axis][:steps] = @y_step if @y_step
    render :json => @report
  end


  # Load requested report.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 17:49:09 UTC
  # Status:: Validation Pending


  def reporting

    params[:report] = "" if params[:report].blank?
    @report = params[:report]
  end


  # Responds Report data in any format.
  #
  # Author:: Yann Azoury
  # Version:: 15
  # Last Update:: 2010-06-18 18:06:28 UTC
  # Status:: Validation Pending


  def reporting_data

    report_sid = params[:report].blank? ? "" : params[:report]
    render(:nothing => true) and return if report_sid.blank?
    opts = (params[:report_options] || {}).reject{|k,v| v.blank?}
    opts[:format] ||= params[:format]
    r = BgWorkerReport.make_report(report_sid, opts)
    r[:title][:style] = r[:title][:style].tr(',', ';').gsub('colour', 'color') if r && r[:title] && r[:title][:style]
    @report = r
    respond_to do |format|
      format.json { render :json => @report }
      format.html { render :text => @report }
    end
  end


  # Index of all <%= model.sid %>.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-05-20 16:26:24 UTC
  # Status:: Validation Pending


  def index

    list
    unless(%w(json xml).include?(params[:format]))
      render(:action => :list)
    end
  end


  # Loads a new record.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-03-25 18:26:30 UTC
  # Status:: Validation Pending


  def new

    @bg_worker_attributes = params[:bg_worker] ? params[:bg_worker]['0'].clone : {}

    @bg_worker = BgWorker.load_from_params(@bg_worker_attributes)

    render(:layout => !request.xhr?)
  end


  # Inserts the record in the database.
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2013-10-31 16:38:41 UTC
  # Status:: Validation Pending


  def create

    redirect_to(:action => :index) and return unless request.post?
    redirect_to(:action => :index) and return if params[:bg_worker].blank? || !params[:bg_worker].is_a?(Hash)
    @bg_worker_attributes = params[:bg_worker] ? params[:bg_worker]['0'].clone : {}

    @bg_worker = BgWorker.load_from_params(@bg_worker_attributes)
    if @bg_worker.errors.empty? && @bg_worker.save
      flash[:notice] = _("%{page} was successfully created.") % {:page => _("Bg Worker")}
      if request.xhr? # && params[:format] == 'json'
        render(:json => {:id => @bg_worker.id}.merge(@bg_worker.attributes).to_json)
        return
      end
    else
      if request.xhr? # && params[:format] == 'json'
        render(:json => ({:errors => @bg_worker.errors.full_messages}.merge(@bg_worker.attributes)).to_json)
      else
        render(:action => :new)
      end
      return
    end
    if params[:go_to].blank?
      redirect_to :action => (params[:commit_and_new] ? :new : :index)
    else
      redirect_to(params[:go_to])
    end
  end


  # Display the record.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2012-03-26 04:12:53 UTC
  # Status:: Validation Pending


  def show

    @bg_worker_attributes = params[:bg_worker] ? params[:bg_worker][params[:id]].clone : {}
    @bg_worker_attributes.merge!(:id => params[:id]) if @bg_worker_attributes

    @bg_worker = BgWorker.load_from_params(@bg_worker_attributes)
    if @bg_worker.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'bg_worker', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    respond_to do |format|
      format.html {
      render :layout => !request.xhr? }
      format.pdf {
      render :layout => false }
      format.xml {
      render :xml => @bg_worker.to_xml }
      format.json {
      render :json => @bg_worker.to_json }
    end
  end


  # Load the data to fill the edit form.
  #
  # Author:: Yann Azoury
  # Version:: 11
  # Last Update:: 2012-03-25 20:53:17 UTC
  # Status:: Validation Pending


  def edit

    @bg_worker_attributes = params[:bg_worker] ? params[:bg_worker][params[:id]].clone : {}
    @bg_worker_attributes.merge!(:id => params[:id]) if @bg_worker_attributes

    @bg_worker = BgWorker.load_from_params(@bg_worker_attributes)
    if @bg_worker.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'bg_worker', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    render(:layout => !request.xhr?)
  end


  # Updates the current row in database from the sent form.
  #
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2012-12-13 11:53:56 UTC
  # Status:: Validation Pending


  def update

    redirect_to(:action => :index) and return unless request.put?
    redirect_to(:action => :index) and return if params[:bg_worker].blank? || !params[:bg_worker].is_a?(Hash)
    @bg_worker_attributes = params[:bg_worker] ? params[:bg_worker][params[:id]].clone : {}
    @bg_worker_attributes.merge!(:id => params[:id]) if @bg_worker_attributes

    @bg_worker = BgWorker.load_from_params(@bg_worker_attributes)
    if @bg_worker.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'bg_worker', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end
    if @bg_worker.save
      flash[:notice] = _("%{page} was successfully updated.") % {:page => _("Bg Worker")}
    else
      if request.xhr?
        render(:json => {:errors =>
        @bg_worker.errors.full_messages})
      else
        render(:action => :edit, :id => @bg_worker.id)
      end
      return
    end
    render(:json => "OK") and return if request.xhr?
    if params[:bg_worker].length == 1 # single edit
      redirect_to :action => :show, :id => @bg_worker.id
    else
      redirect_to :action => :index
    end
  end


  # Deletes an object or list of objects from the database.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2011-03-08 15:34:31 UTC
  # Status:: Validation Pending


  def destroy

    if params[:id].is_a?(Array)
      @success = BgWorker.destroy(params[:id])
    else
      @bg_worker = BgWorker.find_by_id(params[:id])
      @bg_worker.destroy unless @bg_worker.nil?
      @success = @bg_worker && @bg_worker.destroyed?
    end
    if @success
      flash[:notice] = _("%{model} %{name} successfully deleted.") % {:model => _("Bg Worker"), :name => @bg_worker.disp_name}
    else
      flash[:warning] = _("%{model} %{name} could not be deleted.") % {:model => _("Bg Worker"), :name => params[:name]}
    end
    if params[:format] != "json"
      if request.xhr?
        render :action => 'ajax_update', :layout => false
      else
        if params[:go_to].blank?
          redirect_to :action => :index
        else
          redirect_to(params[:go_to])
        end
      end
    else
      resp = {}
      if @success
        resp[:success] = true
      else
        resp[:success] = false
        resp[:error] = flash[:warning]
      end
      render :json => resp.to_json, :layout => false
    end
  end


  # Search and filter data.
  #
  # Author:: Sylvain Abélard
  # Version:: 44
  # Last Update:: 2010-06-15 18:38:22 UTC
  # Status:: Requires Tests


  def search

    @bg_worker = BgWorker.load_from_params(params[:bg_worker]["0"]) if params[:bg_worker]
    @bg_worker ||= BgWorker.new
    page	   = params[:page].to_i > 0 ? params[:page].to_i : 1
    per_page   = params[:per_page]
    per_page ||= BgWorker.count if params[:format] && %w(xml xls csv).include?(params[:format])
    per_page   = 50 if !per_page || per_page == 0

    # GET RESULTS FROM SMART_QUERY OR PARAMS

    if params[:bg_worker]
      my_p = params[:bg_worker]["0"].reject{|k, v|
        params["comp_#{k}"].blank? || (v.blank? && !params["comp_#{k}"].include?('NULL'))
      } if params[:bg_worker]["0"]
      @bg_workers = BgWorker.search(my_p, params.reject{|k,v| !k[/comp_/]}, :page => page, :per_page => per_page)
    elsif params[:query]
      @bg_workers = BgWorker.active_filter(ActiveSupport::JSON.decode(params[:query])).paginate(:page => page, :per_page => per_page)
    elsif params[:fts_query]
      l = params[:limit] ? params[:limit] : :all
      @bg_workers = BgWorker.find_with_ferret(params[:fts_query], :limit => l)
    elsif (params[:id] || params[:smart_query])
      if params[:id]
        @smart_query = SmartQuery.find_by_id(params[:id])
      else
        attr = params[:smart_query].first[1] if params[:smart_query].first
        attr[:criteria] = SmartQuery.clean_criteria(attr[:criteria])
        @smart_query = SmartQuery.new(attr)
      end
      @bg_workers = BgWorker.search(@smart_query, :page => page, :per_page => per_page)
    else
      opts = {:include => []}
      opts[:page]		  = page
      opts[:per_page]	  = per_page
      opts[:order]		  = @default_order
      opts[:order]		||= 'bg_workers.' +params[:sort_by] if !params[:sort_by].blank?
      opts[:conditions]	||= @default_filter
      opts[:joins] 		||= @joins_fields  || []
      @bg_workers = BgWorker.paginate(opts)
    end

    # RENDER SOMETHING

    if !@bg_workers.blank? && params[:format] # GET
      if params[:format] == 'xml'
        send_data(@bg_workers.to_xml,
        :filename => ('bg_workers.xml'),
        :disposition => 'attachment',
        :type => 'text/xml;charset=utf-8')
        return
      elsif params[:format] == 'xls'
        cols = []
        BgWorker::FIELDS.each{|k,v|
        cols << k if [:string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
        book = Spreadsheet::Workbook.new
        sheet = book.create_worksheet(:name => "bg_workers")
        sheet.row(0).concat(cols)
        @bg_workers.each_with_index do |row,i|
          sheet.row(i+1).replace(cols.map{|c|
            if [:ho_assoc, :bt_assoc].include?(BgWorker::FIELDS[c])
              v = row.send(c)
              v ? v.disp_name : ''
            else
              row.send(c)
            end
          })
        end
        fname = "bg_workers.xls"
        tmp = Tempfile.new(fname)
        book.write(tmp.path)
        tmp.close
        send_file(tmp.path, :filename => fname)
        return
      elsif params[:format] == 'csv'
        cols = BgWorker::FIELDS.inject([]) {|a,v|
        a << v[0] if [:ho_assoc, :bt_assoc, :string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp].include?(v[1]) ; a}
        @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';') }) do |csv|
          csv << cols
          for row in @bg_workers
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(BgWorker::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
        end
        @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
        conv = Iconv.new(@export_encoding, 'UTF-8')
        send_data(conv.iconv(@csv_string), :filename => "bg_workers.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        return
      end
    end
    if request.xhr? || request.post?
      render :partial => 'result_list' and return
    end
  end


  # Gives help about current module.
  #
  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2012-05-19 23:29:44 UTC
  # Status:: Validation Pending


  def help

    @user_actions = Access.where(:table_sid => "bg_workers", :action_sid => ["index", "new", "create", "show", "edit", "update", "destroy", "search", "help", "run_job_deprecated", "clear_locks", "update_task", "edit_task", "tasks", "destroy_task", "add_task", "new_task", "list", "start_worker", "processes", "kill_process", "ptest", "clear_queue", "running", "clear_log", "run_task", "kill_task"]).includes([:user_accesses, :profile_accesses]).reject{|a| @current_user.can_run?(a) }
    render(:layout => !request.xhr?)
  end


  # WARNING: DEPRECATED!
  #
  #--
  # DEPRECATED: this action would be removed
  #++
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 14:21:01 UTC
  # Status:: Validated


  def run_job_deprecated

    @job = Job.find_by_id(params[:id])
    res = @job.run if @job
    case res
    when true
      flash[:notice] = _("Job successfully run.")
    else
      flash[:error] = _("Job could not be run!")
    end
    redirect_to(:action => :list) and return
  end


  # Background Workers: clear process and tasks locks.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 12:43:57 UTC
  # Status:: Validation Pending


  def clear_locks

    res = BgWorker.clear_locks!
    if res
      flash[:notice] = _("Locks cleared.")
    else
      flash[:error] = _("Locks could not be cleared!")
    end
    redirect_to(:action => :list) and return
  end


  # Background Workers: updates the task's Rake file.
  #
  # Author:: Yann Azoury
  # Version:: 33
  # Last Update:: 2013-03-31 21:21:39 UTC
  # Status:: Could be optimized


  def update_task

    t = BgWorker.task(:name => params[:task][:name]) # new task so we update data
    if t[:name].blank?
      flash[:error] = _('Invalid name!')
      redirect_to :action => :back
    end
    t[:filename]	= Rails.root.join('lib', 'tasks', "bg_worker_#{t[:name]}.rake")
    id 		= params[:task][:id]
    t[:code]	= params[:task][:code]
    t[:namespace] 	= params[:task][:namespace]
    t[:desc]	= params[:task][:desc]
    t[:args]	= params[:task][:args].blank? ? nil :
    params[:task][:args].tr(' :', ',').split(',').compact.map{|d|
    ":#{d}".gsub('::', ':') unless d.blank?}.compact.join(', ')
    arg_string	= ", [#{t[:args]}]" unless t[:args].blank?
    t[:dependencies]= params[:task][:dependencies].blank? ? nil :
    params[:task][:dependencies].tr(' :', ',').split(',').compact.map{|d|
    ":#{d}".gsub('::', ':') unless d.blank?}.compact.join(', ')
    dep_string	= " => [#{t[:dependencies]}]" unless t[:dependencies].blank?
    t = BgWorker.task(t)
    file = %Q[# name: #{t[:name]}

      # args: #{t[:args]}
      # desc: #{t[:desc]}
      #{"# namespace: #{t[:namespace]}"  unless t[:namespace].blank?}
      # dependencies: #{t[:dependencies] unless t[:dependencies].blank?}
      #{"namespace :#{t[:namespace]} do" unless t[:namespace].blank?}

      desc %q[#{t[:desc]}]
      task :#{t[:name]} #{arg_string} #{dep_string} do |task #{', args' if arg_string}|

      #{t[:code]}

    end

    #{'end' unless t[:namespace].blank?}]

    if !id.blank? && id != t[:name]
      begin
        File.rm(Rails.root.join('lib', 'tasks', "#{id}.rake"))
      rescue
        flash[:error] = _('Task %{obj} could not be erased!') % {:obj => id}
      end
    end
    begin
      File.open(t[:filename], 'w+') {|f| f.write file}
      flash[:notice] = _('%{obj} successfully modified') % {:obj => _('Task')}
    rescue
      flash[:error] ||= ''
      flash[:error] << _('%{obj} could not be modified!') % {:obj => _('Task')}
    end
    redirect_to :action => :list
  end


  # Background Workers: opens task edition form.
  #
  # Author:: Sylvain Abélard
  # Version:: 37
  # Last Update:: 2010-06-16 12:44:35 UTC
  # Status:: Validation Pending


  def edit_task

    @task = task_info(params[:id], true, true)
    @task[:name].sub('bg_worker_', '')
  end


  # Background Workers: extract partial data from all available tasks.
  #
  # Author:: Sylvain Abélard
  # Version:: 28
  # Last Update:: 2010-06-16 12:45:21 UTC
  # Status:: Validation Pending


  def tasks

    task_files
    all_tasks = @task_files.map{|rt| task_info(rt.chomp('.rake'), true)}
    @tasks = WillPaginate::Collection.create(params[:tasks_page] || 1, params[:tasks_per_page] || 10, all_tasks.size) {|pager|
      pager.replace(all_tasks.sort{|x,y|
        ns_eq = (x[:namespace] <=> y[:namespace])
        ns_eq != 0 ? ns_eq : (x[:name] <=> y[:name])
      })
    }
    if request.xhr?
      render :partial => 'tasks' and return
    end
  end


  # Background Workers: destroys a task and its Rake file.
  #
  # Author:: Sylvain Abélard
  # Version:: 10
  # Last Update:: 2010-06-16 12:45:36 UTC
  # Status:: Validation Pending


  def destroy_task

    @task = task_info(params[:id])
    res = FileUtils.rm(@task[:filename])
    if res
      flash[:notice] = _("%{obj} destroyed.") % {:obj => 'Job'}
    else
      flash[:error] = _("%{obj} could not be destroyed!") % {:obj => 'Job'}
    end
    redirect_to(:action => :list) and return
  end


  # Background Workers: runs a task (add to job list).
  #
  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2011-01-22 17:16:39 UTC
  # Status:: Validation Pending


  def add_task

    task = task_info(params[:id], true)
    dup = BgWorker.first(:conditions => {:name => task[:fullname], :no_duplicate => true})
    res = BgWorker.run_task(task, 3) unless dup
    if res.nil?
      flash[:error] = _("Task could not be added to job list!")
    else
      flash[:notice] = _("Task added to job list.")
    end
    redirect_to(:action => :list) and return
  end


  # Background Workers: opens form for creating a task's Rake file.
  #
  # Author:: Sylvain Abélard
  # Version:: 8
  # Last Update:: 2010-06-16 12:46:14 UTC
  # Status:: Validation Pending


  def new_task

    @task = BgWorker.task
    render :action => :edit_task
  end


  # This gives the list of all records
  #
  # Author:: Sylvain Abélard
  # Version:: 10
  # Last Update:: 2010-06-14 19:15:01 UTC
  # Status:: Validation Pending


  def list

    @restricted_fields = []
    pagin_opts = {:include => []}
    pagin_opts[:page] = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page] = params[:per_page] ? params[:per_page].to_i : (@pres_mode == :list_zoom ? 20 : 50)
    pagin_opts[:order] = 'bg_workers.' +params[:sort_by] if !params[:sort_by].blank?
    @bg_workers = BgWorker.queued.paginate(pagin_opts)
    render(:xml => @bg_workers.to_xml(:dasherize => false, :only => [:id,:every,:from,:cron,:triggered_by,:no_duplicate,:name,:priority,:planned_at,:created_at,:started_at,:locked_at,:locked_by,:completed_at,:last_return_code,:attempts,:failed_at,:logs], :methods => [:start_cond_overview])) and return if params[:format] == 'xml'
    tasks
    running
    if !params[:group_by].blank?
      @bg_workers_groups = {}
      for r in @bg_workers
        crit = r.attributes[params[:group_by].to_s]
        @bg_workers_groups[crit] = [] if @bg_workers_groups[crit].nil?
        @bg_workers_groups[crit] += [r]
      end
    end
  end


  # Background Workers: starting worker.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 13:59:12 UTC
  # Status:: Requires Tests


  def start_worker

    res = BgWorker.start_worker
    if res.nil?
      flash[:error]  = _("Worker did not start!")
    else
      flash[:notice] = _("Worker running.")
    end
    redirect_to(:action => :list) and return
  end


  # Background Workers: listing worker processes with their status.
  #
  # Author:: Sylvain Abélard
  # Version:: 41
  # Last Update:: 2010-06-16 14:00:25 UTC
  # Status:: Validation Pending


  def processes

    require 'sys/proctable'
    statuses = {
      'I' => 'Idle',
      'R' => 'Runnable',
      'S' => 'Sleeping',
      'T' => 'Stopped',
      'U' => 'Wait',
      'Z' => 'Zombie'
    }
    ps = {}
    Sys::ProcTable.ps.each {|p|
      ps[p.pid]  ||= {:children => {}}
      ps[p.ppid] ||= {:children => {}}
      ps[p.pid][:name] = p.name
      ps[p.ppid][:children][p.pid] = p.name
      ps[p.pid][:data] = {
        :ppid => p.ppid,
        :pid => p.pid,
        :command => p.comm,
        :name => p.name,
        :user_id => p.uid,
        :status => statuses[p.state] || p.state
      }
    }
    rubies = {}
    ps.each{|k, v|

      #if v[:user_id] == Process.uid

      if (v[:name] == 'ruby' || v[:name] == 'rake') # and

        # v[:children].any? and #  # and

        rubies[k] = v[:data] if v[:data]
        v[:children].map{|i, d| rubies[i] = ps[i][:data] if ps[i] && ps[i][:data]}
      end
    }
    @processes = WillPaginate::Collection.create(params[:procs_page] || 1, params[:procs_per_page] || 5, rubies.size) {|pager|
      pager.replace(rubies.values.sort{|x, y|
        eq = (x[:ppid] <=> y[:ppid])
        eq != 0 ? eq : (x[:pid] <=> y[:pid])
      })
    }
    if request.xhr?
      render :partial => 'processes' and return
    end
  end


  # Background Workers: killing worker process.
  #
  #--
  # DEPRECATED: this action would be removed
  #++
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 14:00:36 UTC
  # Status:: Validated


  def kill_process

    pid = params[:id]
    res = Process.kill('KILL', pid)
    flash[:notice] = _("KILL signal sent to process %{pid}.") % {:pid => pid}
    redirect_to(:action => :list) and return
  end


  # Background Workers: experiment in spying process info.
  #
  #--
  # DEPRECATED: this action would be removed
  #++
  # Author:: Sylvain Abélard
  # Version:: 36
  # Last Update:: 2010-06-16 14:01:13 UTC
  # Status:: Validated


  def ptest

    require 'sys/proctable'
    ps = {}
    Sys::ProcTable.ps.each {|p|
      ps[p.pid] ||= {:children => {}}
      ps[p.ppid] ||= {:children => {}}
      ps[p.pid][:name] = p.name
      ps[p.ppid][:children][p.pid] = p.name
      ps[p.pid][:data] = [
        p.ppid,
        p.pid,
        p.comm,
        p.name,
        p.starttime,
        p.uid,
        p.session,
        p.state
      ]
    }
    rubies = {}
    ps.each{|k, v| if v[:name] == 'ruby' and v[:children].any?
      rubies[k] = v
      v[:children].map{|i, d| rubies[i] = ps[i]}
    end }
    render :text => rubies.map{|k,v| v[:data].inspect}.join('<br />')

    # ps.map{|p| p.inspect }.join('<br />')

  end


  # Background Workers: clearing tasks in the queue.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 14:01:24 UTC
  # Status:: Validation Pending


  def clear_queue

    res = BgWorker.delete_all('locked_at IS NULL')
    if res
      flash[:notice] = _("All %{obj} destroyed!") %{:obj => _('tasks')}
    else
      flash[:error] = _("All %{obj} could not be destroyed!") %{:obj => _('tasks')}
    end
    redirect_to :action => :list
  end


  # Background Workers: listing running processes.
  #
  # Author:: Sylvain Abélard
  # Version:: 9
  # Last Update:: 2010-06-16 14:01:46 UTC
  # Status:: Validation Pending


  def running

    @running = BgWorker.running.paginate(:page => params[:runs_page] || 1, :per_page => params[:runs_per_page] || 10)
    Thread.list.each {|t|
      @thread = t if t[:name] == 'background_worker'
    }
    if request.xhr?
      render :partial => 'running' and return
    end
  end


  # Clearing MaVeoC-specific log file.
  #
  # Author:: Yann Azoury
  # Version:: 7
  # Last Update:: 2012-04-22 01:54:23 UTC
  # Status:: Requires Tests


  def clear_log

    file = Rails.public_path.join('bg_worker.log')
    FileUtils.rm file
    flash[:warning] = "Cleared log file"
    redirect_to :action => :list
  end


  # Background Workers: running tasks.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 14:10:46 UTC
  # Status:: Validation Pending


  def run_task

    task	= BgWorker.find_by_id(params[:id])
    res	= BgWorker.run_task(task, 3, true) if task
    if res
      flash[:notice] = _("Job invoked.")
    else
      flash[:notice] = _("Error: Job not invoked!")
    end
    redirect_to(:action => :list) and return
  end


  # Background Workers: killing a task from the task list.
  #
  # Author:: Sylvain Abélard
  # Version:: 2
  # Last Update:: 2010-06-16 14:23:02 UTC
  # Status:: Requires Tests


  def kill_task

    job = BgWorker.find_by_id(params[:id])
    res = job.destroy
    if res
      flash[:notice] = _("%{obj} destroyed.") % {:obj => _('Job')}
    else
      flash[:error]  = _("%{obj} could not be destroyed!") % {:obj => _('Job')}
    end
    redirect_to(:action => :list) and return
  end
  protected


  # Background Workers: extracts data from the task's Rake file.
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-02-04 17:30:20 UTC
  # Status:: Could be optimized


  def task_info(name, details=nil, code=nil)
    task_files unless @task_files

    # FIND TASK FILE

    name = name.sub('bg_worker_', '')
    rake = "bg_worker_#{name}.rake"
    @filename = Rails.root.join('lib', 'tasks', rake)
    return BgWorker.task if name.blank? || !@task_files.find(name)

    # SET BASIC PROPERTIES

    task = BgWorker.task(:name => name, :filename => @filename)

    # IF LOOKING FOR ADVANCED PROPERTIES, MUST READ FILE

    if details || code
      begin
        @data = IO.readlines(@filename)
      rescue
        flash[:warning] = _("File invalid")
        return task
      end
    end

    # DETAILS ARE MERELY EXTRACTED FROM COMMENTS
    # ONE MAY EXTRACT INFORMATION DIRECTLY FROM THE SOURCE
    # USING CLEVER REGEXEN

    if details
      @data.grep(/. (name|args|desc|namespace|dependencies): (.*)/) do |line|
        ppt = Regexp.last_match(1)
        val = Regexp.last_match(2)
        if ppt == 'args' || ppt == 'dependencies'
          task[ppt.to_sym] = val.tr(' :', ',').split(',').map{|d| d unless d.blank? }.compact.join(', ')
        elsif ppt == 'namespace' && !val.blank?
          task[:namespace] = val
          task[:fullname]  = "#{task[:namespace]}:bg_worker_#{task[:name]}"
        else
          task[ppt.to_sym] = val
        end
      end
    end

    # CODE HAS TO BE EXTRACTED FROM IN-BETWEEN TASK DEFINITION
    # AND BLOCK END

    if code
      task_begin_code_regexp = /\A\s*task :#{task[:name]}.* do \|.*\|\Z/
      task_end_code_regexp   = /\A\s*end\Z/
      ends = []
      defs = []
      @data.each_with_index {|l, i|
        defs << i if l =~ task_begin_code_regexp
        ends << i if l =~ task_end_code_regexp
      }
      if defs.size == 1 && ends.size >= 1
        task_end = (task[:namespace] && ends[-2]) ? ends[-2] : ends[-1]
        task_def = defs[0] + 1
        task_end -= 1
        task[:code] = task_def < task_end ? @data[task_def..task_end].join.strip : ''
      else
        flash[:warning] = _("This file is not standardized")
        task[:code] = @data.join.strip
      end
    end
    return BgWorker.task(task)
  end


  # Background Workers: finding task files.
  #
  # Author:: Yann Azoury
  # Version:: 7
  # Last Update:: 2013-02-04 17:27:27 UTC
  # Status:: Validation Pending


  def task_files
    Dir.chdir(Rails.root.join('lib', 'tasks')) do |dir|
      @task_files = Dir["*.rake"]
    end
    @task_files = @task_files.reject{|task|
    task !~ /\Abg_worker_/}.map{|task|
      task.sub('bg_worker_', '')
    }
  end
  private


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1

    ckie = (RUBY_VERSION =~ /^1.8/) ? Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "") :  (cookies[:active_filters] || "").force_encoding(Encoding::ISO_8859_1).encode!(Encoding::UTF_8)
    if !ckie.blank?
      find_hash = BgWorker.named_scope_active_filter_method(ActiveSupport::JSON.decode(ckie))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      BgWorker.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_bg_workers_pres_mode"].to_sym unless cookies["#{APP_SID}_bg_workers_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_bg_workers_pres_mode"].to_sym unless params["#{APP_SID}_bg_workers_pres_mode"].blank?
  end

end
