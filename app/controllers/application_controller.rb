# -*- encoding : utf-8 -*-
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Mon Apr 01 10:59:39 +0200 2013
## It should be placed at 'app/controllers/application_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class ApplicationController < ActionController::Base

  clear_helpers

  # session :session_key => "_#{APP_SID}_session_id"

  if Object.const_defined?('FastGettext')
    include FastGettext::Translation
    FastGettext.text_domain ||= APP_SID
  else
    if RUBY_PLATFORM =~ /java/i
      init_gettext(APP_SID, :locale_path => Rails.root.join("locale").gsub(/\\/, '/'))
    else
      init_gettext(APP_SID)
    end
  end
  before_filter(:faveod_cookies_loading)
  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])
  before_filter(:check_accesses)
  before_filter(:set_locale)

  protected


  #--
  # DEPRECATED: this action would be removed
  #++
  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2009-08-19 14:03:13 UTC
  # Status:: Validated


  def user_setup
    logger.debug("USER_SETUP: #{session.inspect}")

    # User.current=() needs a thread-global reference to the session.

    Thread.current[:session] = session

    # User.current needs a thread-global reference to the session[:user_id]

    Thread.current[:user_id] = session[:user_id]

    # This is used by the logout action to discard the old HTTP authentiction.
    # Logout redirects to login and that generates a new authentication request. That request is the only input that can tell the browser to
    # stop sending the old authentication data with every request!

    if flash[:skip_user_setup] == true
      flash[:skip_user_setup] = false
      return true
    end
    login = password = nil
    r = request.env

    #  old_user = user = User.current
    # If the request contains an HTTP authentication, decode it.
    # Don't use it to authenticate the user yet.

    if (authdata =  r['X-HTTP_AUTHORIZATION']) or (authdata = r['HTTP_AUTHORIZATION'])
      authdata = authdata.to_s.split

      # FIX: At the moment we only support Basic authentication. It's
      # prone to sniffing. Change to Digest authentication.

      if not authdata[0] == 'Basic'
        login, password = Base64.decode64(authdata[1]).split(':')[0..1]
      end
    end

    # If the HTTP authentication is for a different user name, the user wants
    # to change logins. This can happen if an operation requires an
    # administrative login and the current user isn't the administrator but
    # also has an administrative login. It can also happen with command-line
    # tools like "wget" or web services clients that operate on behalf of
    # several users.
    #
    # Note that HTTP authentication (at least Basic) can be sent without
    # the server first asking for it, and that's valid according to the
    # HTTP specification. So, I can get here without having asked the browser
    # to put up a login panel.
    #
    # Allow re-log-in if the user name and password authenticate properly.
    #
    #if login and (user.blank? or login != user.login)
    #  user = User.sign_on(login, password)
    #end
    # Sign on the user via a web form.

    if request.post? && (p = params[:user])
      @current_user = User.sign_on(p[:login], p[:password]) if p[:login] && p[:password]
      flash[:login_succeeded] = true if @current_user
    end

    # Sign on the user via a security token.
    #if params[:id] and params[:token]
    #  user = User.sign_on_by_token(params[:id], params['token'])
    #end
    #if @current_user != old_user && !@current_user.nil?
    #  flash[:login_succeeded] = true
    #end

  end


  # This action is called for every request so we can check authorizations and access.
  # You can change the process here with extra caution.
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-04-01 10:59:43 UTC
  # Status:: Could be optimized


  def check_accesses
    path_params = request.path_parameters() #path_params[:action] path_params[:controller]
    if request.post? && (p = params[:user]) && path_params[:controller] == 'users' && path_params[:action] == 'login'
      self.current_user = User.sign_on(p[:login], p[:password]) if p[:login] && p[:password]
      flash[:login_succeeded] = true if self.current_user
    end
    logger.debug("[CHECK ACCESSES] Current User: #{self.current_user.inspect}  #{path_params.inspect}")
    session[:context] ||= {}

    # session[:context][:user_id] = self.current_user.id if self.current_user # context example
    # disable multiple session per user
    #if !@current_user.nil? && session.session_id != @current_user.last_session_id
    #  @current_user = User.current = nil
    #  reset_session
    #  flash[:notice]='This session is no longer valid...<br/>Please login to continue'
    #  session[:return_to]=request.fullpath if (path_params[:controller] != 'users' && path_params[:action] != 'logout')
    #  redirect_to :controller => 'users', :action => 'login'
    #  return false
    #end
    # Grants everything to Faveod Users

    return true if !self.current_user.nil? && self.current_user.active? && self.current_user.has_profile?("Faveod User")
    return true if Rails.env == 'test' && params[:user_profile] == "Faveod User"

    # else get accesses

    action = Access.actions.where(:table_sid => path_params[:controller], :action_sid => path_params[:action]).first
    if action.nil?
      render :file => Rails.root.join("public", "404.html"), :layout => false, :status => "404 File Not Found"
      return false
    end

    # Check if loggin is required

    if self.current_user.new_record?

      #    not_logged = Profile.find_by_name('Not Logged')

      unless self.current_user.can_run?(action)
        flash[:notice] = _("Please login to continue.")
        session[:return_to] = request.fullpath if (path_params[:controller] != 'users' &&
        !(['login','logout','home'].include?(path_params[:action])))
        redirect_to :controller => :users, :action => :login
        return false
      else
        return true
      end
    end

    # if granted is not allowed, redirect to the access denied

    if !self.current_user.can_run?(action)
      render :file => File.join(Rails.public_path, "401.html"), :layout => true, :status => "401 Access Denied"
      return false
    end
    return true
  end


  # Store the given user id in the session.
  #
  # Author:: Yann Azoury
  # Version:: 3
  # Last Update:: 2013-02-10 18:13:17 UTC
  # Status:: Validation Pending


  def current_user=(new_user)
    session[:user_id] = new_user ? new_user.id : nil
    @current_user = new_user || false
  end


  # Accesses the current user from the session.
  # Future calls avoid the database because nil is not equal to false.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2010-02-02 15:18:32 UTC
  # Status:: Validation Pending


  def current_user
    return @current_user unless @current_user.nil? || @current_user == false
    if session[:user_id]
      self.current_user = User.find_by_id(session[:user_id])
    elsif cookies[:auth_token]
      user = User.find_by_remember_token(cookies[:auth_token])
      if user && user.remember_token?
        cookies[:auth_token] = { :value => user.remember_token, :expires => user.remember_token_expires_at }
        self.current_user = user
      end
    else # Basic HTTP Login (useful for Web Services)
      authenticate_with_http_basic do |username, password|
        self.current_user = User.sign_on(username, password)
      end
    end

    # no authenticated user, new anonymous user

    self.current_user = User.new(:login => _('Anonymous'), :last_name => _('Anonymous'), :active => true) if !@current_user
    return @current_user
  end


  # Catch uncatched exceptions
  #
  # Author:: Sylvain Ab√©lard
  # Version:: 5
  # Last Update:: 2010-05-19 14:21:28 UTC
  # Status:: Requires Tests


  def log_exception(exc, &block)
    if SystemSetting[:store_uncatched_exceptions]
      deliverer = block || self.class.read_inheritable_attribute(:exception_data)
      data = case deliverer
      when nil    then {}
      when Symbol then send(deliverer)
      when Proc   then deliverer.call(self)
      end
      saved = UncatchedException.create_from_exception(self, exc, data)
      UncatchedExceptionMailer.deliver_uncatched_exception(exc, current_user, params, saved)
      flash[:warning] = _("An error occured during last action, you have been redirected.")
      redirect_to("/") and return if current_user
    else
      logger.debug("Exception catched but not stored:\n#{exc.inspect}")
    end
  end


  # Overrides default method.
  #
  # Author:: Yann Azoury
  # Version:: 3
  # Last Update:: 2010-05-03 11:27:53 UTC
  # Status:: Validation Pending


  def rescue_action_locally(exc)
    if SystemSetting[:store_uncatched_exceptions]
      log_exception(exc)
    else
      super
    end
  end


  # Overrides default action.
  #
  # Author:: Yann Azoury
  # Version:: 3
  # Last Update:: 2010-05-03 11:28:00 UTC
  # Status:: Validation Pending


  def rescue_action_in_public(exc)
    if SystemSetting[:store_uncatched_exceptions]
      log_exception(exc)
    else
      super
    end
  end


  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2013-02-23 21:08:18 UTC
  # Status:: Validation Pending


  def set_locale
    if Object.const_defined?('FastGettext')
      FastGettext.available_locales = GSS[:field_languages] ? GSS[:field_languages].split(' ') : %w(en fr ar ko)
      FastGettext.text_domain = APP_SID
      session[:locale] = I18n.locale = FastGettext.set_locale(params[:locale] || params[:lang] || cookies[:lang] || session[:locale] || request.env['HTTP_ACCEPT_LANGUAGE'] || 'en')
    end
  end
  private


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1
    if !cookies[:active_filters].blank?
      find_hash = RootMaveoc.named_scope_active_filter_method(ActiveSupport::JSON.decode(Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "{}")))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      RootMaveoc.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_root_maveocs_pres_mode"].to_sym unless cookies["#{APP_SID}_root_maveocs_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_root_maveocs_pres_mode"].to_sym unless params["#{APP_SID}_root_maveocs_pres_mode"].blank?
  end

end
