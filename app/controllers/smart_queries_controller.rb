# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:38:01 +0100 2013
## It should be placed at 'app/controllers/smart_queries_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class SmartQueriesController < ApplicationController
  layout 'application_jquery_horizontal'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :create) do
    request.request_method_symbol == :post
  end
  before_filter(:only => :update) do
    request.request_method_symbol == :put
  end

  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])


  # Index of all <%= model.sid %>.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-05-20 16:26:24 UTC
  # Status:: Validation Pending


  def index

    list
    unless(%w(json xml).include?(params[:format]))
      render(:action => :list)
    end
  end


  # This gives the list of all records
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-01-29 17:02:44 UTC
  # Status:: Validation Pending


  def list

    @restricted_fields = []
    pagin_opts = {:include => []}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:smart_queries_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'smart_queries.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @smart_queries = SmartQuery.paginate(pagin_opts)
    render(:xml => @smart_queries.to_xml(:dasherize => false, :only => [:id,:name,:table_sid,:joining_criteria,:criteria])) and return if params[:format] == 'xml'
    render(:json => @smart_queries) and return if params[:format] == 'json'
    render(:pdf => @smart_queries, :action => :list) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["name", "table_sid"].include?(params[:group_by])
      @smart_queries_groups = @smart_queries.inject({}) { |acc,elt|
        crit = nil
        if [].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # Inserts the record in the database.
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2013-10-31 16:38:41 UTC
  # Status:: Validation Pending


  def create

    redirect_to(:action => :index) and return unless request.post?
    redirect_to(:action => :index) and return if params[:smart_query].blank? || !params[:smart_query].is_a?(Hash)
    @smart_query_attributes = params[:smart_query] ? params[:smart_query]['0'].clone : {}

    @smart_query = SmartQuery.load_from_params(@smart_query_attributes)
    @smart_query.criteria = set_criteria_for_create_7
    if @smart_query.errors.empty? && @smart_query.save
      flash[:notice] = _("%{page} was successfully created.") % {:page => _("Smart Query")}
      if request.xhr? # && params[:format] == 'json'
        render(:json => {:id => @smart_query.id}.merge(@smart_query.attributes).to_json)
        return
      end
    else
      if request.xhr? # && params[:format] == 'json'
        render(:json => ({:errors => @smart_query.errors.full_messages}.merge(@smart_query.attributes)).to_json)
      else
        render(:action => :new)
      end
      return
    end
    if params[:go_to].blank?
      redirect_to :action => (params[:commit_and_new] ? :new : :index)
    else
      redirect_to(params[:go_to])
    end
  end


  # Display the record.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2012-03-26 04:12:53 UTC
  # Status:: Validation Pending


  def show

    @smart_query_attributes = params[:smart_query] ? params[:smart_query][params[:id]].clone : {}
    @smart_query_attributes.merge!(:id => params[:id]) if @smart_query_attributes

    @smart_query = SmartQuery.load_from_params(@smart_query_attributes)
    if @smart_query.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'smart_query', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    respond_to do |format|
      format.html {
      render :layout => !request.xhr? }
      format.pdf {
      render :layout => false }
      format.xml {
      render :xml => @smart_query.to_xml }
      format.json {
      render :json => @smart_query.to_json }
    end
  end


  # Updates the current row in database from the sent form.
  #
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2012-12-13 11:53:56 UTC
  # Status:: Validation Pending


  def update

    redirect_to(:action => :index) and return unless request.put?
    redirect_to(:action => :index) and return if params[:smart_query].blank? || !params[:smart_query].is_a?(Hash)
    @smart_query_attributes = params[:smart_query] ? params[:smart_query][params[:id]].clone : {}
    @smart_query_attributes.merge!(:id => params[:id]) if @smart_query_attributes

    @smart_query = SmartQuery.load_from_params(@smart_query_attributes)
    if @smart_query.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'smart_query', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end
    @smart_query.criteria = set_criteria_for_update_7
    if @smart_query.save
      flash[:notice] = _("%{page} was successfully updated.") % {:page => _("Smart Query")}
    else
      if request.xhr?
        render(:json => {:errors =>
        @smart_query.errors.full_messages})
      else
        render(:action => :edit, :id => @smart_query.id)
      end
      return
    end
    render(:json => "OK") and return if request.xhr?
    if params[:smart_query].length == 1 # single edit
      redirect_to :action => :show, :id => @smart_query.id
    else
      redirect_to :action => :index
    end
  end


  # Deletes an object or list of objects from the database.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2011-03-08 15:34:31 UTC
  # Status:: Validation Pending


  def destroy

    if params[:id].is_a?(Array)
      @success = SmartQuery.destroy(params[:id])
    else
      @smart_query = SmartQuery.find_by_id(params[:id])
      @smart_query.destroy unless @smart_query.nil?
      @success = @smart_query && @smart_query.destroyed?
    end
    if @success
      flash[:notice] = _("%{model} %{name} successfully deleted.") % {:model => _("Smart Query"), :name => @smart_query.disp_name}
    else
      flash[:warning] = _("%{model} %{name} could not be deleted.") % {:model => _("Smart Query"), :name => params[:name]}
    end
    if params[:format] != "json"
      if request.xhr?
        render :action => 'ajax_update', :layout => false
      else
        if params[:go_to].blank?
          redirect_to :action => :index
        else
          redirect_to(params[:go_to])
        end
      end
    else
      resp = {}
      if @success
        resp[:success] = true
      else
        resp[:success] = false
        resp[:error] = flash[:warning]
      end
      render :json => resp.to_json, :layout => false
    end
  end


  # Search and filter data.
  #
  # Author:: Sylvain Abélard
  # Version:: 44
  # Last Update:: 2010-06-15 18:38:22 UTC
  # Status:: Requires Tests


  def search

    @smart_query = SmartQuery.load_from_params(params[:smart_query]["0"]) if params[:smart_query]
    @smart_query ||= SmartQuery.new
    page	   = params[:page].to_i > 0 ? params[:page].to_i : 1
    per_page   = params[:per_page]
    per_page ||= SmartQuery.count if params[:format] && %w(xml xls csv).include?(params[:format])
    per_page   = 50 if !per_page || per_page == 0

    # GET RESULTS FROM SMART_QUERY OR PARAMS

    if params[:smart_query]
      my_p = params[:smart_query]["0"].reject{|k, v|
        params["comp_#{k}"].blank? || (v.blank? && !params["comp_#{k}"].include?('NULL'))
      } if params[:smart_query]["0"]
      @smart_queries = SmartQuery.search(my_p, params.reject{|k,v| !k[/comp_/]}, :page => page, :per_page => per_page)
    elsif params[:query]
      @smart_queries = SmartQuery.active_filter(ActiveSupport::JSON.decode(params[:query])).paginate(:page => page, :per_page => per_page)
    elsif params[:fts_query]
      l = params[:limit] ? params[:limit] : :all
      @smart_queries = SmartQuery.find_with_ferret(params[:fts_query], :limit => l)
    elsif (params[:id] || params[:smart_query])
      if params[:id]
        @smart_query = SmartQuery.find_by_id(params[:id])
      else
        attr = params[:smart_query].first[1] if params[:smart_query].first
        attr[:criteria] = SmartQuery.clean_criteria(attr[:criteria])
        @smart_query = SmartQuery.new(attr)
      end
      @smart_queries = SmartQuery.search(@smart_query, :page => page, :per_page => per_page)
    else
      opts = {:include => []}
      opts[:page]		  = page
      opts[:per_page]	  = per_page
      opts[:order]		  = @default_order
      opts[:order]		||= 'smart_queries.' +params[:sort_by] if !params[:sort_by].blank?
      opts[:conditions]	||= @default_filter
      opts[:joins] 		||= @joins_fields  || []
      @smart_queries = SmartQuery.paginate(opts)
    end

    # RENDER SOMETHING

    if !@smart_queries.blank? && params[:format] # GET
      if params[:format] == 'xml'
        send_data(@smart_queries.to_xml,
        :filename => ('smart_queries.xml'),
        :disposition => 'attachment',
        :type => 'text/xml;charset=utf-8')
        return
      elsif params[:format] == 'xls'
        cols = []
        SmartQuery::FIELDS.each{|k,v|
        cols << k if [:string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
        book = Spreadsheet::Workbook.new
        sheet = book.create_worksheet(:name => "smart_queries")
        sheet.row(0).concat(cols)
        @smart_queries.each_with_index do |row,i|
          sheet.row(i+1).replace(cols.map{|c|
            if [:ho_assoc, :bt_assoc].include?(SmartQuery::FIELDS[c])
              v = row.send(c)
              v ? v.disp_name : ''
            else
              row.send(c)
            end
          })
        end
        fname = "smart_queries.xls"
        tmp = Tempfile.new(fname)
        book.write(tmp.path)
        tmp.close
        send_file(tmp.path, :filename => fname)
        return
      elsif params[:format] == 'csv'
        cols = SmartQuery::FIELDS.inject([]) {|a,v|
        a << v[0] if [:ho_assoc, :bt_assoc, :string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp].include?(v[1]) ; a}
        @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';') }) do |csv|
          csv << cols
          for row in @smart_queries
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(SmartQuery::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
        end
        @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
        conv = Iconv.new(@export_encoding, 'UTF-8')
        send_data(conv.iconv(@csv_string), :filename => "smart_queries.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        return
      end
    end
    if request.xhr? || request.post?
      render :partial => 'result_list' and return
    end
  end


  # Allows download of all or current record in many formats.
  #
  # Author:: Yann Azoury
  # Version:: 46
  # Last Update:: 2013-02-11 07:45:35 UTC
  # Status:: Validation Pending


  def download

    @restricted_fields = []
    @no_menubar	= true
    @no_links	= true
    @no_filterbar	= true
    @no_row_links	= true
    pagin_opts		  = {:include => []}
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= "smart_queries.#{params[:sort_by]}" if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter
    pagin_opts[:joins]	||= @joins_fields || []

    # pagin_opts[:select]	||= "`smart_queries`.`name`,`smart_queries`.`table_sid`,`smart_queries`.`joining_criteria`,`smart_queries`.`criteria`" unless params[:format] == 'html'

    if params[:id] && params[:id].to_i > 0
      @smart_query = SmartQuery.find_by_id(params[:id], pagin_opts)
      if !@smart_query
        flash[:warning] = _("Error: %{obj} not found!") % {:obj => _(%q[SmartQuery])}
        begin
          redirect_to :back
        rescue
          redirect_to :action => :list
        end
        return
      end
      f_name = @smart_query.disp_name
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/smart_queries/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/smart_queries/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/smart_queries/show.html.erb', :format => :html, :id => @smart_query.id, :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "#{@smart_query.disp_name}.pdf") unless params[:debug_pdf] || pdf.blank?

          # send_data(render_to_string(:format => :html, :layout => false, :action => :show, :id => @smart_query.id), :filename => "#{f_name}.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

          return
        }
        format.xml {
        send_data(@smart_query.to_xml, :filename => "#{f_name}.xml", :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.json {
        send_data(@smart_query.to_json, :filename => "#{f_name}.json", :disposition => 'attachment', :type => 'text/json;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "smart_queries")
          sheet.row(0).concat(["Name", "Table", "Joining Criteria", "Criteria"])
          sheet.row(1).replace([@smart_query.name, @smart_query.table_sid, @smart_query.joining_criteria, @smart_query.criteria])
          fname = "smart_queries.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv { row = @smart_query
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            SmartQuery::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [].include?(c) }
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(SmartQuery::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "#{f_name}.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
          return
        }
      end
    else
      pagin_opts[:page] = 1
      pagin_opts[:per_page] = SmartQuery.count+1
      @smart_queries = SmartQuery.paginate(pagin_opts)
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/smart_queries/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "smart_queries.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/smart_queries/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "smart_queries.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/smart_queries/list.html.erb', :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "smart_queries.pdf") unless params[:debug_pdf] || pdf.blank?

          #      send_data(render_to_string(:layout => false, :action => :list), :filename => "smart_queries.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

        }
        format.xml {
        send_data(@smart_queries.to_xml, :filename => ('smart_queries.xml'), :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "smart_queries")
          sheet.row(0).concat(["Name", "Table", "Joining Criteria", "Criteria"])
          @smart_queries.each_with_index do |row,i|
            sheet.row(i+1).replace([row.name, row.table_sid, row.joining_criteria, row.criteria])
          end
          fname = "smart_queries.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv {
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            SmartQuery::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [].include?(c) }
            csv << cols.map{|c| _(c.titleize)}
            @smart_queries.map{|row|
              csv << cols.map {|c|
                if [:ho_assoc, :bt_assoc].include?(SmartQuery::FIELDS[c])
                  v = row.send(c) ; v ? v.disp_name : nil
                else
                  row.send(c)
                end
              }
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "smart_queries.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        }
      end
    end
  end


  # Exports RSS, XML and ATOM feeds.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 12:11:11 UTC
  # Status:: Validation Pending


  def feed

    @smart_queries = SmartQuery.all(:limit => 50)
    respond_to do |format|
      format.rss {render :template => 'smart_queries/rss', :layout => false}
      format.xml {render :template => 'smart_queries/rss', :layout => false}
      format.html {render :template => 'smart_queries/rss', :layout => false}
      format.atom {render :template => 'smart_queries/atom', :layout => false}
    end
  end


  # Gives help about current module.
  #
  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2012-05-19 23:29:44 UTC
  # Status:: Validation Pending


  def help

    @user_actions = Access.where(:table_sid => "smart_queries", :action_sid => ["index", "list", "create", "show", "update", "destroy", "search", "download", "feed", "help", "adv_search", "db_table", "new", "edit", "change_table", "test_query", "global_search"]).includes([:user_accesses, :profile_accesses]).reject{|a| @current_user.can_run?(a) }
    render(:layout => !request.xhr?)
  end


  # Make complex queries.
  #
  # Author:: Yann Azoury
  # Version:: 7
  # Last Update:: 2010-05-27 12:12:45 UTC
  # Status:: Validation Pending


  def adv_search

    redirect_to :action => :search
  end


  # Many maintenance and technical tasks.
  #
  # Author:: Yann Azoury
  # Version:: 22
  # Last Update:: 2011-08-09 11:14:57 UTC
  # Status:: Requires Tests


  def db_table

    @record_nb = SmartQuery.count
    cnx = SmartQuery.connection
    case cnx.adapter_name
    when /mysql/i
      @table_infos = cnx.execute(%Q[SHOW TABLE STATUS WHERE name = 'smart_queries';]).fetch_hash.reject{|k,v| v.blank? }
      @table_size = @table_infos['Data_length'].to_i + @table_infos['Index_length'].to_i
      @db_size = cnx.execute(%Q[SELECT sum(data_length + index_length) 'size' FROM information_schema.TABLES WHERE table_schema = '#{cnx.current_database}';]).fetch_row.first.to_i
      @table_infos['Database_size'] = @db_size
      @table_infos['Size in Database'] = "%.2f %" % (@table_size * 100.0 / @db_size)
    when /postgres/i
      @table_infos = cnx.execute(%Q[SELECT * from pg_class WHERE name = 'smart_queries';]).fetch_hash.reject{|k,v| v.blank? }
      @table_size = cnx.execute(%Q[SELECT pg_total_relation_size('smart_queries');]).fetch_row.first.to_i
      @db_size = cnx.execute(%Q[SELECT pg_database_size('#{cnx.current_database}');]).fetch_row.first.to_i
      @table_infos['Database_size'] = @db_size
      @table_infos['Size in Database'] = "%.2f %" % (@table_size * 100.0 / @db_size)
    when /sqlserver/i
    when /oracle/i
    end unless params[:command]
    if request.post? || request.delete?
      case params[:command]
      when 'purge_with_triggers'
        SmartQuery.destroy_all
      when 'purge_without_triggers'
        SmartQuery.delete_all
      when 'generate_random_data'
        nb = params[:size].to_i
        ok = []
        nb.times do |i|
          ok << SmartQuery.create(:name => Forgery(:name).full_name, :table_sid => Forgery(:name).full_name, :joining_criteria => SmartQuery::JOINING_CRITERIA.random)
        end
        flash[:notice] = "#{ok.reject{|e| e.new_record? }.length} Created Successfully"

        #TODO

      when 'foreign_keys'

        #TODO

      when 'validations'
        val_fail = 0
        SmartQuery.all.each do |elt|
          val_fail += 1 if !elt.valid?
        end
        msg = val_fail > 0 ? :warning : :notice
        flash[msg] = _("Errors found: %{n}") % {:n => val_fail}
      when 'optimize'
        case cnx.adapter_name
        when /mysql/i
          cnx.execute(%Q[OPTIMIZE TABLE `smart_queries`;])
        end
      end
      redirect_to(:action => :db_table)
    end
  end


  # Adding a saved report.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:41:17 UTC
  # Status:: Validation Pending


  def new

    @smart_query_attributes = params[:smart_query] ? params[:smart_query]['0'].clone : {}

    @smart_query = SmartQuery.load_from_params(@smart_query_attributes)

    smart_query_opts
    render :layout => !request.xhr?
  end


  # Load the data to fill the edit form.
  #
  # Author:: Pierre Carrio
  # Version:: 9
  # Last Update:: 2013-03-23 17:38:33 UTC
  # Status:: Validation Pending


  def edit

    @smart_query_attributes = params[:smart_query] ? params[:smart_query][params[:id]].clone : {}
    @smart_query_attributes.merge!(:id => params[:id]) if @smart_query_attributes

    @smart_query = SmartQuery.load_from_params(@smart_query_attributes)
    if @smart_query.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'smart_query', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    smart_query_opts
    logger.debug " @smart_query.inspect #{@smart_query.inspect} "
    render :layout => !request.xhr?
  end


  # Changing queried model.
  #
  # Author:: Pierre Carrio
  # Version:: 14
  # Last Update:: 2013-03-21 11:45:24 UTC
  # Status:: Validation Pending


  def change_table

    @smart_query = SmartQuery.find_by_id(params[:id])
    @smart_query ||= SmartQuery.new(params[:smart_query][params[:id] || '0'])
    smart_query_opts
    render :partial => 'field_conditions'
  end


  # WARNING: DEPRECATED!
  # Please use "search" action instead.
  #
  #--
  # DEPRECATED: this action would be removed
  #++
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2010-06-16 14:21:22 UTC
  # Status:: Validated


  def test_query

    @smart_query = SmartQuery.find_by_id(params[:id])
    @smart_query ||= SmartQuery.new(params[:smart_query][params[:id]])
    smart_query_opts
    pg_opts = {:page => params[:page] || 1}
    @results = @model.paginate(pg_opts.merge(@smart_query.to_ar_opts))
    render :update do |page|
      page['test_query'].replace_html(:partial => "#{@table}/result_list",
      :locals => {@table.to_sym => @results})
    end
  end


  # Author:: Sylvain Abélard
  # Version:: 38
  # Last Update:: 2013-03-20 16:14:27 UTC
  # Status:: Requires Tests


  def global_search


    # matching type: full, starts with, ends with, contains
    # queries scope: per model, per field, FTS...

    @timestamp	= (params[:timestamp] || Time.now).to_i
    @criteria	= params[:value].blank? ? params[:criteria] : params[:value]
    @msg		= nil
    @res		= {}
    @total		= 0
    bfor = %w(ends_with contains).include?(params[:match]) ? '' : '%'
    aftr = %w(starts_with contains).include?(params[:match]) ? '' : '%'
    if @criteria.to_s.size < 2
      @msg = _('Sorry, query too short for meaningful results.')
    else

      @res["SystemSetting"] ||= {:ids => []}
      @res["SystemSetting"][:name] ||= []
      @res["SystemSetting"][:name] +=
      SystemSetting.all(:conditions => ["LOWER(`name`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["SystemSetting"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{SystemSetting}),
          :field	=> _(%Q{Name}),
          :tags	=> "system_settings name",
          :link	=> url_for({:controller => :system_settings, :action => :show, :id => x.id})
        }
      }
      ret = @res["SystemSetting"][:name].size
      @res["SystemSetting"].delete(:name) if ret == 0

      #  @res.delete("SystemSetting") if 0 == (mod +
      #    (@res["SystemSetting"][:fts] ? @res["SystemSetting"][:fts].values.size : 0))
      # @res["SystemSetting"].values.flatten.size == 0

      @res["User"] ||= {:ids => []}
      @res["User"][:login] ||= []
      @res["User"][:login] +=
      User.all(:conditions => ["LOWER(`login`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["User"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{User}),
          :field	=> _(%Q{Login}),
          :tags	=> "users login",
          :link	=> url_for({:controller => :users, :action => :show, :id => x.id})
        }
      }
      ret = @res["User"][:login].size
      @res["User"].delete(:login) if ret == 0
      @res["User"][:telephone] ||= []
      @res["User"][:telephone] +=
      User.all(:conditions => ["LOWER(`telephone`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["User"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{User}),
          :field	=> _(%Q{Telephone}),
          :tags	=> "users telephone",
          :link	=> url_for({:controller => :users, :action => :show, :id => x.id})
        }
      }
      ret = @res["User"][:telephone].size
      @res["User"].delete(:telephone) if ret == 0

      #  @res.delete("User") if 0 == (mod +
      #    (@res["User"][:fts] ? @res["User"][:fts].values.size : 0))
      # @res["User"].values.flatten.size == 0

      @res["SavedReport"] ||= {:ids => []}
      @res["SavedReport"][:name] ||= []
      @res["SavedReport"][:name] +=
      SavedReport.all(:conditions => ["LOWER(`name`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["SavedReport"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{SavedReport}),
          :field	=> _(%Q{Name}),
          :tags	=> "saved_reports name",
          :link	=> url_for({:controller => :saved_reports, :action => :show, :id => x.id})
        }
      }
      ret = @res["SavedReport"][:name].size
      @res["SavedReport"].delete(:name) if ret == 0

      #  @res.delete("SavedReport") if 0 == (mod +
      #    (@res["SavedReport"][:fts] ? @res["SavedReport"][:fts].values.size : 0))
      # @res["SavedReport"].values.flatten.size == 0

      @res["BgWorker"] ||= {:ids => []}
      @res["BgWorker"][:locked_by] ||= []
      @res["BgWorker"][:locked_by] +=
      BgWorker.all(:conditions => ["LOWER(`locked_by`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["BgWorker"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{BgWorker}),
          :field	=> _(%Q{Locked By}),
          :tags	=> "bg_workers locked_by",
          :link	=> url_for({:controller => :bg_workers, :action => :show, :id => x.id})
        }
      }
      ret = @res["BgWorker"][:locked_by].size
      @res["BgWorker"].delete(:locked_by) if ret == 0
      @res["BgWorker"][:cron] ||= []
      @res["BgWorker"][:cron] +=
      BgWorker.all(:conditions => ["LOWER(`cron`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["BgWorker"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{BgWorker}),
          :field	=> _(%Q{Cron}),
          :tags	=> "bg_workers cron",
          :link	=> url_for({:controller => :bg_workers, :action => :show, :id => x.id})
        }
      }
      ret = @res["BgWorker"][:cron].size
      @res["BgWorker"].delete(:cron) if ret == 0
      @res["BgWorker"][:logs] ||= []
      @res["BgWorker"][:logs] +=
      BgWorker.all(:conditions => ["LOWER(`logs`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["BgWorker"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{BgWorker}),
          :field	=> _(%Q{Logs}),
          :tags	=> "bg_workers logs",
          :link	=> url_for({:controller => :bg_workers, :action => :show, :id => x.id})
        }
      }
      ret = @res["BgWorker"][:logs].size
      @res["BgWorker"].delete(:logs) if ret == 0
      @res["BgWorker"][:start_cond_overview] ||= []
      @res["BgWorker"][:start_cond_overview] +=
      BgWorker.all(:conditions => ["LOWER(`start_cond_overview`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["BgWorker"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{BgWorker}),
          :field	=> _(%Q{Start}),
          :tags	=> "bg_workers start_cond_overview",
          :link	=> url_for({:controller => :bg_workers, :action => :show, :id => x.id})
        }
      }
      ret = @res["BgWorker"][:start_cond_overview].size
      @res["BgWorker"].delete(:start_cond_overview) if ret == 0

      #  @res.delete("BgWorker") if 0 == (mod +
      #    (@res["BgWorker"][:fts] ? @res["BgWorker"][:fts].values.size : 0))
      # @res["BgWorker"].values.flatten.size == 0

      @res["FileImport"] ||= {:ids => []}
      @res["FileImport"][:log] ||= []
      @res["FileImport"][:log] +=
      FileImport.all(:conditions => ["LOWER(`log`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["FileImport"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{FileImport}),
          :field	=> _(%Q{Log}),
          :tags	=> "file_imports log",
          :link	=> url_for({:controller => :file_imports, :action => :show, :id => x.id})
        }
      }
      ret = @res["FileImport"][:log].size
      @res["FileImport"].delete(:log) if ret == 0

      #  @res.delete("FileImport") if 0 == (mod +
      #    (@res["FileImport"][:fts] ? @res["FileImport"][:fts].values.size : 0))
      # @res["FileImport"].values.flatten.size == 0

      @res["DevFeedback"] ||= {:ids => []}
      @res["DevFeedback"][:title] ||= []
      @res["DevFeedback"][:title] +=
      DevFeedback.all(:conditions => ["LOWER(`title`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["DevFeedback"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{DevFeedback}),
          :field	=> _(%Q{Title}),
          :tags	=> "dev_feedbacks title",
          :link	=> url_for({:controller => :dev_feedbacks, :action => :show, :id => x.id})
        }
      }
      ret = @res["DevFeedback"][:title].size
      @res["DevFeedback"].delete(:title) if ret == 0
      @res["DevFeedback"][:text] ||= []
      @res["DevFeedback"][:text] +=
      DevFeedback.all(:conditions => ["LOWER(`text`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["DevFeedback"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{DevFeedback}),
          :field	=> _(%Q{Text}),
          :tags	=> "dev_feedbacks text",
          :link	=> url_for({:controller => :dev_feedbacks, :action => :show, :id => x.id})
        }
      }
      ret = @res["DevFeedback"][:text].size
      @res["DevFeedback"].delete(:text) if ret == 0
      @res["DevFeedback"][:url] ||= []
      @res["DevFeedback"][:url] +=
      DevFeedback.all(:conditions => ["LOWER(`url`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["DevFeedback"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{DevFeedback}),
          :field	=> _(%Q{URL}),
          :tags	=> "dev_feedbacks url",
          :link	=> url_for({:controller => :dev_feedbacks, :action => :show, :id => x.id})
        }
      }
      ret = @res["DevFeedback"][:url].size
      @res["DevFeedback"].delete(:url) if ret == 0
      @res["DevFeedback"][:controller] ||= []
      @res["DevFeedback"][:controller] +=
      DevFeedback.all(:conditions => ["LOWER(`controller`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["DevFeedback"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{DevFeedback}),
          :field	=> _(%Q{Controller}),
          :tags	=> "dev_feedbacks controller",
          :link	=> url_for({:controller => :dev_feedbacks, :action => :show, :id => x.id})
        }
      }
      ret = @res["DevFeedback"][:controller].size
      @res["DevFeedback"].delete(:controller) if ret == 0
      @res["DevFeedback"][:action] ||= []
      @res["DevFeedback"][:action] +=
      DevFeedback.all(:conditions => ["LOWER(`action`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["DevFeedback"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{DevFeedback}),
          :field	=> _(%Q{Action}),
          :tags	=> "dev_feedbacks action",
          :link	=> url_for({:controller => :dev_feedbacks, :action => :show, :id => x.id})
        }
      }
      ret = @res["DevFeedback"][:action].size
      @res["DevFeedback"].delete(:action) if ret == 0
      @res["DevFeedback"][:ip] ||= []
      @res["DevFeedback"][:ip] +=
      DevFeedback.all(:conditions => ["LOWER(`ip`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["DevFeedback"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{DevFeedback}),
          :field	=> _(%Q{IP}),
          :tags	=> "dev_feedbacks ip",
          :link	=> url_for({:controller => :dev_feedbacks, :action => :show, :id => x.id})
        }
      }
      ret = @res["DevFeedback"][:ip].size
      @res["DevFeedback"].delete(:ip) if ret == 0
      @res["DevFeedback"][:ua] ||= []
      @res["DevFeedback"][:ua] +=
      DevFeedback.all(:conditions => ["LOWER(`ua`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["DevFeedback"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{DevFeedback}),
          :field	=> _(%Q{UA}),
          :tags	=> "dev_feedbacks ua",
          :link	=> url_for({:controller => :dev_feedbacks, :action => :show, :id => x.id})
        }
      }
      ret = @res["DevFeedback"][:ua].size
      @res["DevFeedback"].delete(:ua) if ret == 0

      #  @res.delete("DevFeedback") if 0 == (mod +
      #    (@res["DevFeedback"][:fts] ? @res["DevFeedback"][:fts].values.size : 0))
      # @res["DevFeedback"].values.flatten.size == 0

      @res["Access"] ||= {:ids => []}
      @res["Access"][:set_sid] ||= []
      @res["Access"][:set_sid] +=
      Access.all(:conditions => ["LOWER(`set_sid`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["Access"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{Access}),
          :field	=> _(%Q{Set}),
          :tags	=> "accesses set_sid",
          :link	=> url_for({:controller => :accesses, :action => :show, :id => x.id})
        }
      }
      ret = @res["Access"][:set_sid].size
      @res["Access"].delete(:set_sid) if ret == 0
      @res["Access"][:type_sid] ||= []
      @res["Access"][:type_sid] +=
      Access.all(:conditions => ["LOWER(`type_sid`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["Access"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{Access}),
          :field	=> _(%Q{Type}),
          :tags	=> "accesses type_sid",
          :link	=> url_for({:controller => :accesses, :action => :show, :id => x.id})
        }
      }
      ret = @res["Access"][:type_sid].size
      @res["Access"].delete(:type_sid) if ret == 0

      #  @res.delete("Access") if 0 == (mod +
      #    (@res["Access"][:fts] ? @res["Access"][:fts].values.size : 0))
      # @res["Access"].values.flatten.size == 0

      @res["Customer"] ||= {:ids => []}
      @res["Customer"][:first_name] ||= []
      @res["Customer"][:first_name] +=
      Customer.all(:conditions => ["LOWER(`first_name`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["Customer"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{Customer}),
          :field	=> _(%Q{First Name}),
          :tags	=> "customers first_name",
          :link	=> url_for({:controller => :customers, :action => :show, :id => x.id})
        }
      }
      ret = @res["Customer"][:first_name].size
      @res["Customer"].delete(:first_name) if ret == 0
      @res["Customer"][:last_name] ||= []
      @res["Customer"][:last_name] +=
      Customer.all(:conditions => ["LOWER(`last_name`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["Customer"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{Customer}),
          :field	=> _(%Q{Last Name}),
          :tags	=> "customers last_name",
          :link	=> url_for({:controller => :customers, :action => :show, :id => x.id})
        }
      }
      ret = @res["Customer"][:last_name].size
      @res["Customer"].delete(:last_name) if ret == 0
      @res["Customer"][:new_string] ||= []
      @res["Customer"][:new_string] +=
      Customer.all(:conditions => ["LOWER(`new_string`) LIKE ?", "#{bfor}#{@criteria}#{aftr}"]).map{|x|
        @res["Customer"][:ids] << x.id
        {:title	=> x.disp_name,
          :model	=> _(%Q{Customer}),
          :field	=> _(%Q{New String}),
          :tags	=> "customers new_string",
          :link	=> url_for({:controller => :customers, :action => :show, :id => x.id})
        }
      }
      ret = @res["Customer"][:new_string].size
      @res["Customer"].delete(:new_string) if ret == 0

      #  @res.delete("Customer") if 0 == (mod +
      #    (@res["Customer"][:fts] ? @res["Customer"][:fts].values.size : 0))
      # @res["Customer"].values.flatten.size == 0

    end
    @res.each{|k,v|
      ids = (v.delete(:ids) || [])
      @total += ids.uniq.size
      @res.delete(k) if v.blank?
    }
    @msg ||= _("Sorry, no result for '%{c}'") % {:c => @criteria} if @total == 0
    render :json => {
      :request	=> @criteria,
      :timestamp	=> @timestamp,
      :msg		=> @msg,
      :total	=> @total,
      :total_msg	=> _("Results: %{n}") % {:n => @total},
      :sections	=> @res
    }
  end
  protected


  # Manages query options: table, fields, criteria...
  #
  # Author:: Yann Azoury
  # Version:: 62
  # Last Update:: 2012-04-22 01:27:20 UTC
  # Status:: Requires Tests


  def smart_query_opts
    @tables = []
    @grouped_tables = {}
    @i = 0
    aks = Access.tables.all(:select => 'table_sid, app_sid').map{|a| [a.app_sid, a.table_sid]}
    aks.each do |a|
      g = a[0] || '[None]'
      t = a[1]
      @tables << t
      @grouped_tables[g] ||= []
      @grouped_tables[g] << [t.titleize, t]
    end
    model = params[:table]
    model = nil if model.blank?
    params[:smart_query].each{|k,v|
    model ||= v[:table_sid] if v} if model && !params[:smart_query].blank?
    model ||= @smart_query.table_sid
    @table = @tables.find{|t| t == model} if model
    @table ||= @tables.last
    @fields = []
    @criteria = HashWithIndifferentAccess.new
    if @table
      @model  = Kernel.const_get(@table.classify)
      @fields = SmartQuery.search_fields_of(@table)
      conds = params[:smart_query][params[:id]][:criteria] if params[:smart_query] && params[:smart_query][params[:id]]
      @smart_query.criteria = clean_criteria(conds) if conds.is_a?(Hash)
      conds = @smart_query.criteria
      unless conds.blank?
        begin
          if conds.is_a?(Array)
            conds.each{|crit|
              @criteria[crit[:field]] ||= []
              @criteria[crit[:field]] << crit
            }
          else
            raise
          end
        rescue

          # invalid conditions: raise an error, try to recover data, or just tell the user

          flash[:warning] = _("Invalid query. Data could not be recovered.")
        end
      end
    end
  end


  # Takes raw query parameters and makes a more usable conditions hash.
  #
  # Author:: Sylvain Abélard
  # Version:: 12
  # Last Update:: 2010-06-16 12:43:22 UTC
  # Status:: Requires Tests


  def clean_criteria(criteria)
    res = criteria.values.reject{|v| v[:compare].blank? || (v[:value].blank? && v[:compare] != 'IS NULL') }.map{|v|
      if v[:value].is_a?(Hash)
        t  = v[:value]
        if t[:year].blank?
          dt = Time.parse("#{t[:hour]}:#{t[:minute]}")
          v[:value] = dt.strftime("%H:%M") if dt
        else
          dt = DateTime.civil(t[:year].to_i, t[:month].to_i, t[:day].to_i, t[:hour].to_i, t[:minute].to_i, t[:second].to_i)
          dt = dt.to_date if dt && t[:hour].blank?
          v[:value] = dt.to_formatted_s(:db) if dt
        end
      end
      v
    }
    return res
  end
  private


  # For field criteria


  def set_criteria_for_create_7

    clean_criteria(@smart_query.criteria)

  end


  # For field criteria


  def set_criteria_for_update_7

    clean_criteria(@smart_query.criteria)

  end


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1

    ckie = (RUBY_VERSION =~ /^1.8/) ? Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "") :  (cookies[:active_filters] || "").force_encoding(Encoding::ISO_8859_1).encode!(Encoding::UTF_8)
    if !ckie.blank?
      find_hash = SmartQuery.named_scope_active_filter_method(ActiveSupport::JSON.decode(ckie))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      SmartQuery.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_smart_queries_pres_mode"].to_sym unless cookies["#{APP_SID}_smart_queries_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_smart_queries_pres_mode"].to_sym unless params["#{APP_SID}_smart_queries_pres_mode"].blank?
  end

end
