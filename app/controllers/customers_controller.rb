# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:40:27 +0100 2013
## It should be placed at 'app/controllers/customers_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class CustomersController < ApplicationController
  layout 'application_jquery_horizontal'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :create) do
    request.request_method_symbol == :post
  end
  before_filter(:only => :update) do
    request.request_method_symbol == :put
  end

  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])

  # AJAX association management.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2011-06-23 17:57:01 UTC
  # Status:: Requires Tests


  def linker

    render(:text => _('AJAX only')) and return if !request.xhr?
    render(:text => _('Missing required parameter')) and return if params[:id].blank? || params[:sid].blank?
    params[:page] = 1 if params[:page].to_i == 0
    params[:per_page] = 15 if params[:per_page].to_i == 0
    @customer   = Customer.find_by_id(params[:id])
    @customer ||= Customer.new
    case params[:sid].to_sym
    when :user
      val = params["user"] ? params["user"]["0"] : {}
      @user = User.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/users/list_for_linker', :locals => {:assoc_sid => :customers, :assoc_type => :belongs_to}
    end
  end


  # Retrieve the thumbnail of a file (icon or image).
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2013-02-04 15:20:42 UTC
  # Status:: Requires Tests


  def get_file_thumb

    @customer = Customer.find_by_id(params[:id])
    filename = nil
    document = nil
    mime	 = nil
    case params[:sid].to_s
    when "photo"
      filename   = @customer.photo__thumb_path
      filename ||= @customer.photo__name
      document   = @customer.photo
    end
    if filename
      mime = MIME::Types.type_for(filename)
      file_type = mime.first ? mime.first.content_type : 'application/octet-stream'
      disposition	= 'inline' if mime.first && ['text', 'image'].include?(mime.first.media_type)
      disposition ||= 'attachment'
      extension = filename.split('.').last
      if mime.first.nil? || mime.first.media_type != 'image'
        icon = Rails.root.join('public', 'images', 'file_icons', "#{extension}.png").to_s
        icon = Rails.root.join('public', 'images', 'file_icons', "defaut.png").to_s unless File.exist?(icon)

        # sends thumbnail file

        send_data(File.open(icon).read, :filename => File.basename(icon), :type => 'image/png', :disposition => 'inline')
        return
      end
      if document && Customer.columns.find{|e| e.name == params[:sid]}

        # sends thumbnail blob in the database

        send_data(@customer.thumbnail(params[:sid]), :filename => filename, :type => file_type, :disposition => 'inline')
      else

        # makes thumbnail and send

        thmb = @customer.thumbnail(params[:sid])
        if thmb
          send_data(thmb, :filename => filename, :type => file_type, :disposition => 'inline')
        else
          render :nothing => true
        end
      end
    else
      render :nothing => true
    end
  end


  # File management: gets files' size.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:23:12 UTC
  # Status:: Requires Tests


  def get_file_size

    size	  = nil
    filename = nil
    document = nil
    @customer = Customer.find_by_id(params[:id])
    case params[:sid].to_s
    when "photo"
      filename	= @customer.photo__path
      document	= @customer.photo
    end
    if Customer.columns.find{|e| e.name == params[:sid]} # binary in db
      size = document.blank? ? 0 : document.length
    else
      size = filename.blank? ? 0 : File.size(filename)
    end
    render :text => size.to_s
  end


  # Load the entire file.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2012-09-11 00:06:47 UTC
  # Status:: Requires Tests


  def get_file

    @customer = Customer.find_by_id(params[:id])
    filename = nil
    filepath = nil
    document = nil
    case params[:sid].to_s
    when "photo"
      filename = @customer.photo__name
      filepath = @customer.photo__path
      document = @customer.photo
    end
    if document && File.exist?(filepath)
      mime = MIME::Types.type_for(filename)
      file_type	= mime.first ? mime.first.content_type : 'application/octet-stream'
      disposition	= 'inline' if mime.first && ['text', 'image'].include?(mime.first.media_type)
      disposition ||= 'attachment'
      send_data(document, :filename => filename, :type => file_type, :disposition => disposition)
    else
      render :nothing => true
    end
  end


  # Index of all <%= model.sid %>.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-05-20 16:26:24 UTC
  # Status:: Validation Pending


  def index

    list
    unless(%w(json xml).include?(params[:format]))
      render(:action => :list)
    end
  end


  # This gives the list of all records
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-01-29 17:02:44 UTC
  # Status:: Validation Pending


  def list

    @restricted_fields = []
    pagin_opts = {:include => [:user]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:customers_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'customers.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @customers = Customer.paginate(pagin_opts)
    render(:xml => @customers.to_xml(:dasherize => false, :only => [:id,:first_name,:last_name,:photo__name,:new_date,:new_string], :methods => [:user_human_display])) and return if params[:format] == 'xml'
    render(:json => @customers) and return if params[:format] == 'json'
    render(:pdf => @customers, :action => :list) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["first_name", "last_name", "user", "new_date", "new_string"].include?(params[:group_by])
      @customers_groups = @customers.inject({}) { |acc,elt|
        crit = nil
        if ["user"].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # Loads a new record.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-03-25 18:26:30 UTC
  # Status:: Validation Pending


  def new

    @customer_attributes = params[:customer] ? params[:customer]['0'].clone : {}

    @customer = Customer.load_from_params(@customer_attributes)

    render(:layout => !request.xhr?)
  end


  # Inserts the record in the database.
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2013-10-31 16:38:41 UTC
  # Status:: Validation Pending


  def create

    redirect_to(:action => :index) and return unless request.post?
    redirect_to(:action => :index) and return if params[:customer].blank? || !params[:customer].is_a?(Hash)
    @customer_attributes = params[:customer] ? params[:customer]['0'].clone : {}

    @customer = Customer.load_from_params(@customer_attributes)
    if @customer.errors.empty? && @customer.save
      flash[:notice] = _("%{page} was successfully created.") % {:page => _("Customer")}
      if request.xhr? # && params[:format] == 'json'
        render(:json => {:id => @customer.id}.merge(@customer.attributes).to_json)
        return
      end
    else
      if request.xhr? # && params[:format] == 'json'
        render(:json => ({:errors => @customer.errors.full_messages}.merge(@customer.attributes)).to_json)
      else
        render(:action => :new)
      end
      return
    end
    if params[:go_to].blank?
      redirect_to :action => (params[:commit_and_new] ? :new : :index)
    else
      redirect_to(params[:go_to])
    end
  end


  # Display the record.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2012-03-26 04:12:53 UTC
  # Status:: Validation Pending


  def show

    @customer_attributes = params[:customer] ? params[:customer][params[:id]].clone : {}
    @customer_attributes.merge!(:id => params[:id]) if @customer_attributes

    @customer = Customer.load_from_params(@customer_attributes)
    if @customer.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'customer', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    respond_to do |format|
      format.html {
      render :layout => !request.xhr? }
      format.pdf {
      render :layout => false }
      format.xml {
      render :xml => @customer.to_xml }
      format.json {
      render :json => @customer.to_json }
    end
  end


  # Load the data to fill the edit form.
  #
  # Author:: Yann Azoury
  # Version:: 11
  # Last Update:: 2012-03-25 20:53:17 UTC
  # Status:: Validation Pending


  def edit

    @customer_attributes = params[:customer] ? params[:customer][params[:id]].clone : {}
    @customer_attributes.merge!(:id => params[:id]) if @customer_attributes

    @customer = Customer.load_from_params(@customer_attributes)
    if @customer.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'customer', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    render(:layout => !request.xhr?)
  end


  # Updates the current row in database from the sent form.
  #
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2012-12-13 11:53:56 UTC
  # Status:: Validation Pending


  def update

    redirect_to(:action => :index) and return unless request.put?
    redirect_to(:action => :index) and return if params[:customer].blank? || !params[:customer].is_a?(Hash)
    @customer_attributes = params[:customer] ? params[:customer][params[:id]].clone : {}
    @customer_attributes.merge!(:id => params[:id]) if @customer_attributes

    @customer = Customer.load_from_params(@customer_attributes)
    if @customer.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'customer', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end
    if @customer.save
      flash[:notice] = _("%{page} was successfully updated.") % {:page => _("Customer")}
    else
      if request.xhr?
        render(:json => {:errors =>
        @customer.errors.full_messages})
      else
        render(:action => :edit, :id => @customer.id)
      end
      return
    end
    render(:json => "OK") and return if request.xhr?
    if params[:customer].length == 1 # single edit
      redirect_to :action => :show, :id => @customer.id
    else
      redirect_to :action => :index
    end
  end


  # Deletes an object or list of objects from the database.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2011-03-08 15:34:31 UTC
  # Status:: Validation Pending


  def destroy

    if params[:id].is_a?(Array)
      @success = Customer.destroy(params[:id])
    else
      @customer = Customer.find_by_id(params[:id])
      @customer.destroy unless @customer.nil?
      @success = @customer && @customer.destroyed?
    end
    if @success
      flash[:notice] = _("%{model} %{name} successfully deleted.") % {:model => _("Customer"), :name => @customer.disp_name}
    else
      flash[:warning] = _("%{model} %{name} could not be deleted.") % {:model => _("Customer"), :name => params[:name]}
    end
    if params[:format] != "json"
      if request.xhr?
        render :action => 'ajax_update', :layout => false
      else
        if params[:go_to].blank?
          redirect_to :action => :index
        else
          redirect_to(params[:go_to])
        end
      end
    else
      resp = {}
      if @success
        resp[:success] = true
      else
        resp[:success] = false
        resp[:error] = flash[:warning]
      end
      render :json => resp.to_json, :layout => false
    end
  end


  # Search and filter data.
  #
  # Author:: Sylvain Abélard
  # Version:: 44
  # Last Update:: 2010-06-15 18:38:22 UTC
  # Status:: Requires Tests


  def search

    @customer = Customer.load_from_params(params[:customer]["0"]) if params[:customer]
    @customer ||= Customer.new
    page	   = params[:page].to_i > 0 ? params[:page].to_i : 1
    per_page   = params[:per_page]
    per_page ||= Customer.count if params[:format] && %w(xml xls csv).include?(params[:format])
    per_page   = 50 if !per_page || per_page == 0

    # GET RESULTS FROM SMART_QUERY OR PARAMS

    if params[:customer]
      my_p = params[:customer]["0"].reject{|k, v|
        params["comp_#{k}"].blank? || (v.blank? && !params["comp_#{k}"].include?('NULL'))
      } if params[:customer]["0"]
      @customers = Customer.search(my_p, params.reject{|k,v| !k[/comp_/]}, :page => page, :per_page => per_page)
    elsif params[:query]
      @customers = Customer.active_filter(ActiveSupport::JSON.decode(params[:query])).paginate(:page => page, :per_page => per_page)
    elsif params[:fts_query]
      l = params[:limit] ? params[:limit] : :all
      @customers = Customer.find_with_ferret(params[:fts_query], :limit => l)
    elsif (params[:id] || params[:smart_query])
      if params[:id]
        @smart_query = SmartQuery.find_by_id(params[:id])
      else
        attr = params[:smart_query].first[1] if params[:smart_query].first
        attr[:criteria] = SmartQuery.clean_criteria(attr[:criteria])
        @smart_query = SmartQuery.new(attr)
      end
      @customers = Customer.search(@smart_query, :page => page, :per_page => per_page)
    else
      opts = {:include => [:user]}
      opts[:page]		  = page
      opts[:per_page]	  = per_page
      opts[:order]		  = @default_order
      opts[:order]		||= 'customers.' +params[:sort_by] if !params[:sort_by].blank?
      opts[:conditions]	||= @default_filter
      opts[:joins] 		||= @joins_fields  || []
      @customers = Customer.paginate(opts)
    end

    # RENDER SOMETHING

    if !@customers.blank? && params[:format] # GET
      if params[:format] == 'xml'
        send_data(@customers.to_xml,
        :filename => ('customers.xml'),
        :disposition => 'attachment',
        :type => 'text/xml;charset=utf-8')
        return
      elsif params[:format] == 'xls'
        cols = []
        Customer::FIELDS.each{|k,v|
        cols << k if [:string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
        book = Spreadsheet::Workbook.new
        sheet = book.create_worksheet(:name => "customers")
        sheet.row(0).concat(cols)
        @customers.each_with_index do |row,i|
          sheet.row(i+1).replace(cols.map{|c|
            if [:ho_assoc, :bt_assoc].include?(Customer::FIELDS[c])
              v = row.send(c)
              v ? v.disp_name : ''
            else
              row.send(c)
            end
          })
        end
        fname = "customers.xls"
        tmp = Tempfile.new(fname)
        book.write(tmp.path)
        tmp.close
        send_file(tmp.path, :filename => fname)
        return
      elsif params[:format] == 'csv'
        cols = Customer::FIELDS.inject([]) {|a,v|
        a << v[0] if [:ho_assoc, :bt_assoc, :string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp].include?(v[1]) ; a}
        @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';') }) do |csv|
          csv << cols
          for row in @customers
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(Customer::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
        end
        @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
        conv = Iconv.new(@export_encoding, 'UTF-8')
        send_data(conv.iconv(@csv_string), :filename => "customers.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        return
      end
    end
    if request.xhr? || request.post?
      render :partial => 'result_list' and return
    end
  end


  # Allows download of all or current record in many formats.
  #
  # Author:: Yann Azoury
  # Version:: 46
  # Last Update:: 2013-02-11 07:45:35 UTC
  # Status:: Validation Pending


  def download

    @restricted_fields = []
    @no_menubar	= true
    @no_links	= true
    @no_filterbar	= true
    @no_row_links	= true
    pagin_opts		  = {:include => [:user]}
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= "customers.#{params[:sort_by]}" if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter
    pagin_opts[:joins]	||= @joins_fields || []

    # pagin_opts[:select]	||= "`customers`.`first_name`,`customers`.`last_name`" unless params[:format] == 'html'

    if params[:id] && params[:id].to_i > 0
      @customer = Customer.find_by_id(params[:id], pagin_opts)
      if !@customer
        flash[:warning] = _("Error: %{obj} not found!") % {:obj => _(%q[Customer])}
        begin
          redirect_to :back
        rescue
          redirect_to :action => :list
        end
        return
      end
      f_name = @customer.disp_name
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/customers/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/customers/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/customers/show.html.erb', :format => :html, :id => @customer.id, :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "#{@customer.disp_name}.pdf") unless params[:debug_pdf] || pdf.blank?

          # send_data(render_to_string(:format => :html, :layout => false, :action => :show, :id => @customer.id), :filename => "#{f_name}.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

          return
        }
        format.xml {
        send_data(@customer.to_xml, :filename => "#{f_name}.xml", :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.json {
        send_data(@customer.to_json, :filename => "#{f_name}.json", :disposition => 'attachment', :type => 'text/json;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "customers")
          sheet.row(0).concat(["First Name", "Last Name"])
          sheet.row(1).replace([@customer.first_name, @customer.last_name])
          fname = "customers.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv { row = @customer
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            Customer::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:user].include?(c) }
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(Customer::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "#{f_name}.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
          return
        }
      end
    else
      pagin_opts[:page] = 1
      pagin_opts[:per_page] = Customer.count+1
      @customers = Customer.paginate(pagin_opts)
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/customers/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "customers.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/customers/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "customers.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/customers/list.html.erb', :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "customers.pdf") unless params[:debug_pdf] || pdf.blank?

          #      send_data(render_to_string(:layout => false, :action => :list), :filename => "customers.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

        }
        format.xml {
        send_data(@customers.to_xml, :filename => ('customers.xml'), :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "customers")
          sheet.row(0).concat(["First Name", "Last Name"])
          @customers.each_with_index do |row,i|
            sheet.row(i+1).replace([row.first_name, row.last_name])
          end
          fname = "customers.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv {
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            Customer::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:user].include?(c) }
            csv << cols.map{|c| _(c.titleize)}
            @customers.map{|row|
              csv << cols.map {|c|
                if [:ho_assoc, :bt_assoc].include?(Customer::FIELDS[c])
                  v = row.send(c) ; v ? v.disp_name : nil
                else
                  row.send(c)
                end
              }
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "customers.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        }
      end
    end
  end


  # Exports RSS, XML and ATOM feeds.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 12:11:11 UTC
  # Status:: Validation Pending


  def feed

    @customers = Customer.all(:limit => 50)
    respond_to do |format|
      format.rss {render :template => 'customers/rss', :layout => false}
      format.xml {render :template => 'customers/rss', :layout => false}
      format.html {render :template => 'customers/rss', :layout => false}
      format.atom {render :template => 'customers/atom', :layout => false}
    end
  end


  # Gives help about current module.
  #
  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2012-05-19 23:29:44 UTC
  # Status:: Validation Pending


  def help

    @user_actions = Access.where(:table_sid => "customers", :action_sid => ["index", "list", "new", "create", "show", "edit", "update", "destroy", "search", "download", "feed", "help", "adv_search"]).includes([:user_accesses, :profile_accesses]).reject{|a| @current_user.can_run?(a) }
    render(:layout => !request.xhr?)
  end


  # Make complex queries.
  #
  # Author:: Yann Azoury
  # Version:: 7
  # Last Update:: 2010-05-27 12:12:45 UTC
  # Status:: Validation Pending


  def adv_search

    redirect_to :action => :search
  end
  protected
  private


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1

    ckie = (RUBY_VERSION =~ /^1.8/) ? Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "") :  (cookies[:active_filters] || "").force_encoding(Encoding::ISO_8859_1).encode!(Encoding::UTF_8)
    if !ckie.blank?
      find_hash = Customer.named_scope_active_filter_method(ActiveSupport::JSON.decode(ckie))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      Customer.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_customers_pres_mode"].to_sym unless cookies["#{APP_SID}_customers_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_customers_pres_mode"].to_sym unless params["#{APP_SID}_customers_pres_mode"].blank?
  end

end
