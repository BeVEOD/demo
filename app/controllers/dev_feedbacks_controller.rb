# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:40:24 +0100 2013
## It should be placed at 'app/controllers/dev_feedbacks_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class DevFeedbacksController < ApplicationController
  layout 'application'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :create) do
    request.request_method_symbol == :post
  end
  before_filter(:only => :update) do
    request.request_method_symbol == :put
  end

  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])

  # AJAX association management.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2011-06-23 17:57:01 UTC
  # Status:: Requires Tests


  def linker

    render(:text => _('AJAX only')) and return if !request.xhr?
    render(:text => _('Missing required parameter')) and return if params[:id].blank? || params[:sid].blank?
    params[:page] = 1 if params[:page].to_i == 0
    params[:per_page] = 15 if params[:per_page].to_i == 0
    @dev_feedback   = DevFeedback.find_by_id(params[:id])
    @dev_feedback ||= DevFeedback.new
    case params[:sid].to_sym
    when :user
      val = params["user"] ? params["user"]["0"] : {}
      @user = User.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/users/list_for_linker', :locals => {:assoc_sid => :dev_feedbacks, :assoc_type => :belongs_to}
    end
  end


  # Reporting: displays preset reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 19:23:13 UTC
  # Status:: Requires Tests


  def report_chooser

    @data_sets = SmartQuery.all(:conditions => {:table_sid => ['dev_feedbacks', '']})
    m_par = params[:dev_feedbacks] || {}
    @data_set = SmartQuery.find_by_id(m_par[:data_set]) || @data_sets.first
    logger.debug("m_par #{m_par.inspect}")
  end


  # Reporting: global steps to rendering reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:24:32 UTC
  # Status:: Could be optimized


  def report_generate

    report_check_params

    #logger.debug("BEGIN report_load_labels")

    report_load_labels

    #logger.debug("END report_load_labels")
    #logger.debug("BEGIN report_load_datasets")

    report_load_datasets

    #logger.debug("END report_load_datasets")
    #logger.debug("BEGIN report_load_title")

    report_load_title

    #logger.debug("END report_load_title")

    respond_to do |format|
      format.html {report_convert_to_html}
      format.json {report_convert_to_ofc}

      #  format.pdf {report_convert_to_pdf }

    end
  end


  # Reporting: checks sent params for security and consistency.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:23:42 UTC
  # Status:: Could be optimized


  def report_check_params


    # logger.debug("BEGIN report_check_params")

    @report_type = params[:format] == 'html' ? :table : :chart
    @x_type = DevFeedback::FIELDS[params[:x_field]]
    render(:text => "No correct x_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@x_type)

    # logger.debug("\t\t x_field: #{params[:x_field]} (#{@x_type})")

    if params[:y_field]
      @y_type = DevFeedback::FIELDS[params[:y_field]]
      render(:text => "No correct y_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@y_type)
    end
    render(:text => "No correct serie parameter") and return if params[:serie_1].blank? || !params[:serie_1].is_a?(Hash) || (params[:serie_1][:field].blank? && params[:serie_1][:operation].blank?)
    f = params["serie_1"][:field] ||= 'id'
    o = params["serie_1"][:operation] ||= [:integer, :float, :double].include?(DevFeedback::FIELDS[params["serie_1"][:field]]) ? :value : :count

    # TODO manage field is a model_method

    render(:text => "No correct serie[:field] parameter") and return if !DevFeedback::FIELDS.has_key?(f) && (o != 'count')
    render(:text => "No correct serie[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(DevFeedback::FIELDS[f]) && params[:serie_1][:operation].blank?)
    (2..5).each {|i|
      break if params["serie_#{i}"].blank? || !params["serie_#{i}"].is_a?(Hash)
      f = params["serie_#{i}"][:field]
      render(:text => "No correct serie_#{i}[:field] parameter") and return if f.blank? || !DevFeedback::FIELDS.has_key?(f)
      render(:text => "No correct serie_#{i}[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(DevFeedback::FIELDS[f]) && params["serie_#{i}"][:operation].blank?)
    }
    @x_field = params[:x_field]
    @y_field = params[:y_field] unless params[:y_field].blank?

    # logger.debug("END report_check_params")

  end


  # Reporting: extracts labels and categories to display axes.
  #
  # Author:: Yann Azoury
  # Version:: 6
  # Last Update:: 2011-01-22 17:12:57 UTC
  # Status:: Could be optimized


  def report_load_labels

    case @x_type
    when :string
      return @x_labels = DevFeedback.all(:select => "DISTINCT(`#{@x_field}`)").map{|r| r.send(@x_field)}
    when :static_list
      return @x_labels = DevFeedback.const_get(@x_field.pluralize.upcase)
    when :bt_assoc
      return @x_labels = DevFeedback.reflect_on_association(@x_field.to_sym).klass.all
    end
    @x_range = if params[:x_range] # range is given
      case @x_type
      when :integer
        params[:x_range].split('..').map(&:to_i)
      when :float, :double
        params[:x_range].split('..').map(&:to_f)
      when :date, :datetime
        rg = params[:x_range].split('..').map(&:to_i)
        @x_min = Time.now + rg.first.days
        @x_max = Time.now + rg.last.days
        rg
      end
    else
      @x_min = DevFeedback.minimum(@x_field)
      @x_max = DevFeedback.maximum(@x_field)
      case @x_type
      when :integer, :float, :double
      when :date, :datetime
        [((@x_min - Time.now) / 86400).round, ((@x_max - Time.now) / 86400).round]
      end
    end
    if true
      case @x_type
      when :integer, :float, :double
        @x_min, @x_max = @x_range
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10.0
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
        @x_labels = [@x_min]
        while(@x_labels.last <= @x_max) do
          @x_labels << @x_labels.last + @x_steps
        end
      when :date, :datetime
        @x_steps = case params[:x_steps]
        when "month"
          30
        when "week"
          7
        else
          if !params[:x_steps] || params[:x_steps].to_i == 0
            (@x_range.last - @x_range.first).round / 10.0
          else
            params[:x_steps].to_i
          end
        end
        @x_steps = 1 if @x_steps == 0
        @x_min ||= Time.now + @x_range.first.days
        @x_max ||= Time.now + @x_range.last.days
        @x_labels = [@x_min]
        logger.debug("\t (#{@x_min})..(#{@x_max}) - #{@x_steps} days step")
        200.times {
          break if @x_labels.last > @x_max
          @x_labels << @x_labels.last + @x_steps.days
        }
      end
    else  # no params[:x_range] => need to guess range
      case @x_type
      when :integer, :float, :double
        @datasets.each_with_index { |h,i|
          d = h[:values]
          if !@x_min
            @x_min = d.min
          else
            d_min = d.min
            @x_min = d_min if d_min < @x_min
          end
          if !@x_max
            @x_max = d.max
          else
            d_max = d.max
            @x_max = d_max if d_max > @x_max
          end
        }
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
      end
      case @x_type
      when :integer, :float, :double
        if params[:x_ticks]
        end
      when :static_list
      when :date, :datetime
      end
    end
  end


  # Reporting: loads datasets.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:20:49 UTC
  # Status:: Could be optimized


  def report_load_datasets

    @datasets = []
    i = 1
    if @y_field
      case @y_type
      when :string
        @y_labels = DevFeedback.all(:select => DevFeedback.connection.distinct(@y_field, nil)).map{|r| r.send(@y_field)}
      when :static_list
        @y_labels = DevFeedback.const_get(@y_field.pluralize.upcase)
      when :ho_assoc, :bt_assoc, :habtm_assoc
        @y_labels = DevFeedback.all(:include => @y_field).map{|r| r.send(@y_field)}
      end
      while(params["serie_#{i}"]) do
        ds = {}
        @y_labels.each_with_index { |l,idx|
          next if l.nil?
          case @y_type
          when :string
            ds["values_for_#{l}"] = DevFeedback.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => l}, :data_set => @data_set)
          when :static_list
            ds["values_for_#{l}"] = DevFeedback.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => (@y_labels.index(l)+1)}, :data_set => @data_set)
          when :bt_assoc
            fk = DevFeedback.reflect_on_association(@y_field.to_sym).primary_key_name

            #        DevFeedback.send(:with_scope, :find => {:conditions => {fk => l.id}}) {
            #        ds["values_for_#{l.id}"] = report_retrieve_data(params["serie_#{i}"][:operation].to_s, params["serie_#{i}"][:field])

            ds["values_for_#{l.id}"] = DevFeedback.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {fk => l.id}, :data_set => @data_set)

            #        }

          end
        }
        i += 1 ; @datasets << ds
      end
      return
    end
    while(params["serie_#{i}"]) do
      ds = {:values => DevFeedback.report_calculation(params["serie_#{i}"][:operation],
        params["serie_#{i}"][:field],
      :group => @x_field, :labels => @x_labels, :data_set => @data_set)}
      ds[:type] = params["serie_#{i}"][:type] || 'bar'
      @y_min = 0
      y_min = ds[:values].min || 0
      @y_min = y_min if y_min < @y_min
      if !@y_max
        @y_max = ds[:values].max || 0
      else
        y_max = ds[:values].max || 0
        @y_max = y_max if y_max > @y_max
      end
      i += 1 ; @datasets << ds
    end
    case @y_max
    when 0...5 then @y_max = 5 ; @y_step = 1
    when 5..10 then @y_max = 10 ; @y_step = 1
    when 10..50 then @y_max = 50 ; @y_step = 5
    when 50..100 then @y_max = 100 ; @y_step = 10
    when 100..500 then @y_max = 500 ; @y_step = 50
    when 500..1000 then @y_max = 1000 ; @y_step = 50
    when 1000..5000 then @y_max = 5000 ; @y_step = 100
    end
  end


  # Reporting: displays selected title or guess an appropriate one.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:19:56 UTC
  # Status:: Could be optimized


  def report_load_title

    @title = _(params[:title]) and return unless params[:title].blank?
    op_nm = case params[:serie_1][:operation].to_s
    when "avg" then "Average"
    when "min" then "Minimum"
    when "max" then "Maximum"
    else params[:serie_1][:operation].to_s.titleize
    end
    @title = "#{op_nm} of " + (params[:serie_1][:operation].to_s == 'count' ? 'records' : params[:serie_1][:field].to_s)
    @title << " by " + @x_field
    case @x_type
    when :date, :datetime
      @title << " from " + @x_labels.first.strftime("%D") + " to " + @x_labels.last.strftime("%D")
    end
    @datasets.each_with_index do |ds,idx|
      ds[:text] ||= params["serie_#{idx+1}"][:operation].to_s.titleize + " of " + (params["serie_#{idx+1}"][:operation].to_s == 'count' ? 'records' : params["serie_#{idx+1}"][:field].to_s)
    end if @report_type == :chart
  end


  # Reporting: renders data in HTML tables.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:18:50 UTC
  # Status:: Could be optimized


  def report_convert_to_html

    title = "<caption>#{@title}</caption>"
    if @y_labels # matrix
      @report = @datasets.map {|ds|
        logger.debug("ds: #{ds.inspect}")
        trs = [['<th></th>'] + @x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        case @y_type
        when :ho_assoc, :bt_assoc
          trs += @y_labels.uniq.map{ |l| l ? (["<th>#{l.disp_name}</th>"] + ds["values_for_#{l.id}"].map { |v| "<td>#{v}</td>" }) : [] }
        else
          trs += @y_labels.uniq.map{ |l| ["<th>#{l}</th>"] + ds["values_for_#{l}"].map { |v| "<td>#{v}</td>" } }
        end
        "<table>#{title}%s</table>" % trs.map{|t| "<tr>#{t}</tr>"}.join
      }
    else
      @report = @datasets.map {|ds|
        trs = [@x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        trs << ds[:values].map { |v| "<td>#{v}</td>" }
        "<table>#{title}#{trs.map{|t| "<tr>#{t}</tr>"}}</table>"
      }
    end
    render :text => @report
  end


  # Reporting: adds OFC styles and renders appropriate JSON.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 12:18:04 UTC
  # Status:: Could be optimized


  def report_convert_to_ofc

    colors = %w(2222FF 7FFFD4 D2691E A9A9A9 BDB76B DCDCDC ADFF2F F4A460 F5DEB3)
    @datasets.each_with_index { |d,idx|
      d[:type] ||= "bar"
      d[:colour] ||= colors[idx]
    }
    @report = {:elements => @datasets, :title => {:text => @title}, :bg_colour => "#FFFFFF"}
    case @x_type
    when :date, :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d, :format => :short)}, :rotate => '45' }}
    when :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d.to_date, :format => :short)}, :rotate => '45' }}
    when :integer, :float, :decimal, :static_list
      @report[:x_axis] = {:labels => {:labels => @x_labels, :rotate => '45'} }
    when :bt_assoc
      @report[:x_axis] = {:labels => {:labels => @x_labels.map(&:disp_name), :rotate => '45'} }
    end
    @report[:y_axis] = {:min => @y_min, :max => @y_max}
    @report[:y_axis][:steps] = @y_step if @y_step
    render :json => @report
  end


  # Displays nested set data in a tree.
  #
  # Author:: Sylvain Abélard
  # Version:: 8
  # Last Update:: 2010-06-16 12:24:11 UTC
  # Status:: Requires Tests


  def tree_list

    p_id = params[:node].to_i > 0 ? params[:node] : nil
    if request.xhr? && params[:node]
      @roots = DevFeedback.all(:conditions => {:parent_id => p_id}, :order => 'lft').map{ |r|
        {'id' => r.id,
          'text' => r.disp_name,
        'leaf' => false } # (r.children_count == 0) }
      }
    else
      @root   = DevFeedback.find_by_id(params[:id]) if params[:id]
      @root ||= DevFeedback.get_root
    end
    respond_to do |format|
      format.html { render(:partial => 'tree_list', :locals => {:row => @root} ) if request.xhr? }
      format.json { render :json	=> @roots.to_json }
      format.xml  { render :xml	=> @roots.to_xml }
    end
  end


  # Nested sets: node management.
  #
  # Author:: Sylvain Abélard
  # Version:: 8
  # Last Update:: 2010-06-16 12:28:05 UTC
  # Status:: Requires Tests


  def tree_move

    @dev_feedback = DevFeedback.find_by_id(params[:id])
    @to_remove = []
    if @dev_feedback
      if params[:receiver]
        @receiver = DevFeedback.find_by_id(params[:receiver])
        parent    = @receiver.parent || DevFeedback.get_root
        @dev_feedback.move_to_right_of(@receiver) if @receiver
      elsif params[:direction]
        case params[:direction]
        when 'prev'
          @dev_feedback.move_left
          parent = @dev_feedback.parent || DevFeedback.get_root
        when 'next'
          @dev_feedback.move_right
          parent = @dev_feedback.parent || DevFeedback.get_root
        when 'inc'
          parent = @dev_feedback.left_sibling
          @dev_feedback.move_to_child_of(parent)
        when 'dec'
          @dev_feedback.move_to_right_of(@dev_feedback.parent)
          parent = @dev_feedback.parent || DevFeedback.get_root
        end
      end
    end
    render :partial => 'tree_list', :locals => {:row => parent}
  end


  # Load requested report.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 17:49:09 UTC
  # Status:: Validation Pending


  def reporting

    params[:report] = "" if params[:report].blank?
    @report = params[:report]
  end


  # Responds Report data in any format.
  #
  # Author:: Yann Azoury
  # Version:: 15
  # Last Update:: 2010-06-18 18:06:28 UTC
  # Status:: Validation Pending


  def reporting_data

    report_sid = params[:report].blank? ? "" : params[:report]
    render(:nothing => true) and return if report_sid.blank?
    opts = (params[:report_options] || {}).reject{|k,v| v.blank?}
    opts[:format] ||= params[:format]
    r = DevFeedbackReport.make_report(report_sid, opts)
    r[:title][:style] = r[:title][:style].tr(',', ';').gsub('colour', 'color') if r && r[:title] && r[:title][:style]
    @report = r
    respond_to do |format|
      format.json { render :json => @report }
      format.html { render :text => @report }
    end
  end


  # Index of all <%= model.sid %>.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-05-20 16:26:24 UTC
  # Status:: Validation Pending


  def index

    list
    unless(%w(json xml).include?(params[:format]))
      render(:action => :list)
    end
  end


  # This gives the list of all records
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-01-29 17:02:44 UTC
  # Status:: Validation Pending


  def list

    @restricted_fields = []
    pagin_opts = {:include => [:user]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:dev_feedbacks_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'dev_feedbacks.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @dev_feedbacks = DevFeedback.paginate(pagin_opts)
    render(:xml => @dev_feedbacks.to_xml(:dasherize => false, :only => [:id,:ticket_status,:title,:text,:zone,:url,:controller,:action,:created_at,:ip,:ua,:browser,:parent_id], :methods => [:user_human_display])) and return if params[:format] == 'xml'
    render(:json => @dev_feedbacks) and return if params[:format] == 'json'
    render(:pdf => @dev_feedbacks, :action => :list) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["title", "url", "controller", "action", "created_at", "user", "ip", "ua", "parent_id"].include?(params[:group_by])
      @dev_feedbacks_groups = @dev_feedbacks.inject({}) { |acc,elt|
        crit = nil
        if ["user"].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # Loads a new record.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-03-25 18:26:30 UTC
  # Status:: Validation Pending


  def new

    @dev_feedback_attributes = params[:dev_feedback] ? params[:dev_feedback]['0'].clone : {}

    @dev_feedback = DevFeedback.load_from_params(@dev_feedback_attributes)

    render(:layout => !request.xhr?)
  end


  # Inserts the record in the database.
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2013-10-31 16:38:41 UTC
  # Status:: Validation Pending


  def create

    redirect_to(:action => :index) and return unless request.post?
    redirect_to(:action => :index) and return if params[:dev_feedback].blank? || !params[:dev_feedback].is_a?(Hash)
    @dev_feedback_attributes = params[:dev_feedback] ? params[:dev_feedback]['0'].clone : {}
    @dev_feedback_attributes.delete(:ip) if @dev_feedback_attributes && restrict_ip_for_create_5
    @dev_feedback_attributes.delete(:ua) if @dev_feedback_attributes && restrict_ua_for_create_5
    @dev_feedback = DevFeedback.load_from_params(@dev_feedback_attributes)
    @dev_feedback.user = set_user_for_create_8
    @dev_feedback.ip = set_ip_for_create_9
    @dev_feedback.ua = set_ua_for_create_10
    if @dev_feedback.errors.empty? && @dev_feedback.save
      @dev_feedback.move_to_child_of(@dev_feedback_attributes[:parent_id]) unless @dev_feedback_attributes[:parent_id].blank?
      flash[:notice] = _("%{page} was successfully created.") % {:page => _("Dev Feedback")}
      if request.xhr? # && params[:format] == 'json'
        render(:json => {:id => @dev_feedback.id}.merge(@dev_feedback.attributes).to_json)
        return
      end
    else
      if request.xhr? # && params[:format] == 'json'
        render(:json => ({:errors => @dev_feedback.errors.full_messages}.merge(@dev_feedback.attributes)).to_json)
      else
        render(:action => :new)
      end
      return
    end
    if params[:go_to].blank?
      redirect_to :action => (params[:commit_and_new] ? :new : :index)
    else
      redirect_to(params[:go_to])
    end
  end


  # Display the record.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2012-03-26 04:12:53 UTC
  # Status:: Validation Pending


  def show

    @dev_feedback_attributes = params[:dev_feedback] ? params[:dev_feedback][params[:id]].clone : {}
    @dev_feedback_attributes.merge!(:id => params[:id]) if @dev_feedback_attributes
    @dev_feedback_attributes.delete(:ip) if @dev_feedback_attributes && restrict_ip_for_show_5
    @dev_feedback_attributes.delete(:ua) if @dev_feedback_attributes && restrict_ua_for_show_5
    @dev_feedback = DevFeedback.load_from_params(@dev_feedback_attributes)
    if @dev_feedback.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'dev_feedback', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    respond_to do |format|
      format.html {
      render :layout => !request.xhr? }
      format.pdf {
      render :layout => false }
      format.xml {
      render :xml => @dev_feedback.to_xml }
      format.json {
      render :json => @dev_feedback.to_json }
    end
  end


  # Load the data to fill the edit form.
  #
  # Author:: Yann Azoury
  # Version:: 11
  # Last Update:: 2012-03-25 20:53:17 UTC
  # Status:: Validation Pending


  def edit

    @dev_feedback_attributes = params[:dev_feedback] ? params[:dev_feedback][params[:id]].clone : {}
    @dev_feedback_attributes.merge!(:id => params[:id]) if @dev_feedback_attributes
    @dev_feedback_attributes.delete(:ip) if @dev_feedback_attributes && restrict_ip_for_edit_5
    @dev_feedback_attributes.delete(:ua) if @dev_feedback_attributes && restrict_ua_for_edit_5
    @dev_feedback = DevFeedback.load_from_params(@dev_feedback_attributes)
    if @dev_feedback.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'dev_feedback', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    render(:layout => !request.xhr?)
  end


  # Updates the current row in database from the sent form.
  #
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2012-12-13 11:53:56 UTC
  # Status:: Validation Pending


  def update

    redirect_to(:action => :index) and return unless request.put?
    redirect_to(:action => :index) and return if params[:dev_feedback].blank? || !params[:dev_feedback].is_a?(Hash)
    @dev_feedback_attributes = params[:dev_feedback] ? params[:dev_feedback][params[:id]].clone : {}
    @dev_feedback_attributes.merge!(:id => params[:id]) if @dev_feedback_attributes
    @dev_feedback_attributes.delete(:ip) if @dev_feedback_attributes && restrict_ip_for_update_5
    @dev_feedback_attributes.delete(:ua) if @dev_feedback_attributes && restrict_ua_for_update_5
    @dev_feedback = DevFeedback.load_from_params(@dev_feedback_attributes)
    if @dev_feedback.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'dev_feedback', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end
    if @dev_feedback.save
      flash[:notice] = _("%{page} was successfully updated.") % {:page => _("Dev Feedback")}
    else
      if request.xhr?
        render(:json => {:errors =>
        @dev_feedback.errors.full_messages})
      else
        render(:action => :edit, :id => @dev_feedback.id)
      end
      return
    end
    render(:json => "OK") and return if request.xhr?
    if params[:dev_feedback].length == 1 # single edit
      redirect_to :action => :show, :id => @dev_feedback.id
    else
      redirect_to :action => :index
    end
  end


  # Deletes an object or list of objects from the database.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2011-03-08 15:34:31 UTC
  # Status:: Validation Pending


  def destroy

    if params[:id].is_a?(Array)
      @success = DevFeedback.destroy(params[:id])
    else
      @dev_feedback = DevFeedback.find_by_id(params[:id])
      @dev_feedback.destroy unless @dev_feedback.nil?
      @success = @dev_feedback && @dev_feedback.destroyed?
    end
    if @success
      flash[:notice] = _("%{model} %{name} successfully deleted.") % {:model => _("Dev Feedback"), :name => @dev_feedback.disp_name}
    else
      flash[:warning] = _("%{model} %{name} could not be deleted.") % {:model => _("Dev Feedback"), :name => params[:name]}
    end
    if params[:format] != "json"
      if request.xhr?
        render :action => 'ajax_update', :layout => false
      else
        if params[:go_to].blank?
          redirect_to :action => :index
        else
          redirect_to(params[:go_to])
        end
      end
    else
      resp = {}
      if @success
        resp[:success] = true
      else
        resp[:success] = false
        resp[:error] = flash[:warning]
      end
      render :json => resp.to_json, :layout => false
    end
  end


  # Search and filter data.
  #
  # Author:: Sylvain Abélard
  # Version:: 44
  # Last Update:: 2010-06-15 18:38:22 UTC
  # Status:: Requires Tests


  def search

    @dev_feedback = DevFeedback.load_from_params(params[:dev_feedback]["0"]) if params[:dev_feedback]
    @dev_feedback ||= DevFeedback.new
    page	   = params[:page].to_i > 0 ? params[:page].to_i : 1
    per_page   = params[:per_page]
    per_page ||= DevFeedback.count if params[:format] && %w(xml xls csv).include?(params[:format])
    per_page   = 50 if !per_page || per_page == 0

    # GET RESULTS FROM SMART_QUERY OR PARAMS

    if params[:dev_feedback]
      my_p = params[:dev_feedback]["0"].reject{|k, v|
        params["comp_#{k}"].blank? || (v.blank? && !params["comp_#{k}"].include?('NULL'))
      } if params[:dev_feedback]["0"]
      @dev_feedbacks = DevFeedback.search(my_p, params.reject{|k,v| !k[/comp_/]}, :page => page, :per_page => per_page)
    elsif params[:query]
      @dev_feedbacks = DevFeedback.active_filter(ActiveSupport::JSON.decode(params[:query])).paginate(:page => page, :per_page => per_page)
    elsif params[:fts_query]
      l = params[:limit] ? params[:limit] : :all
      @dev_feedbacks = DevFeedback.find_with_ferret(params[:fts_query], :limit => l)
    elsif (params[:id] || params[:smart_query])
      if params[:id]
        @smart_query = SmartQuery.find_by_id(params[:id])
      else
        attr = params[:smart_query].first[1] if params[:smart_query].first
        attr[:criteria] = SmartQuery.clean_criteria(attr[:criteria])
        @smart_query = SmartQuery.new(attr)
      end
      @dev_feedbacks = DevFeedback.search(@smart_query, :page => page, :per_page => per_page)
    else
      opts = {:include => [:user]}
      opts[:page]		  = page
      opts[:per_page]	  = per_page
      opts[:order]		  = @default_order
      opts[:order]		||= 'dev_feedbacks.' +params[:sort_by] if !params[:sort_by].blank?
      opts[:conditions]	||= @default_filter
      opts[:joins] 		||= @joins_fields  || []
      @dev_feedbacks = DevFeedback.paginate(opts)
    end

    # RENDER SOMETHING

    if !@dev_feedbacks.blank? && params[:format] # GET
      if params[:format] == 'xml'
        send_data(@dev_feedbacks.to_xml,
        :filename => ('dev_feedbacks.xml'),
        :disposition => 'attachment',
        :type => 'text/xml;charset=utf-8')
        return
      elsif params[:format] == 'xls'
        cols = []
        DevFeedback::FIELDS.each{|k,v|
        cols << k if [:string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
        book = Spreadsheet::Workbook.new
        sheet = book.create_worksheet(:name => "dev_feedbacks")
        sheet.row(0).concat(cols)
        @dev_feedbacks.each_with_index do |row,i|
          sheet.row(i+1).replace(cols.map{|c|
            if [:ho_assoc, :bt_assoc].include?(DevFeedback::FIELDS[c])
              v = row.send(c)
              v ? v.disp_name : ''
            else
              row.send(c)
            end
          })
        end
        fname = "dev_feedbacks.xls"
        tmp = Tempfile.new(fname)
        book.write(tmp.path)
        tmp.close
        send_file(tmp.path, :filename => fname)
        return
      elsif params[:format] == 'csv'
        cols = DevFeedback::FIELDS.inject([]) {|a,v|
        a << v[0] if [:ho_assoc, :bt_assoc, :string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp].include?(v[1]) ; a}
        @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';') }) do |csv|
          csv << cols
          for row in @dev_feedbacks
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(DevFeedback::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
        end
        @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
        conv = Iconv.new(@export_encoding, 'UTF-8')
        send_data(conv.iconv(@csv_string), :filename => "dev_feedbacks.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        return
      end
    end
    if request.xhr? || request.post?
      render :partial => 'result_list' and return
    end
  end


  # Allows download of all or current record in many formats.
  #
  # Author:: Yann Azoury
  # Version:: 46
  # Last Update:: 2013-02-11 07:45:35 UTC
  # Status:: Validation Pending


  def download

    @restricted_fields = []
    @no_menubar	= true
    @no_links	= true
    @no_filterbar	= true
    @no_row_links	= true
    pagin_opts		  = {:include => [:user]}
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= "dev_feedbacks.#{params[:sort_by]}" if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter
    pagin_opts[:joins]	||= @joins_fields || []

    # pagin_opts[:select]	||= "`dev_feedbacks`.`ticket_status`,`dev_feedbacks`.`title`,`dev_feedbacks`.`text`,`dev_feedbacks`.`zone`,`dev_feedbacks`.`url`,`dev_feedbacks`.`controller`,`dev_feedbacks`.`action`,`dev_feedbacks`.`created_at`,`dev_feedbacks`.`ip`,`dev_feedbacks`.`ua`,`dev_feedbacks`.`browser`" unless params[:format] == 'html'

    if params[:id] && params[:id].to_i > 0
      @dev_feedback = DevFeedback.find_by_id(params[:id], pagin_opts)
      if !@dev_feedback
        flash[:warning] = _("Error: %{obj} not found!") % {:obj => _(%q[DevFeedback])}
        begin
          redirect_to :back
        rescue
          redirect_to :action => :list
        end
        return
      end
      f_name = @dev_feedback.disp_name
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/dev_feedbacks/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/dev_feedbacks/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/dev_feedbacks/show.html.erb', :format => :html, :id => @dev_feedback.id, :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "#{@dev_feedback.disp_name}.pdf") unless params[:debug_pdf] || pdf.blank?

          # send_data(render_to_string(:format => :html, :layout => false, :action => :show, :id => @dev_feedback.id), :filename => "#{f_name}.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

          return
        }
        format.xml {
        send_data(@dev_feedback.to_xml, :filename => "#{f_name}.xml", :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.json {
        send_data(@dev_feedback.to_json, :filename => "#{f_name}.json", :disposition => 'attachment', :type => 'text/json;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "dev_feedbacks")
          sheet.row(0).concat(["Ticket Status", "Title", "Text", "Zone", "URL", "Controller", "Action", "Created at", "IP", "UA", "Browser"])
          sheet.row(1).replace([@dev_feedback.ticket_status, @dev_feedback.title, @dev_feedback.text, @dev_feedback.zone, @dev_feedback.url, @dev_feedback.controller, @dev_feedback.action, @dev_feedback.created_at, @dev_feedback.ip, @dev_feedback.ua, @dev_feedback.browser])
          fname = "dev_feedbacks.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv { row = @dev_feedback
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            DevFeedback::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:user].include?(c) }
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(DevFeedback::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "#{f_name}.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
          return
        }
      end
    else
      pagin_opts[:page] = 1
      pagin_opts[:per_page] = DevFeedback.count+1
      @dev_feedbacks = DevFeedback.paginate(pagin_opts)
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/dev_feedbacks/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "dev_feedbacks.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/dev_feedbacks/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "dev_feedbacks.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/dev_feedbacks/list.html.erb', :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "dev_feedbacks.pdf") unless params[:debug_pdf] || pdf.blank?

          #      send_data(render_to_string(:layout => false, :action => :list), :filename => "dev_feedbacks.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

        }
        format.xml {
        send_data(@dev_feedbacks.to_xml, :filename => ('dev_feedbacks.xml'), :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "dev_feedbacks")
          sheet.row(0).concat(["Ticket Status", "Title", "Text", "Zone", "URL", "Controller", "Action", "Created at", "IP", "UA", "Browser"])
          @dev_feedbacks.each_with_index do |row,i|
            sheet.row(i+1).replace([row.ticket_status, row.title, row.text, row.zone, row.url, row.controller, row.action, row.created_at, row.ip, row.ua, row.browser])
          end
          fname = "dev_feedbacks.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv {
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            DevFeedback::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:user].include?(c) }
            csv << cols.map{|c| _(c.titleize)}
            @dev_feedbacks.map{|row|
              csv << cols.map {|c|
                if [:ho_assoc, :bt_assoc].include?(DevFeedback::FIELDS[c])
                  v = row.send(c) ; v ? v.disp_name : nil
                else
                  row.send(c)
                end
              }
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "dev_feedbacks.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        }
      end
    end
  end


  # Exports RSS, XML and ATOM feeds.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 12:11:11 UTC
  # Status:: Validation Pending


  def feed

    @dev_feedbacks = DevFeedback.all(:limit => 50)
    respond_to do |format|
      format.rss {render :template => 'dev_feedbacks/rss', :layout => false}
      format.xml {render :template => 'dev_feedbacks/rss', :layout => false}
      format.html {render :template => 'dev_feedbacks/rss', :layout => false}
      format.atom {render :template => 'dev_feedbacks/atom', :layout => false}
    end
  end


  # Gives help about current module.
  #
  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2012-05-19 23:29:44 UTC
  # Status:: Validation Pending


  def help

    @user_actions = Access.where(:table_sid => "dev_feedbacks", :action_sid => ["index", "list", "new", "create", "show", "edit", "update", "destroy", "search", "download", "feed", "help", "adv_search"]).includes([:user_accesses, :profile_accesses]).reject{|a| @current_user.can_run?(a) }
    render(:layout => !request.xhr?)
  end


  # Make complex queries.
  #
  # Author:: Yann Azoury
  # Version:: 7
  # Last Update:: 2010-05-27 12:12:45 UTC
  # Status:: Validation Pending


  def adv_search

    redirect_to :action => :search
  end
  protected
  private


  # For field user


  def set_user_for_create_8

    @current_user

  end


  # For field ip


  def restrict_ip_for_create_5

    !current_user.is_admin?

  end


  # For field ip


  def restrict_ip_for_show_5

    !current_user.is_admin?

  end


  # For field ip


  def restrict_ip_for_edit_5

    !current_user.is_admin?

  end


  # For field ip


  def restrict_ip_for_update_5

    !current_user.is_admin?

  end


  # For field ip


  def set_ip_for_create_9

    request.remote_ip

  end


  # For field ua


  def restrict_ua_for_create_5

    !current_user.is_admin?

  end


  # For field ua


  def restrict_ua_for_show_5

    !current_user.is_admin?

  end


  # For field ua


  def restrict_ua_for_edit_5

    !current_user.is_admin?

  end


  # For field ua


  def restrict_ua_for_update_5

    !current_user.is_admin?

  end


  # For field ua


  def set_ua_for_create_10

    request.env['HTTP_USER_AGENT']
  end


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1

    ckie = (RUBY_VERSION =~ /^1.8/) ? Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "") :  (cookies[:active_filters] || "").force_encoding(Encoding::ISO_8859_1).encode!(Encoding::UTF_8)
    if !ckie.blank?
      find_hash = DevFeedback.named_scope_active_filter_method(ActiveSupport::JSON.decode(ckie))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      DevFeedback.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_dev_feedbacks_pres_mode"].to_sym unless cookies["#{APP_SID}_dev_feedbacks_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_dev_feedbacks_pres_mode"].to_sym unless params["#{APP_SID}_dev_feedbacks_pres_mode"].blank?
  end

end
