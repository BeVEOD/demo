# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:38:01 +0100 2013
## It should be placed at 'app/controllers/system_settings_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class SystemSettingsController < ApplicationController
  layout 'application_jquery_horizontal'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :create) do
    request.request_method_symbol == :post
  end
  before_filter(:only => :update) do
    request.request_method_symbol == :put
  end
  before_filter(:only => :irbjax) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :run_command) do
    request.request_method_symbol == :get
  end

  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])


  # This gives the list of all records
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-01-29 17:02:44 UTC
  # Status:: Validation Pending


  def list

    @restricted_fields = []
    pagin_opts = {:include => []}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:system_settings_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'system_settings.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @system_settings = SystemSetting.paginate(pagin_opts)
    render(:xml => @system_settings.to_xml(:dasherize => false, :only => [:id,:name,:value])) and return if params[:format] == 'xml'
    render(:json => @system_settings) and return if params[:format] == 'json'
    render(:pdf => @system_settings, :action => :list) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["name"].include?(params[:group_by])
      @system_settings_groups = @system_settings.inject({}) { |acc,elt|
        crit = nil
        if [].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # Loads a new record.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-03-25 18:26:30 UTC
  # Status:: Validation Pending


  def new

    @system_setting_attributes = params[:system_setting] ? params[:system_setting]['0'].clone : {}

    @system_setting = SystemSetting.load_from_params(@system_setting_attributes)

    render(:layout => !request.xhr?)
  end


  # Inserts the record in the database.
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2013-10-31 16:38:41 UTC
  # Status:: Validation Pending


  def create

    redirect_to(:action => :index) and return unless request.post?
    redirect_to(:action => :index) and return if params[:system_setting].blank? || !params[:system_setting].is_a?(Hash)
    @system_setting_attributes = params[:system_setting] ? params[:system_setting]['0'].clone : {}

    @system_setting = SystemSetting.load_from_params(@system_setting_attributes)
    if @system_setting.errors.empty? && @system_setting.save
      flash[:notice] = _("%{page} was successfully created.") % {:page => _("System Setting")}
      if request.xhr? # && params[:format] == 'json'
        render(:json => {:id => @system_setting.id}.merge(@system_setting.attributes).to_json)
        return
      end
    else
      if request.xhr? # && params[:format] == 'json'
        render(:json => ({:errors => @system_setting.errors.full_messages}.merge(@system_setting.attributes)).to_json)
      else
        render(:action => :new)
      end
      return
    end
    if params[:go_to].blank?
      redirect_to :action => (params[:commit_and_new] ? :new : :index)
    else
      redirect_to(params[:go_to])
    end
  end


  # Display the record.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2012-03-26 04:12:53 UTC
  # Status:: Validation Pending


  def show

    @system_setting_attributes = params[:system_setting] ? params[:system_setting][params[:id]].clone : {}
    @system_setting_attributes.merge!(:id => params[:id]) if @system_setting_attributes

    @system_setting = SystemSetting.load_from_params(@system_setting_attributes)
    if @system_setting.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'system_setting', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    respond_to do |format|
      format.html {
      render :layout => !request.xhr? }
      format.pdf {
      render :layout => false }
      format.xml {
      render :xml => @system_setting.to_xml }
      format.json {
      render :json => @system_setting.to_json }
    end
  end


  # Load the data to fill the edit form.
  #
  # Author:: Yann Azoury
  # Version:: 11
  # Last Update:: 2012-03-25 20:53:17 UTC
  # Status:: Validation Pending


  def edit

    @system_setting_attributes = params[:system_setting] ? params[:system_setting][params[:id]].clone : {}
    @system_setting_attributes.merge!(:id => params[:id]) if @system_setting_attributes

    @system_setting = SystemSetting.load_from_params(@system_setting_attributes)
    if @system_setting.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'system_setting', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    render(:layout => !request.xhr?)
  end


  # Updates the current row in database from the sent form.
  #
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2012-12-13 11:53:56 UTC
  # Status:: Validation Pending


  def update

    redirect_to(:action => :index) and return unless request.put?
    redirect_to(:action => :index) and return if params[:system_setting].blank? || !params[:system_setting].is_a?(Hash)
    @system_setting_attributes = params[:system_setting] ? params[:system_setting][params[:id]].clone : {}
    @system_setting_attributes.merge!(:id => params[:id]) if @system_setting_attributes

    @system_setting = SystemSetting.load_from_params(@system_setting_attributes)
    if @system_setting.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'system_setting', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end
    if @system_setting.save
      flash[:notice] = _("%{page} was successfully updated.") % {:page => _("System Setting")}
    else
      if request.xhr?
        render(:json => {:errors =>
        @system_setting.errors.full_messages})
      else
        render(:action => :edit, :id => @system_setting.id)
      end
      return
    end
    render(:json => "OK") and return if request.xhr?
    if params[:system_setting].length == 1 # single edit
      redirect_to :action => :show, :id => @system_setting.id
    else
      redirect_to :action => :index
    end
  end


  # Deletes an object or list of objects from the database.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2011-03-08 15:34:31 UTC
  # Status:: Validation Pending


  def destroy

    if params[:id].is_a?(Array)
      @success = SystemSetting.destroy(params[:id])
    else
      @system_setting = SystemSetting.find_by_id(params[:id])
      @system_setting.destroy unless @system_setting.nil?
      @success = @system_setting && @system_setting.destroyed?
    end
    if @success
      flash[:notice] = _("%{model} %{name} successfully deleted.") % {:model => _("System Setting"), :name => @system_setting.disp_name}
    else
      flash[:warning] = _("%{model} %{name} could not be deleted.") % {:model => _("System Setting"), :name => params[:name]}
    end
    if params[:format] != "json"
      if request.xhr?
        render :action => 'ajax_update', :layout => false
      else
        if params[:go_to].blank?
          redirect_to :action => :index
        else
          redirect_to(params[:go_to])
        end
      end
    else
      resp = {}
      if @success
        resp[:success] = true
      else
        resp[:success] = false
        resp[:error] = flash[:warning]
      end
      render :json => resp.to_json, :layout => false
    end
  end


  # Search and filter data.
  #
  # Author:: Sylvain Abélard
  # Version:: 44
  # Last Update:: 2010-06-15 18:38:22 UTC
  # Status:: Requires Tests


  def search

    @system_setting = SystemSetting.load_from_params(params[:system_setting]["0"]) if params[:system_setting]
    @system_setting ||= SystemSetting.new
    page	   = params[:page].to_i > 0 ? params[:page].to_i : 1
    per_page   = params[:per_page]
    per_page ||= SystemSetting.count if params[:format] && %w(xml xls csv).include?(params[:format])
    per_page   = 50 if !per_page || per_page == 0

    # GET RESULTS FROM SMART_QUERY OR PARAMS

    if params[:system_setting]
      my_p = params[:system_setting]["0"].reject{|k, v|
        params["comp_#{k}"].blank? || (v.blank? && !params["comp_#{k}"].include?('NULL'))
      } if params[:system_setting]["0"]
      @system_settings = SystemSetting.search(my_p, params.reject{|k,v| !k[/comp_/]}, :page => page, :per_page => per_page)
    elsif params[:query]
      @system_settings = SystemSetting.active_filter(ActiveSupport::JSON.decode(params[:query])).paginate(:page => page, :per_page => per_page)
    elsif params[:fts_query]
      l = params[:limit] ? params[:limit] : :all
      @system_settings = SystemSetting.find_with_ferret(params[:fts_query], :limit => l)
    elsif (params[:id] || params[:smart_query])
      if params[:id]
        @smart_query = SmartQuery.find_by_id(params[:id])
      else
        attr = params[:smart_query].first[1] if params[:smart_query].first
        attr[:criteria] = SmartQuery.clean_criteria(attr[:criteria])
        @smart_query = SmartQuery.new(attr)
      end
      @system_settings = SystemSetting.search(@smart_query, :page => page, :per_page => per_page)
    else
      opts = {:include => []}
      opts[:page]		  = page
      opts[:per_page]	  = per_page
      opts[:order]		  = @default_order
      opts[:order]		||= 'system_settings.' +params[:sort_by] if !params[:sort_by].blank?
      opts[:conditions]	||= @default_filter
      opts[:joins] 		||= @joins_fields  || []
      @system_settings = SystemSetting.paginate(opts)
    end

    # RENDER SOMETHING

    if !@system_settings.blank? && params[:format] # GET
      if params[:format] == 'xml'
        send_data(@system_settings.to_xml,
        :filename => ('system_settings.xml'),
        :disposition => 'attachment',
        :type => 'text/xml;charset=utf-8')
        return
      elsif params[:format] == 'xls'
        cols = []
        SystemSetting::FIELDS.each{|k,v|
        cols << k if [:string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
        book = Spreadsheet::Workbook.new
        sheet = book.create_worksheet(:name => "system_settings")
        sheet.row(0).concat(cols)
        @system_settings.each_with_index do |row,i|
          sheet.row(i+1).replace(cols.map{|c|
            if [:ho_assoc, :bt_assoc].include?(SystemSetting::FIELDS[c])
              v = row.send(c)
              v ? v.disp_name : ''
            else
              row.send(c)
            end
          })
        end
        fname = "system_settings.xls"
        tmp = Tempfile.new(fname)
        book.write(tmp.path)
        tmp.close
        send_file(tmp.path, :filename => fname)
        return
      elsif params[:format] == 'csv'
        cols = SystemSetting::FIELDS.inject([]) {|a,v|
        a << v[0] if [:ho_assoc, :bt_assoc, :string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp].include?(v[1]) ; a}
        @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';') }) do |csv|
          csv << cols
          for row in @system_settings
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(SystemSetting::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
        end
        @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
        conv = Iconv.new(@export_encoding, 'UTF-8')
        send_data(conv.iconv(@csv_string), :filename => "system_settings.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        return
      end
    end
    if request.xhr? || request.post?
      render :partial => 'result_list' and return
    end
  end


  # Allows download of all or current record in many formats.
  #
  # Author:: Yann Azoury
  # Version:: 46
  # Last Update:: 2013-02-11 07:45:35 UTC
  # Status:: Validation Pending


  def download

    @restricted_fields = []
    @no_menubar	= true
    @no_links	= true
    @no_filterbar	= true
    @no_row_links	= true
    pagin_opts		  = {:include => []}
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= "system_settings.#{params[:sort_by]}" if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter
    pagin_opts[:joins]	||= @joins_fields || []

    # pagin_opts[:select]	||= "`system_settings`.`name`,`system_settings`.`value`" unless params[:format] == 'html'

    if params[:id] && params[:id].to_i > 0
      @system_setting = SystemSetting.find_by_id(params[:id], pagin_opts)
      if !@system_setting
        flash[:warning] = _("Error: %{obj} not found!") % {:obj => _(%q[SystemSetting])}
        begin
          redirect_to :back
        rescue
          redirect_to :action => :list
        end
        return
      end
      f_name = @system_setting.disp_name
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/system_settings/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/system_settings/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/system_settings/show.html.erb', :format => :html, :id => @system_setting.id, :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "#{@system_setting.disp_name}.pdf") unless params[:debug_pdf] || pdf.blank?

          # send_data(render_to_string(:format => :html, :layout => false, :action => :show, :id => @system_setting.id), :filename => "#{f_name}.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

          return
        }
        format.xml {
        send_data(@system_setting.to_xml, :filename => "#{f_name}.xml", :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.json {
        send_data(@system_setting.to_json, :filename => "#{f_name}.json", :disposition => 'attachment', :type => 'text/json;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "system_settings")
          sheet.row(0).concat(["Name", "Value"])
          sheet.row(1).replace([@system_setting.name, @system_setting.value])
          fname = "system_settings.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv { row = @system_setting
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            SystemSetting::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [].include?(c) }
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(SystemSetting::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "#{f_name}.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
          return
        }
      end
    else
      pagin_opts[:page] = 1
      pagin_opts[:per_page] = SystemSetting.count+1
      @system_settings = SystemSetting.paginate(pagin_opts)
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/system_settings/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "system_settings.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/system_settings/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "system_settings.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/system_settings/list.html.erb', :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "system_settings.pdf") unless params[:debug_pdf] || pdf.blank?

          #      send_data(render_to_string(:layout => false, :action => :list), :filename => "system_settings.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

        }
        format.xml {
        send_data(@system_settings.to_xml, :filename => ('system_settings.xml'), :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "system_settings")
          sheet.row(0).concat(["Name", "Value"])
          @system_settings.each_with_index do |row,i|
            sheet.row(i+1).replace([row.name, row.value])
          end
          fname = "system_settings.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv {
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            SystemSetting::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [].include?(c) }
            csv << cols.map{|c| _(c.titleize)}
            @system_settings.map{|row|
              csv << cols.map {|c|
                if [:ho_assoc, :bt_assoc].include?(SystemSetting::FIELDS[c])
                  v = row.send(c) ; v ? v.disp_name : nil
                else
                  row.send(c)
                end
              }
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "system_settings.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        }
      end
    end
  end


  # Exports RSS, XML and ATOM feeds.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 12:11:11 UTC
  # Status:: Validation Pending


  def feed

    @system_settings = SystemSetting.all(:limit => 50)
    respond_to do |format|
      format.rss {render :template => 'system_settings/rss', :layout => false}
      format.xml {render :template => 'system_settings/rss', :layout => false}
      format.html {render :template => 'system_settings/rss', :layout => false}
      format.atom {render :template => 'system_settings/atom', :layout => false}
    end
  end


  # Gives help about current module.
  #
  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2012-05-19 23:29:44 UTC
  # Status:: Validation Pending


  def help

    @user_actions = Access.where(:table_sid => "system_settings", :action_sid => ["list", "new", "create", "show", "edit", "update", "destroy", "search", "download", "feed", "help", "adv_search", "index", "dev_doc", "gen_doc", "routes", "page_icons", "file_icons", "monitoring", "requests_times", "list_logs", "clear_logs", "reload", "public_files", "node_details", "dependency_graph", "upload_form", "console", "sql_console", "download_zip", "irbjax", "run_command"]).includes([:user_accesses, :profile_accesses]).reject{|a| @current_user.can_run?(a) }
    render(:layout => !request.xhr?)
  end


  # Make complex queries.
  #
  # Author:: Yann Azoury
  # Version:: 7
  # Last Update:: 2010-05-27 12:12:45 UTC
  # Status:: Validation Pending


  def adv_search

    redirect_to :action => :search
  end


  # Default controller action.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2009-11-24 14:11:55 UTC
  # Status:: Validation Pending


  def index

    @importers = Access.all(:conditions => {:action_sid => 'importer'}, :group => :table_sid, :select => :table_sid)
    @exporters = Access.all(:conditions => {:action_sid => 'search'}, :group => :table_sid, :select => :table_sid)
    @db_tables = Access.all(:conditions => {:action_sid => 'db_table'}, :group => :table_sid, :select => :table_sid)
  end


  # Reading development documentation.
  #
  # Author:: Yann Azoury
  # Version:: 1
  # Last Update:: 2011-09-06 00:51:02 UTC
  # Status:: Validation Pending


  def dev_doc

    @doc_path = Rails.root.join('doc', 'app', 'index.html')
    @doc_update = File.exists?(@doc_path) ? File.stat(@doc_path).mtime : nil
    if @doc_update
      @path = params[:path]
      @path ||= 'index.html' if File.exists?(@doc_path)
      @path.gsub!(/\.\.\//, '')
      @path.gsub!(/\A\.*\/*/, '')
      @file_path = Rails.root.join('doc', 'app', @path)
      @file_path = @doc_path if !File.exists?(@file_path)
      @doc = IO.read(@file_path)
      render :layout => false
    end
  end


  # Automatically creating developer documentation.
  #
  # Author:: Sylvain Abélard
  # Version:: 7
  # Last Update:: 2010-06-16 14:18:02 UTC
  # Status:: Validation Pending


  def gen_doc


    # IO.popen('rake doc:reapp template=/usr/lib/ruby/gems/1.8/gems/allison-2.0.3/lib/allison.rb')

    IO.popen('rake doc:reapp')
    flash[:notice] = _("Generating Documentation")
    redirect_to(:action => :dev_doc)
  end


  # Administration: listing routes.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-04-05 16:56:29 UTC
  # Status:: Validation Pending


  def routes

    named_routes = ActionDispatch::Routing::Routes.named_routes.routes
    @routes = ActionDispatch::Routing::Routes.routes.collect do |route|
      name = named_routes.index(route).to_s
      verb = route.conditions[:method].to_s.upcase
      segs = "/" + route.segment_keys.map{|k| ":#{k}" }.join("/")
      reqs = route.requirements.empty? ? "" : route.requirements.inspect
      {:name => name, :verb => verb, :segs => segs, :reqs => reqs}
    end
  end


  # External web service for MaVeoCs' icon management.
  #
  # Author:: Yann Azoury
  # Version:: 15
  # Last Update:: 2012-02-28 15:12:58 UTC
  # Status:: Requires Tests


  def page_icons

    @page_icons = Dir[File.join(Rails.public_path, 'images', 'page_icons', '*')].reject{|f|
      (f =~ /_(error|link|add|delete|go|edit)\./i) || (f !~ /\.(png|gif|jpg)\Z/i)
    }.map{|f| f[/\/images.*\Z/]}.sort
    respond_to do |wants|
      wants.html
      wants.xml {
        @xml = ""
        xml = Builder::XmlMarkup.new(:target => @xml)
        xml.instruct!
        @page_icons.each{ |p|
          xml.url(p)
        }
      render :xml => @xml }
    end
  end


  # Author:: Yann Azoury
  # Version:: 3
  # Last Update:: 2012-04-22 01:49:58 UTC
  # Status:: Validation Pending


  def file_icons

    @file_icons = Dir[Rails.public_path.join('images', 'file_icons', '*')].reject{|f|
      (f =~ /_(error|link|add|delete|go|edit)\.png/i) || !(f =~ /\.(png|gif|jpg)$/i)
    }.map{|f| f[/\/images.*$/]}.sort
    respond_to do |wants|
      wants.html
      wants.xml { render :xml => @file_icons.inject({}) {|acc,elt| acc.merge(:url => elt) }.to_xml }
    end
  end


  # Gives some information about current running application.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2009-07-22 16:19:10 UTC
  # Status:: Validation Pending


  def monitoring

    @table_nb = Access.tables.count
    @field_nb = Access.fields.count
    @action_nb = Access.actions.count
    @gems = Gem.loaded_specs.map{|n,spec| spec }.sort{|x,y| -(x.dependencies.length <=> y.dependencies.length) }
  end


  # Administration: request times' dashboard.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-02-27 11:10:42 UTC
  # Status:: Validation Pending


  def requests_times

    rnd2 = lambda {|x| (x.to_f * 100).round.to_f / 100}
    @lines = params[:lines] ? params[:lines].to_i : 100000
    @top = params[:top] ? params[:top].to_i : 50
    @log_file = params[:log_file] ? params[:log_file][/[a-z]*/] : Rails.env
    @log_file_path = Rails.root.join("log", "#{@log_file}.log")
    if RUBY_PLATFORM[/windows/i]
      @logs = []
      File::Tail::Logfile.open(@log_file_path, :backward => @lines) do |log|
        log.tail(@lines) {|l| @logs << l if (/\ACompleted in/ =~ l) }
      end
      @logs = @logs.map {|l| l = l.split(' ');
      [rnd2.call(l[2]), rnd2.call(l[7]), rnd2.call(l[11]), 0, l[16]]}
      @logs = @logs.sort {|x,y| y[0] <=> x[0]}[0, @top]
      @logs = @logs.map {|x|
        x[3] = x[0] - x[1] - x[2]
        x[4] = x[4].blank? ? '' : x[4].sub(/\[.+:\/\/([a-z0-9._-])+\/(.*)\]/, '/\2')
        x
      }
    else
      if RAILS_GEM_VERSION < '2.2'
        IO.popen(%{tail -n #{@lines} "#{@log_file_path}" | awk '/^Completed\ in/ { print $3 " " $8 " " $12 " " $17 }' | sort -nr | head -n #{@top}}) { |t|
          @logs = t.readlines
        }
      else
        if @log_file == 'production'
          IO.popen(%{tail -n #{@lines} "#{@log_file_path}" | awk '/^Completed\ in/ { print $3 " " $5 " " $7 " " $11 }' | sed s/ms/\/ | tr -d ',)[]' | sort -nr | head -n #{@top}}) { |t|
            @logs = t.readlines
          }
        else
          IO.popen(%{tail -n #{@lines} "#{@log_file_path}" | echo `grep -B 1 Completed | grep -A 1 Rendered | sed -e "s/^Rendered [^\\S]\\+ (\\(.*\\)ms)$/\\1/g" | sed -e "s/Completed in \\([^\\S]\\+\\)ms (View: [^\\S]\\+, DB: \\([^\\S]\\+\\)) | .* \\(\\[.*\\]\\)/\\1 \\2 \\3/g"` | sed -e "s/ -- /\\\\n/g" | sort -nrk 2 | head -n #{@top}}) { |t|
            @logs = t.readlines
          }
        end
      end
      @logs.each_with_index { |l, i|
        d = l.split(' ')
        if RAILS_GEM_VERSION < '2.2'
          d0 = rnd2.call(d[0])
          d1 = rnd2.call(d[1])
        elsif @log_file == 'production'
          d0 = d[0].to_i
          d1 = d[1].to_i
        else
          d1 = rnd2.call(d[0])
          d0 = rnd2.call(d[1])
        end
        d2 = rnd2.call(d[2])
        d3 = d[3].blank? ? '' : d[3].sub(/\[.+:\/\/([a-z0-9._-])+\/(.*)\]/, '/\2')
        @logs[i] = [d0, d1, d2, rnd2.call(d0 - d1 - d2), d3]
      }
    end
  end


  # Administration: logs from the last requests.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2013-02-27 11:05:29 UTC
  # Status:: Validation Pending


  def list_logs

    @lines = params[:lines] ? params[:lines].to_i : 20000
    @lines = 10000 if @lines > 20000
    @top = params[:top] ? params[:top].to_i : 20
    @top = 100 if @top > 100
    @show_sql = params[:show_sql] == 'true'
    @log_file = params[:log_file] ? params[:log_file][/[a-z]*/] : Rails.env
    @log_file = Rails.root.join('log', "#{@log_file}.log")
    @log_file_size = File.exists?(@log_file) ? File.size(@log_file) : 0
    raw_logs = nil
    if RUBY_PLATFORM[/windows/i]
      raw_logs = File::Tail::Logfile.open(@log_file, :backward => @lines) do |log|
        log.tail(@lines)
      end
    else
      IO.popen(%Q[tail -n #{@lines} "#{@log_file}" ]) { |tt|
        raw_logs = tt.readlines
      }
    end
    @logs = []
    @sess = []
    @current = nil
    @sess_id = nil
    raw_logs.each do |l|
      if @current
        @current << l if @show_sql || !(l =~ /\e\[/)
        @sess_id = l.sub(/\A  Session ID: /, '').chop if @sess_id.nil? && l[/\A  Session ID: /]
        if l =~ /\ACompleted/
          @logs << @current.clone
          if RAILS_GEM_VERSION < '2.3.2' && @sess_id
            @sess << @sess_id.clone
          end
          @sess_id = @current = nil
        end
      else
        if l =~ /\A#{RAILS_GEM_VERSION > '3.0' ? 'Started' : 'Processing'}/
          @current = [l]
        end
      end
    end
    @logs = @logs.last(@top)
    @sess = @sess.last(@top).reverse

    #logger.debug("SESSIONS: #{@sess.inspect}")

    @users = User.active.all(:conditions => {:last_session_id => @sess.uniq})
    colors = %w(Aquamarine Bisque Chocolate DarkGray DarkKhaki Gainsboro GreenYellow Lavender LemonChiffon LightBlue LightGoldenRodYellow LightSteelBlue LightSkyBlue PapayaWhip SandyBrown Wheat WhiteSmoke)
    @sess_h = {}; @users.map(&:last_session_id).each{|s| @sess_h[s] = colors[@sess_h.length]}
  end


  # Administration: clear logs files.
  #
  # Author:: Sylvain Abélard
  # Version:: 3
  # Last Update:: 2010-06-16 12:37:33 UTC
  # Status:: Requires Tests


  def clear_logs

    if request.post?

      # @closed_logs = []

      Dir[File.join("log", "*.log")].each do |log_file|

        # @closed_logs << log_file

        f = File.open(log_file, "w")
        f.close
      end
      flash[:notice] = _("Log cleared")

      # flash[:notice] = _("Logs cleared: %{logs}") % {:logs => @closed_logs.to_sentence}

    end
    redirect_to(:action => :list_logs)
  end


  # Reload or restart Application
  #
  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2010-10-24 22:33:00 UTC
  # Status:: Validation Pending


  def reload

    if params[:force]
      msg = params[:force] == 'true' ? "Restarted by #{current_user.login} at #{Time.now}" : params[:force]
      File.open(Rails.root.join('tmp', 'restart.txt'), 'w') {|f| f.write(msg) }
    elsif !params[:only_routes]

      #  reload_application

      ::ActionController::Routing::Routes.reload!
      Dispatcher.cleanup_application
      Dispatcher.reload_application
    else
      ::ActionController::Routing::Routes.reload!
    end
    redirect_to :controller => :system_settings
  end


  # Administration: displays public files in JS Tree Manager.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2013-09-13 18:52:07 UTC
  # Status:: Requires Tests


  def public_files

    if params[:cmd] == 'get'
      valid_path = check_file_path(File.join(Rails.public_path, params[:path].to_s))
      if valid_path
        root = File.join(@path, '*')

        # This part is also call in the view

        type_with_icon = []
        path_folder_icon = File.join(Rails.public_path, "images", "file_icons16x16")
        Dir.entries(path_folder_icon).map{|f|
          type_with_icon << File.basename(f, ".png") if f != "." && f != ".."
        }
        @files = Dir[root].sort.map{|f|
          lstat = File.lstat(f)
          type = MIME::Types.type_for(f).first.try(:sub_type)
          type = "txt" if type == "plain"
          type = "unknown" if !type_with_icon.include?(type)
          hash = {
            :data     => File.basename(f),
            :attr     => { :rel => (lstat.directory? ? "folder" : (lstat.symlink? ? "link" : type))},
            :metadata => { :id => f.sub(Rails.public_path, ""), :name => File.basename(f) },
            :icon     => (File.directory?(f) ? "folder" : "file")
          }
          if lstat.symlink?
            hash[:attr][:link] = File.readlink(f).blank? ? "" : File.readlink(f)
          elsif lstat.directory?
            hash[:state] = "closed"
            nbchild_and_size_tab = SystemSetting.contents_folder(f)
            nbchild_and_size_tab[2] = view_context.try(:number_to_human_size, nbchild_and_size_tab[2],
            :precision => 2, :separator => '.')
            hash[:attr][:nbchild_and_size] = nbchild_and_size_tab
          else
            hash[:attr][:size] = view_context.try(:number_to_human_size, File.size(f),
            :precision => 2, :separator => '.') if File.exists?(f)
          end
          hash
        }
        render :json => @files.to_json
        return
      else
        render :json => { :success => false, :error => _("Cannot access the path %{path}") % {:path => @path} }
        return
      end
    elsif request.post?
      case params[:cmd]
      when 'rename'
        newpath = File.join(Rails.public_path, params[:newname])
        oldpath = File.join(Rails.public_path, params[:oldname])
        if check_file_path(oldpath) && !check_file_path(newpath)
          FileUtils.mv(oldpath, newpath)
          render :json => {:success => true}
          return
        else
          render :json => {:success => false, :error => _("Cannot rename file: %{oldpath} to %{newpath}") %
          {:oldpath => oldpath, :newpath => newpath} }
          return
        end
      when 'newdir'
        if check_file_path(File.join(Rails.public_path, params[:dir])) ? false : Dir.mkdir(@path)
          render :json => {:success => true}
          return
        else
          render :json => {:success => false, :error => _("Cannot create directory: %{path}") % {:path => @path} }
          return
        end
      when 'delete'
        if check_file_path(File.join(Rails.public_path, params[:file]))
          File.stat(@path).directory? ? Dir.delete(@path) : File.delete(@path)
          render :json => {:success => true}
          return
        else
          render :json => {:success => false, :error => _("Cannot delete: %{path}") % {:path => @path} }
          return
        end
      when 'unzip'
        zip  = File.join(Rails.public_path, params[:zip])
        dest = File.join(Rails.public_path, params[:dest])
        if check_file_path(zip)
          render :json => SystemSetting.unzip_file(zip, dest)
          return
        else
          render :json => {:success => false, :error => _("Cannot acces: %{zip} or %{dest}") % {:zip=> zip, :dest=> dest} }
          return
        end
      when 'zip'
        if check_file_path(File.join(Rails.public_path, params[:path]))
          render :json => SystemSetting.zip_file(params[:folder], @path)
          return
        else
          render :json => {:success => false, :error => _("Cannot acces: %{path}") % {:path=> @path} }
          return
        end
      when 'preview'
        path = File.join(Rails.public_path, params[:path])
        text_preview = ''
        if check_file_path(path)
          File.open(@path, "r"){|file|

            #conv = Iconv.new('UTF-8', 'UTF-8')

            10.times{

              #text_preview = conv.iconv(line)

              text_preview << "#{file.gets}<br/>"
            }
          }
        end
        render :text => text_preview, :layout => false
        return
      when 'upload'
        if check_file_path(File.join(Rails.public_path, params[:path]))
          return_data = {:success => true}
          v = params[:form]
          if !v.blank? && check_file_path(@path)
            file = File.join(@path, v[:file].original_filename)
            if File.exist?(file)
              return_data[:success] = false
              return_data[:errors]  = {:form => _("File %{file} already exists") % {:file => file.sub(@path, '')} }
            else
              begin
                File.open(file, "wb") {|f| f.write(v[:file].read) }
              rescue
                return_data[:success] = false
                return_data[:errors]  = {:form => _("File %{file} can't be uploaded") % {:file => file.sub(@path, '')} }
              end
            end
          end
          render :action => 'upload_form', :layout => false
          return
        else
          render :json => {:success => false, :error => _("Cannot upload in the directory: %{path}") % {:path => @path} }
          return
        end
      else
        render :json => {:error => _("Command unknown '%{cmd}'") % {:cmd => params[:cmd]} }
        return
      end
    end
    render :layout => 'application_jquery'
  end


  # Administration: file tree: displays details about selected file.
  #
  # Author:: Yann Azoury
  # Version:: 5
  # Last Update:: 2012-04-05 16:50:11 UTC
  # Status:: Validation Pending


  def node_details

    render(:nothing => true) and return unless check_file_path(params[:id])
    @stats = File::Stat.new(@path)

    # make preview

    extension = File.extname(@rel_path).sub('.','')
    mime = MIME::Types.type_for(extension)
    if mime.first.nil? || mime.first.media_type != 'image'
      if File.exists? File.join(Rails.public_path, 'images', 'file_icons', "#{extension}.png")
        @preview_src = "/images/file_icons/#{extension}.png"
      else
        @preview_src = "/images/file_icons/defaut.png"
      end
    else
      @preview_src = @rel_path
    end
    render(:layout => !request.xhr?)
  end


  # Generates and send the dependency image (Linux only)
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-04-22 01:53:40 UTC
  # Status:: Validation Pending


  def dependency_graph

    @gems = Gem.loaded_specs.map{|n,spec| spec }.sort{|x,y| -(x.dependencies.length <=> y.dependencies.length) }
    dest_file = Rails.root.join('tmp', "dependency_graph.png")

    #gv = IO.popen("/usr/bin/dot -q -Tpng", "w+")
    #gv.puts(render_to_string(:partial => '/system_settings/dependency_graph.dot', :layout => false))
    #gv.close_write
    #send_data(gv.read, :filename => "dependency_graph.#{params[:format] || 'png'}", :disposition => 'inline')
    #gv.close

    @graph = render_graph('system_settings/dependency_graph.dot', params[:format] || 'png', 'dot')
    send_data(@graph, :filename => "dependency_graph.#{params[:format] || 'png'}", :disposition => 'inline')
  end


  # Mininal layout is used to get HTML tags and headers, so IE knows it should interpret HTML and not simply render text
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-03-16 18:59:51 UTC
  # Status:: Validation Pending


  def upload_form

    render :layout => 'minimal'
  end


  # Author:: Yann Azoury
  # Version:: 3
  # Last Update:: 2012-05-29 15:55:30 UTC
  # Status:: In Progress


  def console

    @system_setting = SystemSetting.new
    if(request.post?)
      @code = params[:code]
      @result = eval(params[:code])
    end
  end


  # Author:: Nicolas Couturier
  # Version:: 10
  # Last Update:: 2013-03-22 11:48:40 UTC
  # Status:: Requires Tests


  def sql_console

    if request.post?
      client = ActiveRecord::Base.connection
      begin
        case client.adapter_name
        when "Mysql"
          result = client.execute(params[:query])
          return render :json => nil if result.nil?
          rows = []
          result.each { |row| rows.push row.to_a }
          render :json => {:columns => result.fetch_fields.map { |field| field.name }, :rows => rows}
        when "Mysql2"
          result = client.execute(params[:query])
          return render :json => nil if result.nil?
          render :json => {:columns => result.fields, :rows => result.each(:as => :array)}
        when "Postgresql"
          result = client.execute(params[:query])
          return render :json => nil if result.nil?
          render :json => {:columns => result.columns, :rows => result.rows}
        end
      rescue => e
        render :json => e.message, :status => 500
      end
    end
  end


  # Create and send code archive.
  #
  # Author:: Nicolas Couturier
  # Version:: 10
  # Last Update:: 2013-03-01 18:17:34 UTC
  # Status:: Requires Tests


  def download_zip

    require 'rake'
    file = Rails.root.join('tmp', "#{APP_SID}_#{Date.today}.zip")
    File.delete(file) if File.exists?(file)
    Rake::Task.clear
    Rails.application.load_tasks
    Rake::Task['create_archive'].reenable
    Rake::Task['create_archive'].invoke
    send_file(file)
  end


  # Author:: Sylvain Abélard
  # Version:: 2
  # Last Update:: 2013-03-21 17:34:57 UTC
  # Status:: In Progress


  def irbjax

  end


  # Author:: Nicolas Couturier
  # Version:: 2
  # Last Update:: 2013-02-26 18:10:58 UTC
  # Status:: In Progress


  def run_command

    require Rails.root.join("lib", "filesystem")
    require Rails.root.join("lib", "shell")
    irbjax_session ||= IrbjaxEngine::IrbjaxSession.new(session)
    IrbjaxEngine.session = irbjax_session.session
    output = IrbjaxEngine.run_line(params[:cmd])
    render :json => { "output" => output.format, "result" => "Success!" }
  end
  protected


  # Checking file path.
  #
  # Author:: Ali Krikeb
  # Version:: 11
  # Last Update:: 2012-02-28 10:01:21 UTC
  # Status:: Validation Pending


  def check_file_path(path)
    ret = {}
    ret[:path] = path.to_s[/\A\//] ? File.expand_path(path.to_s) : File.expand_path(path.to_s, Rails.root)
    @path ||= ret[:path]
    public_root = File.expand_path(Rails.public_path)
    ret[:rel_path] = ret[:path].sub(public_root, '')
    @rel_path ||= ret[:rel_path]
    return ret[:path] if File.exists?(File.join(public_root, ret[:rel_path]))
    return false
  end
  private


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1

    ckie = (RUBY_VERSION =~ /^1.8/) ? Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "") :  (cookies[:active_filters] || "").force_encoding(Encoding::ISO_8859_1).encode!(Encoding::UTF_8)
    if !ckie.blank?
      find_hash = SystemSetting.named_scope_active_filter_method(ActiveSupport::JSON.decode(ckie))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      SystemSetting.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_system_settings_pres_mode"].to_sym unless cookies["#{APP_SID}_system_settings_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_system_settings_pres_mode"].to_sym unless params["#{APP_SID}_system_settings_pres_mode"].blank?
  end

end
