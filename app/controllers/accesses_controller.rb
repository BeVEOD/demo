# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:40:24 +0100 2013
## It should be placed at 'app/controllers/accesses_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class AccessesController < ApplicationController
  layout 'application_jquery_horizontal'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end


  # AJAX association management.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2011-06-23 17:57:01 UTC
  # Status:: Requires Tests


  def linker

    render(:text => _('AJAX only')) and return if !request.xhr?
    render(:text => _('Missing required parameter')) and return if params[:id].blank? || params[:sid].blank?
    params[:page] = 1 if params[:page].to_i == 0
    params[:per_page] = 15 if params[:per_page].to_i == 0
    @access   = Access.find_by_id(params[:id])
    @access ||= Access.new
    case params[:sid].to_sym
    when :home_page_profiles
      val = params["home_page_profile"] ? params["home_page_profile"]["0"] : {}
      @home_page_profiles = Profile.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/profiles/list_for_linker', :locals => {:assoc_sid => :home_page, :assoc_type => :has_many}
    when :user_accesses
      val = params["user_access"] ? params["user_access"]["0"] : {}
      @user_accesses = UserAccess.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/user_accesses/list_for_linker', :locals => {:assoc_sid => :access, :assoc_type => :has_many}
    when :profile_accesses
      val = params["profile_access"] ? params["profile_access"]["0"] : {}
      @profile_accesses = ProfileAccess.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/profile_accesses/list_for_linker', :locals => {:assoc_sid => :access, :assoc_type => :has_many}
    when :users
      val = params["user"] ? params["user"]["0"] : {}
      @users = User.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/users/list_for_linker', :locals => {:assoc_sid => :accesses, :assoc_type => :has_many_through}
    when :profiles
      val = params["profile"] ? params["profile"]["0"] : {}
      @profiles = Profile.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/profiles/list_for_linker', :locals => {:assoc_sid => :accesses, :assoc_type => :has_many_through}
    end
  end


  # Reporting: displays preset reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 19:23:13 UTC
  # Status:: Requires Tests


  def report_chooser

    @data_sets = SmartQuery.all(:conditions => {:table_sid => ['accesses', '']})
    m_par = params[:accesses] || {}
    @data_set = SmartQuery.find_by_id(m_par[:data_set]) || @data_sets.first
    logger.debug("m_par #{m_par.inspect}")
  end


  # Reporting: global steps to rendering reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:24:32 UTC
  # Status:: Could be optimized


  def report_generate

    report_check_params

    #logger.debug("BEGIN report_load_labels")

    report_load_labels

    #logger.debug("END report_load_labels")
    #logger.debug("BEGIN report_load_datasets")

    report_load_datasets

    #logger.debug("END report_load_datasets")
    #logger.debug("BEGIN report_load_title")

    report_load_title

    #logger.debug("END report_load_title")

    respond_to do |format|
      format.html {report_convert_to_html}
      format.json {report_convert_to_ofc}

      #  format.pdf {report_convert_to_pdf }

    end
  end


  # Reporting: checks sent params for security and consistency.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:23:42 UTC
  # Status:: Could be optimized


  def report_check_params


    # logger.debug("BEGIN report_check_params")

    @report_type = params[:format] == 'html' ? :table : :chart
    @x_type = Access::FIELDS[params[:x_field]]
    render(:text => "No correct x_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@x_type)

    # logger.debug("\t\t x_field: #{params[:x_field]} (#{@x_type})")

    if params[:y_field]
      @y_type = Access::FIELDS[params[:y_field]]
      render(:text => "No correct y_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@y_type)
    end
    render(:text => "No correct serie parameter") and return if params[:serie_1].blank? || !params[:serie_1].is_a?(Hash) || (params[:serie_1][:field].blank? && params[:serie_1][:operation].blank?)
    f = params["serie_1"][:field] ||= 'id'
    o = params["serie_1"][:operation] ||= [:integer, :float, :double].include?(Access::FIELDS[params["serie_1"][:field]]) ? :value : :count

    # TODO manage field is a model_method

    render(:text => "No correct serie[:field] parameter") and return if !Access::FIELDS.has_key?(f) && (o != 'count')
    render(:text => "No correct serie[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(Access::FIELDS[f]) && params[:serie_1][:operation].blank?)
    (2..5).each {|i|
      break if params["serie_#{i}"].blank? || !params["serie_#{i}"].is_a?(Hash)
      f = params["serie_#{i}"][:field]
      render(:text => "No correct serie_#{i}[:field] parameter") and return if f.blank? || !Access::FIELDS.has_key?(f)
      render(:text => "No correct serie_#{i}[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(Access::FIELDS[f]) && params["serie_#{i}"][:operation].blank?)
    }
    @x_field = params[:x_field]
    @y_field = params[:y_field] unless params[:y_field].blank?

    # logger.debug("END report_check_params")

  end


  # Reporting: extracts labels and categories to display axes.
  #
  # Author:: Yann Azoury
  # Version:: 6
  # Last Update:: 2011-01-22 17:12:57 UTC
  # Status:: Could be optimized


  def report_load_labels

    case @x_type
    when :string
      return @x_labels = Access.all(:select => "DISTINCT(`#{@x_field}`)").map{|r| r.send(@x_field)}
    when :static_list
      return @x_labels = Access.const_get(@x_field.pluralize.upcase)
    when :bt_assoc
      return @x_labels = Access.reflect_on_association(@x_field.to_sym).klass.all
    end
    @x_range = if params[:x_range] # range is given
      case @x_type
      when :integer
        params[:x_range].split('..').map(&:to_i)
      when :float, :double
        params[:x_range].split('..').map(&:to_f)
      when :date, :datetime
        rg = params[:x_range].split('..').map(&:to_i)
        @x_min = Time.now + rg.first.days
        @x_max = Time.now + rg.last.days
        rg
      end
    else
      @x_min = Access.minimum(@x_field)
      @x_max = Access.maximum(@x_field)
      case @x_type
      when :integer, :float, :double
      when :date, :datetime
        [((@x_min - Time.now) / 86400).round, ((@x_max - Time.now) / 86400).round]
      end
    end
    if true
      case @x_type
      when :integer, :float, :double
        @x_min, @x_max = @x_range
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10.0
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
        @x_labels = [@x_min]
        while(@x_labels.last <= @x_max) do
          @x_labels << @x_labels.last + @x_steps
        end
      when :date, :datetime
        @x_steps = case params[:x_steps]
        when "month"
          30
        when "week"
          7
        else
          if !params[:x_steps] || params[:x_steps].to_i == 0
            (@x_range.last - @x_range.first).round / 10.0
          else
            params[:x_steps].to_i
          end
        end
        @x_steps = 1 if @x_steps == 0
        @x_min ||= Time.now + @x_range.first.days
        @x_max ||= Time.now + @x_range.last.days
        @x_labels = [@x_min]
        logger.debug("\t (#{@x_min})..(#{@x_max}) - #{@x_steps} days step")
        200.times {
          break if @x_labels.last > @x_max
          @x_labels << @x_labels.last + @x_steps.days
        }
      end
    else  # no params[:x_range] => need to guess range
      case @x_type
      when :integer, :float, :double
        @datasets.each_with_index { |h,i|
          d = h[:values]
          if !@x_min
            @x_min = d.min
          else
            d_min = d.min
            @x_min = d_min if d_min < @x_min
          end
          if !@x_max
            @x_max = d.max
          else
            d_max = d.max
            @x_max = d_max if d_max > @x_max
          end
        }
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
      end
      case @x_type
      when :integer, :float, :double
        if params[:x_ticks]
        end
      when :static_list
      when :date, :datetime
      end
    end
  end


  # Reporting: loads datasets.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:20:49 UTC
  # Status:: Could be optimized


  def report_load_datasets

    @datasets = []
    i = 1
    if @y_field
      case @y_type
      when :string
        @y_labels = Access.all(:select => Access.connection.distinct(@y_field, nil)).map{|r| r.send(@y_field)}
      when :static_list
        @y_labels = Access.const_get(@y_field.pluralize.upcase)
      when :ho_assoc, :bt_assoc, :habtm_assoc
        @y_labels = Access.all(:include => @y_field).map{|r| r.send(@y_field)}
      end
      while(params["serie_#{i}"]) do
        ds = {}
        @y_labels.each_with_index { |l,idx|
          next if l.nil?
          case @y_type
          when :string
            ds["values_for_#{l}"] = Access.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => l}, :data_set => @data_set)
          when :static_list
            ds["values_for_#{l}"] = Access.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => (@y_labels.index(l)+1)}, :data_set => @data_set)
          when :bt_assoc
            fk = Access.reflect_on_association(@y_field.to_sym).primary_key_name

            #        Access.send(:with_scope, :find => {:conditions => {fk => l.id}}) {
            #        ds["values_for_#{l.id}"] = report_retrieve_data(params["serie_#{i}"][:operation].to_s, params["serie_#{i}"][:field])

            ds["values_for_#{l.id}"] = Access.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {fk => l.id}, :data_set => @data_set)

            #        }

          end
        }
        i += 1 ; @datasets << ds
      end
      return
    end
    while(params["serie_#{i}"]) do
      ds = {:values => Access.report_calculation(params["serie_#{i}"][:operation],
        params["serie_#{i}"][:field],
      :group => @x_field, :labels => @x_labels, :data_set => @data_set)}
      ds[:type] = params["serie_#{i}"][:type] || 'bar'
      @y_min = 0
      y_min = ds[:values].min || 0
      @y_min = y_min if y_min < @y_min
      if !@y_max
        @y_max = ds[:values].max || 0
      else
        y_max = ds[:values].max || 0
        @y_max = y_max if y_max > @y_max
      end
      i += 1 ; @datasets << ds
    end
    case @y_max
    when 0...5 then @y_max = 5 ; @y_step = 1
    when 5..10 then @y_max = 10 ; @y_step = 1
    when 10..50 then @y_max = 50 ; @y_step = 5
    when 50..100 then @y_max = 100 ; @y_step = 10
    when 100..500 then @y_max = 500 ; @y_step = 50
    when 500..1000 then @y_max = 1000 ; @y_step = 50
    when 1000..5000 then @y_max = 5000 ; @y_step = 100
    end
  end


  # Reporting: displays selected title or guess an appropriate one.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:19:56 UTC
  # Status:: Could be optimized


  def report_load_title

    @title = _(params[:title]) and return unless params[:title].blank?
    op_nm = case params[:serie_1][:operation].to_s
    when "avg" then "Average"
    when "min" then "Minimum"
    when "max" then "Maximum"
    else params[:serie_1][:operation].to_s.titleize
    end
    @title = "#{op_nm} of " + (params[:serie_1][:operation].to_s == 'count' ? 'records' : params[:serie_1][:field].to_s)
    @title << " by " + @x_field
    case @x_type
    when :date, :datetime
      @title << " from " + @x_labels.first.strftime("%D") + " to " + @x_labels.last.strftime("%D")
    end
    @datasets.each_with_index do |ds,idx|
      ds[:text] ||= params["serie_#{idx+1}"][:operation].to_s.titleize + " of " + (params["serie_#{idx+1}"][:operation].to_s == 'count' ? 'records' : params["serie_#{idx+1}"][:field].to_s)
    end if @report_type == :chart
  end


  # Reporting: renders data in HTML tables.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:18:50 UTC
  # Status:: Could be optimized


  def report_convert_to_html

    title = "<caption>#{@title}</caption>"
    if @y_labels # matrix
      @report = @datasets.map {|ds|
        logger.debug("ds: #{ds.inspect}")
        trs = [['<th></th>'] + @x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        case @y_type
        when :ho_assoc, :bt_assoc
          trs += @y_labels.uniq.map{ |l| l ? (["<th>#{l.disp_name}</th>"] + ds["values_for_#{l.id}"].map { |v| "<td>#{v}</td>" }) : [] }
        else
          trs += @y_labels.uniq.map{ |l| ["<th>#{l}</th>"] + ds["values_for_#{l}"].map { |v| "<td>#{v}</td>" } }
        end
        "<table>#{title}%s</table>" % trs.map{|t| "<tr>#{t}</tr>"}.join
      }
    else
      @report = @datasets.map {|ds|
        trs = [@x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        trs << ds[:values].map { |v| "<td>#{v}</td>" }
        "<table>#{title}#{trs.map{|t| "<tr>#{t}</tr>"}}</table>"
      }
    end
    render :text => @report
  end


  # Reporting: adds OFC styles and renders appropriate JSON.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 12:18:04 UTC
  # Status:: Could be optimized


  def report_convert_to_ofc

    colors = %w(2222FF 7FFFD4 D2691E A9A9A9 BDB76B DCDCDC ADFF2F F4A460 F5DEB3)
    @datasets.each_with_index { |d,idx|
      d[:type] ||= "bar"
      d[:colour] ||= colors[idx]
    }
    @report = {:elements => @datasets, :title => {:text => @title}, :bg_colour => "#FFFFFF"}
    case @x_type
    when :date, :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d, :format => :short)}, :rotate => '45' }}
    when :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d.to_date, :format => :short)}, :rotate => '45' }}
    when :integer, :float, :decimal, :static_list
      @report[:x_axis] = {:labels => {:labels => @x_labels, :rotate => '45'} }
    when :bt_assoc
      @report[:x_axis] = {:labels => {:labels => @x_labels.map(&:disp_name), :rotate => '45'} }
    end
    @report[:y_axis] = {:min => @y_min, :max => @y_max}
    @report[:y_axis][:steps] = @y_step if @y_step
    render :json => @report
  end


  # Index of all <%= model.sid %>.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-05-20 16:26:24 UTC
  # Status:: Validation Pending


  def index

    list
    unless(%w(json xml).include?(params[:format]))
      render(:action => :list)
    end
  end


  # This gives the list of all records
  #
  # Author:: Yann Azoury
  # Version:: 24
  # Last Update:: 2013-01-29 17:02:44 UTC
  # Status:: Validation Pending


  def list

    @restricted_fields = []
    pagin_opts = {:include => [:home_page_profiles,:user_accesses,:profile_accesses]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:accesses_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'accesses.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @accesses = Access.paginate(pagin_opts)
    render(:xml => @accesses.to_xml(:dasherize => false, :only => [:id,:app_sid,:set_sid,:table_sid,:field_sid,:action_sid,:type_sid], :methods => [:home_page_profiles_human_display,:user_accesses_human_display,:profile_accesses_human_display,:users_human_display,:profiles_human_display])) and return if params[:format] == 'xml'
    render(:json => @accesses) and return if params[:format] == 'json'
    render(:pdf => @accesses, :action => :list) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["app_sid", "set_sid", "table_sid", "field_sid", "action_sid", "type_sid"].include?(params[:group_by])
      @accesses_groups = @accesses.inject({}) { |acc,elt|
        crit = nil
        if [].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # Allows download of all or current record in many formats.
  #
  # Author:: Yann Azoury
  # Version:: 46
  # Last Update:: 2013-02-11 07:45:35 UTC
  # Status:: Validation Pending


  def download

    @restricted_fields = []
    @no_menubar	= true
    @no_links	= true
    @no_filterbar	= true
    @no_row_links	= true
    pagin_opts		  = {:include => [:home_page_profiles,:user_accesses,:profile_accesses]}
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= "accesses.#{params[:sort_by]}" if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter
    pagin_opts[:joins]	||= @joins_fields || []

    # pagin_opts[:select]	||= "`accesses`.`app_sid`,`accesses`.`set_sid`,`accesses`.`table_sid`,`accesses`.`field_sid`,`accesses`.`action_sid`,`accesses`.`type_sid`" unless params[:format] == 'html'

    if params[:id] && params[:id].to_i > 0
      @access = Access.find_by_id(params[:id], pagin_opts)
      if !@access
        flash[:warning] = _("Error: %{obj} not found!") % {:obj => _(%q[Access])}
        begin
          redirect_to :back
        rescue
          redirect_to :action => :list
        end
        return
      end
      f_name = @access.disp_name
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/accesses/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/accesses/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/accesses/show.html.erb', :format => :html, :id => @access.id, :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "#{@access.disp_name}.pdf") unless params[:debug_pdf] || pdf.blank?

          # send_data(render_to_string(:format => :html, :layout => false, :action => :show, :id => @access.id), :filename => "#{f_name}.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

          return
        }
        format.xml {
        send_data(@access.to_xml, :filename => "#{f_name}.xml", :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.json {
        send_data(@access.to_json, :filename => "#{f_name}.json", :disposition => 'attachment', :type => 'text/json;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "accesses")
          sheet.row(0).concat(["Application", "Set", "Table", "Field", "Action", "Type", "Home Page Profiles", "User Accesses", "Profile Accesses"])
          sheet.row(1).replace([@access.app_sid, @access.set_sid, @access.table_sid, @access.field_sid, @access.action_sid, @access.type_sid, @access.home_page_profiles.map(&:disp_name).to_sentence, @access.user_accesses.map(&:disp_name).to_sentence, @access.profile_accesses.map(&:disp_name).to_sentence])
          fname = "accesses.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv { row = @access
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            Access::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:users, :profiles].include?(c) }
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(Access::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "#{f_name}.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
          return
        }
      end
    else
      pagin_opts[:page] = 1
      pagin_opts[:per_page] = Access.count+1
      @accesses = Access.paginate(pagin_opts)
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/accesses/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "accesses.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/accesses/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "accesses.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/accesses/list.html.erb', :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "accesses.pdf") unless params[:debug_pdf] || pdf.blank?

          #      send_data(render_to_string(:layout => false, :action => :list), :filename => "accesses.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

        }
        format.xml {
        send_data(@accesses.to_xml, :filename => ('accesses.xml'), :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "accesses")
          sheet.row(0).concat(["Application", "Set", "Table", "Field", "Action", "Type", "Home Page Profiles", "User Accesses", "Profile Accesses"])
          @accesses.each_with_index do |row,i|
            sheet.row(i+1).replace([row.app_sid, row.set_sid, row.table_sid, row.field_sid, row.action_sid, row.type_sid, row.home_page_profiles.map(&:disp_name).to_sentence, row.user_accesses.map(&:disp_name).to_sentence, row.profile_accesses.map(&:disp_name).to_sentence])
          end
          fname = "accesses.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv {
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            Access::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:users, :profiles].include?(c) }
            csv << cols.map{|c| _(c.titleize)}
            @accesses.map{|row|
              csv << cols.map {|c|
                if [:ho_assoc, :bt_assoc].include?(Access::FIELDS[c])
                  v = row.send(c) ; v ? v.disp_name : nil
                else
                  row.send(c)
                end
              }
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "accesses.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        }
      end
    end
  end


  # Adds or removes an access right in the Rights Management panel.
  #
  # Author:: Ali Krikeb
  # Version:: 6
  # Last Update:: 2012-02-20 09:53:55 UTC
  # Status:: Validation Pending


  def set_permission

    render :nothing => true
    return if params[:access_id].blank? || params[:set].blank?
    @access = Access.find(params[:access_id])
    return if @access.nil?
    @set = params[:set] == 'true'
    if params[:user_id]
      @user = User.find(params[:user_id])
      h = {:user_id => @user.id, :access_id => @access.id}
      if params[:prop]
        @ua = UserAccess.first(:conditions => h) || UserAccess.create(h)
        @ua.read = @set if params[:prop] == 'read'
        @ua.write = @set if params[:prop] == 'write'
        @ua.save
      else # aktion
        if @set
          UserAccess.create(h) unless UserAccess.exists?(h)
        else
          UserAccess.delete_all(h) if UserAccess.exists?(h)
        end
      end
    end
    if params[:profile_id]
      @profile = Profile.find(params[:profile_id])
      h = {:profile_id => @profile.id, :access_id => @access.id}
      if params[:prop]
        @pa = ProfileAccess.first(:conditions => h) || ProfileAccess.create(h)
        @pa.read = @set if params[:prop] == 'read'
        @pa.write = @set if params[:prop] == 'write'
        @pa.save
      else  # aktion
        if @set
          ProfileAccess.create(h) unless ProfileAccess.exists?(h)
        else
          ProfileAccess.delete_all(h) if ProfileAccess.exists?(h)
        end
      end
    end
  end


  # Load requested report.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 17:49:09 UTC
  # Status:: Validation Pending


  def reporting

    params[:report] = "count_of_table_sid_by_field_sid" if params[:report].blank?
    @report = params[:report]
  end


  # Responds Report data in any format.
  #
  # Author:: Yann Azoury
  # Version:: 15
  # Last Update:: 2010-06-18 18:06:28 UTC
  # Status:: Validation Pending


  def reporting_data

    report_sid = params[:report].blank? ? "count_of_table_sid_by_field_sid" : params[:report]
    render(:nothing => true) and return if report_sid.blank?
    opts = (params[:report_options] || {}).reject{|k,v| v.blank?}
    opts[:format] ||= params[:format]
    r = AccessReport.make_report(report_sid, opts)
    r[:title][:style] = r[:title][:style].tr(',', ';').gsub('colour', 'color') if r && r[:title] && r[:title][:style]
    @report = r
    respond_to do |format|
      format.json { render :json => @report }
      format.html { render :text => @report }
    end
  end


  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2013-03-15 15:34:15 UTC
  # Status:: Validation Pending


  def permissions

    if params[:format] == 'json'
      @page = Access.find(params[:page_id])
      @profile = Profile.find(params[:profile_id])
      @users = @profile.users.limit(200)
      @user = !params[:user_id].blank? ? @users.where(:id => params[:user_id]).first : @users.first
      @res = {:actions => Access.actions(@page.table_sid).select('id,action_sid,type_sid'),
        :fields => Access.fields(@page.table_sid).select('id,field_sid,type_sid'),
        :users => @users.map{|u| {:name => u.disp_name, :id => u.id} },
        :profile_accesses => @profile.accesses.where(:table_sid => @page.table_sid).map(&:id),
      :user_accesses => (@user ? @user.accesses.where(:table_sid => @page.table_sid).map(&:id) : [])}
      render :json => @res
      return
    end

    # first call

    @pages = Access.tables.reject{|p| p.table_sid == 'root_pages'}
    @page = @pages.first
    @ps_for_col = {}
    @pages.group_by(&:set_sid).each{ |k,v|
      k = _("[None]") if k.blank?
      @ps_for_col[k] = v.map{|p| [_(p.table_sid.titleize), p.id]}
    }
    @profiles = Profile.limit(200)
    @profile = @profiles.first
    @users = @profile.users.limit(200)
  end


  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2013-01-12 17:55:35 UTC
  # Status:: In Progress


  def set_access

    @access = Access.find(params[:page_id])
    @accesses = Access.where(:id => params[:id])
    table_sid = @access.table_sid
    @profile = Profile.find(params[:profile_id]) if !params[:profile_id].blank?
    @user = User.find(params[:user_id]) if !params[:user_id].blank?
    if @profile
      to_create = @accesses - @profile.accesses.where(:table_sid => table_sid)
      @profile.accesses += to_create
      to_delete = @profile.accesses.where(:table_sid => table_sid) - @accesses
      @profile.profile_accesses.where(:access_id => to_delete.map(&:id)).destroy_all
    elsif @user
      to_create = @accesses - @user.accesses.where(:table_sid => table_sid)
      @user.accesses += to_create
      to_delete = @user.accesses.where(:table_sid => table_sid) - @accesses
      @user.user_accesses.where(:access_id => to_delete.map(&:id)).destroy_all
    end
    render :json => params[:id]
  end
  protected
  private


  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_accesses_pres_mode"].to_sym unless cookies["#{APP_SID}_accesses_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_accesses_pres_mode"].to_sym unless params["#{APP_SID}_accesses_pres_mode"].blank?
  end

end
