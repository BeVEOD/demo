# encoding: utf-8
################################################
## This file and all its content belong to Faveod S.A.S unless a commercial
## contract signed by a representant of Faveod S.A.S states otherwise.
##########
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
################################################
## This has been generated by Faveod Generator on Thu Oct 31 16:40:24 +0100 2013
## It should be placed at 'app/controllers/file_imports_controller.rb'
## All manual modifications will be destroyed on next generation
################################################


class FileImportsController < ApplicationController
  layout 'application_jquery_horizontal'

  before_filter(:faveod_cookies_loading)

  before_filter(:only => :create) do
    request.request_method_symbol == :post
  end
  before_filter(:only => :update) do
    request.request_method_symbol == :put
  end
  before_filter(:only => :list) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :source_files) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :running) do
    request.request_method_symbol == :get
  end
  before_filter(:only => :complete) do
    request.request_method_symbol == :get
  end

  around_filter(:data_context_filter_1, :only => [:index, :list, :task_board])

  # AJAX association management.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2011-06-23 17:57:01 UTC
  # Status:: Requires Tests


  def linker

    render(:text => _('AJAX only')) and return if !request.xhr?
    render(:text => _('Missing required parameter')) and return if params[:id].blank? || params[:sid].blank?
    params[:page] = 1 if params[:page].to_i == 0
    params[:per_page] = 15 if params[:per_page].to_i == 0
    @file_import   = FileImport.find_by_id(params[:id])
    @file_import ||= FileImport.new
    case params[:sid].to_sym
    when :user
      val = params["user"] ? params["user"]["0"] : {}
      @user = User.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/users/list_for_linker', :locals => {:assoc_sid => :file_imports, :assoc_type => :belongs_to}
    when :file_import
      val = params["file_import"] ? params["file_import"]["0"] : {}
      @file_import = FileImport.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/file_imports/list_for_linker', :locals => {:assoc_sid => :re_imports, :assoc_type => :belongs_to}
    when :re_imports
      val = params["re_import"] ? params["re_import"]["0"] : {}
      @re_imports = FileImport.search(val, params.reject{|k,v| !k[/comp_/]}, :page => params[:page], :per_page => params[:per_page])
      render :partial => '/file_imports/list_for_linker', :locals => {:assoc_sid => :file_import, :assoc_type => :has_many}
    end
  end


  # Retrieve the thumbnail of a file (icon or image).
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2013-02-04 15:20:42 UTC
  # Status:: Requires Tests


  def get_file_thumb

    @file_import = FileImport.find_by_id(params[:id])
    filename = nil
    document = nil
    mime	 = nil
    case params[:sid].to_s
    when "file"
      filename   = @file_import.file__thumb_path
      filename ||= @file_import.file__name
      document   = @file_import.file
    end
    if filename
      mime = MIME::Types.type_for(filename)
      file_type = mime.first ? mime.first.content_type : 'application/octet-stream'
      disposition	= 'inline' if mime.first && ['text', 'image'].include?(mime.first.media_type)
      disposition ||= 'attachment'
      extension = filename.split('.').last
      if mime.first.nil? || mime.first.media_type != 'image'
        icon = Rails.root.join('public', 'images', 'file_icons', "#{extension}.png").to_s
        icon = Rails.root.join('public', 'images', 'file_icons', "defaut.png").to_s unless File.exist?(icon)

        # sends thumbnail file

        send_data(File.open(icon).read, :filename => File.basename(icon), :type => 'image/png', :disposition => 'inline')
        return
      end
      if document && FileImport.columns.find{|e| e.name == params[:sid]}

        # sends thumbnail blob in the database

        send_data(@file_import.thumbnail(params[:sid]), :filename => filename, :type => file_type, :disposition => 'inline')
      else

        # makes thumbnail and send

        thmb = @file_import.thumbnail(params[:sid])
        if thmb
          send_data(thmb, :filename => filename, :type => file_type, :disposition => 'inline')
        else
          render :nothing => true
        end
      end
    else
      render :nothing => true
    end
  end


  # Reporting: displays preset reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 19:23:13 UTC
  # Status:: Requires Tests


  def report_chooser

    @data_sets = SmartQuery.all(:conditions => {:table_sid => ['file_imports', '']})
    m_par = params[:file_imports] || {}
    @data_set = SmartQuery.find_by_id(m_par[:data_set]) || @data_sets.first
    logger.debug("m_par #{m_par.inspect}")
  end


  # Reporting: global steps to rendering reports.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:24:32 UTC
  # Status:: Could be optimized


  def report_generate

    report_check_params

    #logger.debug("BEGIN report_load_labels")

    report_load_labels

    #logger.debug("END report_load_labels")
    #logger.debug("BEGIN report_load_datasets")

    report_load_datasets

    #logger.debug("END report_load_datasets")
    #logger.debug("BEGIN report_load_title")

    report_load_title

    #logger.debug("END report_load_title")

    respond_to do |format|
      format.html {report_convert_to_html}
      format.json {report_convert_to_ofc}

      #  format.pdf {report_convert_to_pdf }

    end
  end


  # Reporting: checks sent params for security and consistency.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:23:42 UTC
  # Status:: Could be optimized


  def report_check_params


    # logger.debug("BEGIN report_check_params")

    @report_type = params[:format] == 'html' ? :table : :chart
    @x_type = FileImport::FIELDS[params[:x_field]]
    render(:text => "No correct x_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@x_type)

    # logger.debug("\t\t x_field: #{params[:x_field]} (#{@x_type})")

    if params[:y_field]
      @y_type = FileImport::FIELDS[params[:y_field]]
      render(:text => "No correct y_field parameter") and return if ![:integer, :float, :double, :boolean, :static_list, :date, :datetime, :string, :bt_assoc].include?(@y_type)
    end
    render(:text => "No correct serie parameter") and return if params[:serie_1].blank? || !params[:serie_1].is_a?(Hash) || (params[:serie_1][:field].blank? && params[:serie_1][:operation].blank?)
    f = params["serie_1"][:field] ||= 'id'
    o = params["serie_1"][:operation] ||= [:integer, :float, :double].include?(FileImport::FIELDS[params["serie_1"][:field]]) ? :value : :count

    # TODO manage field is a model_method

    render(:text => "No correct serie[:field] parameter") and return if !FileImport::FIELDS.has_key?(f) && (o != 'count')
    render(:text => "No correct serie[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(FileImport::FIELDS[f]) && params[:serie_1][:operation].blank?)
    (2..5).each {|i|
      break if params["serie_#{i}"].blank? || !params["serie_#{i}"].is_a?(Hash)
      f = params["serie_#{i}"][:field]
      render(:text => "No correct serie_#{i}[:field] parameter") and return if f.blank? || !FileImport::FIELDS.has_key?(f)
      render(:text => "No correct serie_#{i}[:operation] parameter") and return if (![:integer, :float, :double, :boolean, :static_list].include?(FileImport::FIELDS[f]) && params["serie_#{i}"][:operation].blank?)
    }
    @x_field = params[:x_field]
    @y_field = params[:y_field] unless params[:y_field].blank?

    # logger.debug("END report_check_params")

  end


  # Reporting: extracts labels and categories to display axes.
  #
  # Author:: Yann Azoury
  # Version:: 6
  # Last Update:: 2011-01-22 17:12:57 UTC
  # Status:: Could be optimized


  def report_load_labels

    case @x_type
    when :string
      return @x_labels = FileImport.all(:select => "DISTINCT(`#{@x_field}`)").map{|r| r.send(@x_field)}
    when :static_list
      return @x_labels = FileImport.const_get(@x_field.pluralize.upcase)
    when :bt_assoc
      return @x_labels = FileImport.reflect_on_association(@x_field.to_sym).klass.all
    end
    @x_range = if params[:x_range] # range is given
      case @x_type
      when :integer
        params[:x_range].split('..').map(&:to_i)
      when :float, :double
        params[:x_range].split('..').map(&:to_f)
      when :date, :datetime
        rg = params[:x_range].split('..').map(&:to_i)
        @x_min = Time.now + rg.first.days
        @x_max = Time.now + rg.last.days
        rg
      end
    else
      @x_min = FileImport.minimum(@x_field)
      @x_max = FileImport.maximum(@x_field)
      case @x_type
      when :integer, :float, :double
      when :date, :datetime
        [((@x_min - Time.now) / 86400).round, ((@x_max - Time.now) / 86400).round]
      end
    end
    if true
      case @x_type
      when :integer, :float, :double
        @x_min, @x_max = @x_range
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10.0
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
        @x_labels = [@x_min]
        while(@x_labels.last <= @x_max) do
          @x_labels << @x_labels.last + @x_steps
        end
      when :date, :datetime
        @x_steps = case params[:x_steps]
        when "month"
          30
        when "week"
          7
        else
          if !params[:x_steps] || params[:x_steps].to_i == 0
            (@x_range.last - @x_range.first).round / 10.0
          else
            params[:x_steps].to_i
          end
        end
        @x_steps = 1 if @x_steps == 0
        @x_min ||= Time.now + @x_range.first.days
        @x_max ||= Time.now + @x_range.last.days
        @x_labels = [@x_min]
        logger.debug("\t (#{@x_min})..(#{@x_max}) - #{@x_steps} days step")
        200.times {
          break if @x_labels.last > @x_max
          @x_labels << @x_labels.last + @x_steps.days
        }
      end
    else  # no params[:x_range] => need to guess range
      case @x_type
      when :integer, :float, :double
        @datasets.each_with_index { |h,i|
          d = h[:values]
          if !@x_min
            @x_min = d.min
          else
            d_min = d.min
            @x_min = d_min if d_min < @x_min
          end
          if !@x_max
            @x_max = d.max
          else
            d_max = d.max
            @x_max = d_max if d_max > @x_max
          end
        }
        params[:x_steps] ||= (@x_max.to_f - @x_min.to_f) / 10
        @x_steps = params[:x_steps].to_f
        @x_steps = 0.1 if @x_steps == 0
      end
      case @x_type
      when :integer, :float, :double
        if params[:x_ticks]
        end
      when :static_list
      when :date, :datetime
      end
    end
  end


  # Reporting: loads datasets.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:20:49 UTC
  # Status:: Could be optimized


  def report_load_datasets

    @datasets = []
    i = 1
    if @y_field
      case @y_type
      when :string
        @y_labels = FileImport.all(:select => FileImport.connection.distinct(@y_field, nil)).map{|r| r.send(@y_field)}
      when :static_list
        @y_labels = FileImport.const_get(@y_field.pluralize.upcase)
      when :ho_assoc, :bt_assoc, :habtm_assoc
        @y_labels = FileImport.all(:include => @y_field).map{|r| r.send(@y_field)}
      end
      while(params["serie_#{i}"]) do
        ds = {}
        @y_labels.each_with_index { |l,idx|
          next if l.nil?
          case @y_type
          when :string
            ds["values_for_#{l}"] = FileImport.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => l}, :data_set => @data_set)
          when :static_list
            ds["values_for_#{l}"] = FileImport.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {@y_field => (@y_labels.index(l)+1)}, :data_set => @data_set)
          when :bt_assoc
            fk = FileImport.reflect_on_association(@y_field.to_sym).primary_key_name

            #        FileImport.send(:with_scope, :find => {:conditions => {fk => l.id}}) {
            #        ds["values_for_#{l.id}"] = report_retrieve_data(params["serie_#{i}"][:operation].to_s, params["serie_#{i}"][:field])

            ds["values_for_#{l.id}"] = FileImport.report_calculation(params["serie_#{i}"][:operation],
            params["serie_#{i}"][:field],
            :labels => @x_labels, :group => @x_field, :scope => {fk => l.id}, :data_set => @data_set)

            #        }

          end
        }
        i += 1 ; @datasets << ds
      end
      return
    end
    while(params["serie_#{i}"]) do
      ds = {:values => FileImport.report_calculation(params["serie_#{i}"][:operation],
        params["serie_#{i}"][:field],
      :group => @x_field, :labels => @x_labels, :data_set => @data_set)}
      ds[:type] = params["serie_#{i}"][:type] || 'bar'
      @y_min = 0
      y_min = ds[:values].min || 0
      @y_min = y_min if y_min < @y_min
      if !@y_max
        @y_max = ds[:values].max || 0
      else
        y_max = ds[:values].max || 0
        @y_max = y_max if y_max > @y_max
      end
      i += 1 ; @datasets << ds
    end
    case @y_max
    when 0...5 then @y_max = 5 ; @y_step = 1
    when 5..10 then @y_max = 10 ; @y_step = 1
    when 10..50 then @y_max = 50 ; @y_step = 5
    when 50..100 then @y_max = 100 ; @y_step = 10
    when 100..500 then @y_max = 500 ; @y_step = 50
    when 500..1000 then @y_max = 1000 ; @y_step = 50
    when 1000..5000 then @y_max = 5000 ; @y_step = 100
    end
  end


  # Reporting: displays selected title or guess an appropriate one.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:19:56 UTC
  # Status:: Could be optimized


  def report_load_title

    @title = _(params[:title]) and return unless params[:title].blank?
    op_nm = case params[:serie_1][:operation].to_s
    when "avg" then "Average"
    when "min" then "Minimum"
    when "max" then "Maximum"
    else params[:serie_1][:operation].to_s.titleize
    end
    @title = "#{op_nm} of " + (params[:serie_1][:operation].to_s == 'count' ? 'records' : params[:serie_1][:field].to_s)
    @title << " by " + @x_field
    case @x_type
    when :date, :datetime
      @title << " from " + @x_labels.first.strftime("%D") + " to " + @x_labels.last.strftime("%D")
    end
    @datasets.each_with_index do |ds,idx|
      ds[:text] ||= params["serie_#{idx+1}"][:operation].to_s.titleize + " of " + (params["serie_#{idx+1}"][:operation].to_s == 'count' ? 'records' : params["serie_#{idx+1}"][:field].to_s)
    end if @report_type == :chart
  end


  # Reporting: renders data in HTML tables.
  #
  # Author:: Sylvain Abélard
  # Version:: 5
  # Last Update:: 2010-06-16 12:18:50 UTC
  # Status:: Could be optimized


  def report_convert_to_html

    title = "<caption>#{@title}</caption>"
    if @y_labels # matrix
      @report = @datasets.map {|ds|
        logger.debug("ds: #{ds.inspect}")
        trs = [['<th></th>'] + @x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        case @y_type
        when :ho_assoc, :bt_assoc
          trs += @y_labels.uniq.map{ |l| l ? (["<th>#{l.disp_name}</th>"] + ds["values_for_#{l.id}"].map { |v| "<td>#{v}</td>" }) : [] }
        else
          trs += @y_labels.uniq.map{ |l| ["<th>#{l}</th>"] + ds["values_for_#{l}"].map { |v| "<td>#{v}</td>" } }
        end
        "<table>#{title}%s</table>" % trs.map{|t| "<tr>#{t}</tr>"}.join
      }
    else
      @report = @datasets.map {|ds|
        trs = [@x_labels.map{|l|
          case @x_type
          when :date, :datetime
            "<th>#{l.strftime("%D")}</th>"
          when :bt_assoc
            "<th>#{l ? l.disp_name : ''}</th>"
          else
            "<th>#{l}</th>"
          end
        }]
        trs << ds[:values].map { |v| "<td>#{v}</td>" }
        "<table>#{title}#{trs.map{|t| "<tr>#{t}</tr>"}}</table>"
      }
    end
    render :text => @report
  end


  # Reporting: adds OFC styles and renders appropriate JSON.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 12:18:04 UTC
  # Status:: Could be optimized


  def report_convert_to_ofc

    colors = %w(2222FF 7FFFD4 D2691E A9A9A9 BDB76B DCDCDC ADFF2F F4A460 F5DEB3)
    @datasets.each_with_index { |d,idx|
      d[:type] ||= "bar"
      d[:colour] ||= colors[idx]
    }
    @report = {:elements => @datasets, :title => {:text => @title}, :bg_colour => "#FFFFFF"}
    case @x_type
    when :date, :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d, :format => :short)}, :rotate => '45' }}
    when :datetime
      @report[:x_axis] = {:labels => {:labels => @x_labels.map{|d| l(d.to_date, :format => :short)}, :rotate => '45' }}
    when :integer, :float, :decimal, :static_list
      @report[:x_axis] = {:labels => {:labels => @x_labels, :rotate => '45'} }
    when :bt_assoc
      @report[:x_axis] = {:labels => {:labels => @x_labels.map(&:disp_name), :rotate => '45'} }
    end
    @report[:y_axis] = {:min => @y_min, :max => @y_max}
    @report[:y_axis][:steps] = @y_step if @y_step
    render :json => @report
  end


  # File management: gets files' size.
  #
  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2010-06-16 12:23:12 UTC
  # Status:: Requires Tests


  def get_file_size

    size	  = nil
    filename = nil
    document = nil
    @file_import = FileImport.find_by_id(params[:id])
    case params[:sid].to_s
    when "file"
      filename	= @file_import.file__path
      document	= @file_import.file
    end
    if FileImport.columns.find{|e| e.name == params[:sid]} # binary in db
      size = document.blank? ? 0 : document.length
    else
      size = filename.blank? ? 0 : File.size(filename)
    end
    render :text => size.to_s
  end


  # Load the entire file.
  #
  # Author:: Yann Azoury
  # Version:: 8
  # Last Update:: 2012-09-11 00:06:47 UTC
  # Status:: Requires Tests


  def get_file

    @file_import = FileImport.find_by_id(params[:id])
    filename = nil
    filepath = nil
    document = nil
    case params[:sid].to_s
    when "file"
      filename = @file_import.file__name
      filepath = @file_import.file__path
      document = @file_import.file
    end
    if document && File.exist?(filepath)
      mime = MIME::Types.type_for(filename)
      file_type	= mime.first ? mime.first.content_type : 'application/octet-stream'
      disposition	= 'inline' if mime.first && ['text', 'image'].include?(mime.first.media_type)
      disposition ||= 'attachment'
      send_data(document, :filename => filename, :type => file_type, :disposition => disposition)
    else
      render :nothing => true
    end
  end


  # Load requested report.
  #
  # Author:: Sylvain Abélard
  # Version:: 11
  # Last Update:: 2010-06-16 17:49:09 UTC
  # Status:: Validation Pending


  def reporting

    params[:report] = "" if params[:report].blank?
    @report = params[:report]
  end


  # Responds Report data in any format.
  #
  # Author:: Yann Azoury
  # Version:: 15
  # Last Update:: 2010-06-18 18:06:28 UTC
  # Status:: Validation Pending


  def reporting_data

    report_sid = params[:report].blank? ? "" : params[:report]
    render(:nothing => true) and return if report_sid.blank?
    opts = (params[:report_options] || {}).reject{|k,v| v.blank?}
    opts[:format] ||= params[:format]
    r = FileImportReport.make_report(report_sid, opts)
    r[:title][:style] = r[:title][:style].tr(',', ';').gsub('colour', 'color') if r && r[:title] && r[:title][:style]
    @report = r
    respond_to do |format|
      format.json { render :json => @report }
      format.html { render :text => @report }
    end
  end


  # Index of all <%= model.sid %>.
  #
  # Author:: Yann Azoury
  # Version:: 10
  # Last Update:: 2012-05-20 16:26:24 UTC
  # Status:: Validation Pending


  def index

    list
    unless(%w(json xml).include?(params[:format]))
      render(:action => :list)
    end
  end


  # Loads a new record.
  #
  # Author:: Yann Azoury
  # Version:: 2
  # Last Update:: 2012-03-25 18:26:30 UTC
  # Status:: Validation Pending


  def new

    @file_import_attributes = params[:file_import] ? params[:file_import]['0'].clone : {}

    @file_import = FileImport.load_from_params(@file_import_attributes)

    render(:layout => !request.xhr?)
  end


  # Inserts the record in the database.
  #
  # Author:: Yann Azoury
  # Version:: 23
  # Last Update:: 2013-10-31 16:38:41 UTC
  # Status:: Validation Pending


  def create

    redirect_to(:action => :index) and return unless request.post?
    redirect_to(:action => :index) and return if params[:file_import].blank? || !params[:file_import].is_a?(Hash)
    @file_import_attributes = params[:file_import] ? params[:file_import]['0'].clone : {}

    @file_import = FileImport.load_from_params(@file_import_attributes)
    if @file_import.errors.empty? && @file_import.save
      flash[:notice] = _("%{page} was successfully created.") % {:page => _("File Import")}
      if request.xhr? # && params[:format] == 'json'
        render(:json => {:id => @file_import.id}.merge(@file_import.attributes).to_json)
        return
      end
    else
      if request.xhr? # && params[:format] == 'json'
        render(:json => ({:errors => @file_import.errors.full_messages}.merge(@file_import.attributes)).to_json)
      else
        render(:action => :new)
      end
      return
    end
    if params[:go_to].blank?
      redirect_to :action => (params[:commit_and_new] ? :new : :index)
    else
      redirect_to(params[:go_to])
    end
  end


  # Display the record.
  #
  # Author:: Yann Azoury
  # Version:: 14
  # Last Update:: 2012-03-26 04:12:53 UTC
  # Status:: Validation Pending


  def show

    @file_import_attributes = params[:file_import] ? params[:file_import][params[:id]].clone : {}
    @file_import_attributes.merge!(:id => params[:id]) if @file_import_attributes

    @file_import = FileImport.load_from_params(@file_import_attributes)
    if @file_import.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'file_import', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    respond_to do |format|
      format.html {
      render :layout => !request.xhr? }
      format.pdf {
      render :layout => false }
      format.xml {
      render :xml => @file_import.to_xml }
      format.json {
      render :json => @file_import.to_json }
    end
  end


  # Load the data to fill the edit form.
  #
  # Author:: Yann Azoury
  # Version:: 11
  # Last Update:: 2012-03-25 20:53:17 UTC
  # Status:: Validation Pending


  def edit

    @file_import_attributes = params[:file_import] ? params[:file_import][params[:id]].clone : {}
    @file_import_attributes.merge!(:id => params[:id]) if @file_import_attributes

    @file_import = FileImport.load_from_params(@file_import_attributes)
    if @file_import.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'file_import', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end

    render(:layout => !request.xhr?)
  end


  # Updates the current row in database from the sent form.
  #
  # Author:: Sylvain Abélard
  # Version:: 14
  # Last Update:: 2012-12-13 11:53:56 UTC
  # Status:: Validation Pending


  def update

    redirect_to(:action => :index) and return unless request.put?
    redirect_to(:action => :index) and return if params[:file_import].blank? || !params[:file_import].is_a?(Hash)
    @file_import_attributes = params[:file_import] ? params[:file_import][params[:id]].clone : {}
    @file_import_attributes.merge!(:id => params[:id]) if @file_import_attributes

    @file_import = FileImport.load_from_params(@file_import_attributes)
    if @file_import.nil?
      flash[:warning] ||= []
      flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'file_import', :id => params[:id]}
      redirect_to(:action => :index)
      return
    end
    if @file_import.save
      flash[:notice] = _("%{page} was successfully updated.") % {:page => _("File Import")}
    else
      if request.xhr?
        render(:json => {:errors =>
        @file_import.errors.full_messages})
      else
        render(:action => :edit, :id => @file_import.id)
      end
      return
    end
    render(:json => "OK") and return if request.xhr?
    if params[:file_import].length == 1 # single edit
      redirect_to :action => :show, :id => @file_import.id
    else
      redirect_to :action => :index
    end
  end


  # Deletes an object or list of objects from the database.
  #
  # Author:: Yann Azoury
  # Version:: 9
  # Last Update:: 2011-03-08 15:34:31 UTC
  # Status:: Validation Pending


  def destroy

    if params[:id].is_a?(Array)
      @success = FileImport.destroy(params[:id])
    else
      @file_import = FileImport.find_by_id(params[:id])
      @file_import.destroy unless @file_import.nil?
      @success = @file_import && @file_import.destroyed?
    end
    if @success
      flash[:notice] = _("%{model} %{name} successfully deleted.") % {:model => _("File Import"), :name => @file_import.disp_name}
    else
      flash[:warning] = _("%{model} %{name} could not be deleted.") % {:model => _("File Import"), :name => params[:name]}
    end
    if params[:format] != "json"
      if request.xhr?
        render :action => 'ajax_update', :layout => false
      else
        if params[:go_to].blank?
          redirect_to :action => :index
        else
          redirect_to(params[:go_to])
        end
      end
    else
      resp = {}
      if @success
        resp[:success] = true
      else
        resp[:success] = false
        resp[:error] = flash[:warning]
      end
      render :json => resp.to_json, :layout => false
    end
  end


  # Search and filter data.
  #
  # Author:: Sylvain Abélard
  # Version:: 44
  # Last Update:: 2010-06-15 18:38:22 UTC
  # Status:: Requires Tests


  def search

    @file_import = FileImport.load_from_params(params[:file_import]["0"]) if params[:file_import]
    @file_import ||= FileImport.new
    page	   = params[:page].to_i > 0 ? params[:page].to_i : 1
    per_page   = params[:per_page]
    per_page ||= FileImport.count if params[:format] && %w(xml xls csv).include?(params[:format])
    per_page   = 50 if !per_page || per_page == 0

    # GET RESULTS FROM SMART_QUERY OR PARAMS

    if params[:file_import]
      my_p = params[:file_import]["0"].reject{|k, v|
        params["comp_#{k}"].blank? || (v.blank? && !params["comp_#{k}"].include?('NULL'))
      } if params[:file_import]["0"]
      @file_imports = FileImport.search(my_p, params.reject{|k,v| !k[/comp_/]}, :page => page, :per_page => per_page)
    elsif params[:query]
      @file_imports = FileImport.active_filter(ActiveSupport::JSON.decode(params[:query])).paginate(:page => page, :per_page => per_page)
    elsif params[:fts_query]
      l = params[:limit] ? params[:limit] : :all
      @file_imports = FileImport.find_with_ferret(params[:fts_query], :limit => l)
    elsif (params[:id] || params[:smart_query])
      if params[:id]
        @smart_query = SmartQuery.find_by_id(params[:id])
      else
        attr = params[:smart_query].first[1] if params[:smart_query].first
        attr[:criteria] = SmartQuery.clean_criteria(attr[:criteria])
        @smart_query = SmartQuery.new(attr)
      end
      @file_imports = FileImport.search(@smart_query, :page => page, :per_page => per_page)
    else
      opts = {:include => [:user,:file_import,:re_imports]}
      opts[:page]		  = page
      opts[:per_page]	  = per_page
      opts[:order]		  = @default_order
      opts[:order]		||= 'file_imports.' +params[:sort_by] if !params[:sort_by].blank?
      opts[:conditions]	||= @default_filter
      opts[:joins] 		||= @joins_fields  || []
      @file_imports = FileImport.paginate(opts)
    end

    # RENDER SOMETHING

    if !@file_imports.blank? && params[:format] # GET
      if params[:format] == 'xml'
        send_data(@file_imports.to_xml,
        :filename => ('file_imports.xml'),
        :disposition => 'attachment',
        :type => 'text/xml;charset=utf-8')
        return
      elsif params[:format] == 'xls'
        cols = []
        FileImport::FIELDS.each{|k,v|
        cols << k if [:string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
        book = Spreadsheet::Workbook.new
        sheet = book.create_worksheet(:name => "file_imports")
        sheet.row(0).concat(cols)
        @file_imports.each_with_index do |row,i|
          sheet.row(i+1).replace(cols.map{|c|
            if [:ho_assoc, :bt_assoc].include?(FileImport::FIELDS[c])
              v = row.send(c)
              v ? v.disp_name : ''
            else
              row.send(c)
            end
          })
        end
        fname = "file_imports.xls"
        tmp = Tempfile.new(fname)
        book.write(tmp.path)
        tmp.close
        send_file(tmp.path, :filename => fname)
        return
      elsif params[:format] == 'csv'
        cols = FileImport::FIELDS.inject([]) {|a,v|
        a << v[0] if [:ho_assoc, :bt_assoc, :string, :text, :integer, :float, :decimal, :date, :time, :datetime, :timestamp].include?(v[1]) ; a}
        @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';') }) do |csv|
          csv << cols
          for row in @file_imports
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(FileImport::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
        end
        @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
        conv = Iconv.new(@export_encoding, 'UTF-8')
        send_data(conv.iconv(@csv_string), :filename => "file_imports.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        return
      end
    end
    if request.xhr? || request.post?
      render :partial => 'result_list' and return
    end
  end


  # Allows download of all or current record in many formats.
  #
  # Author:: Yann Azoury
  # Version:: 46
  # Last Update:: 2013-02-11 07:45:35 UTC
  # Status:: Validation Pending


  def download

    @restricted_fields = []
    @no_menubar	= true
    @no_links	= true
    @no_filterbar	= true
    @no_row_links	= true
    pagin_opts		  = {:include => [:user,:file_import,:re_imports]}
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= "file_imports.#{params[:sort_by]}" if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter
    pagin_opts[:joins]	||= @joins_fields || []

    # pagin_opts[:select]	||= "`file_imports`.`started_at`,`file_imports`.`completed_at`,`file_imports`.`read_lines`,`file_imports`.`wrote_records`,`file_imports`.`expected_total`,`file_imports`.`error_count`,`file_imports`.`log`" unless params[:format] == 'html'

    if params[:id] && params[:id].to_i > 0
      @file_import = FileImport.find_by_id(params[:id], pagin_opts)
      if !@file_import
        flash[:warning] = _("Error: %{obj} not found!") % {:obj => _(%q[FileImport])}
        begin
          redirect_to :back
        rescue
          redirect_to :action => :list
        end
        return
      end
      f_name = @file_import.disp_name
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/file_imports/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/file_imports/show.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "#{f_name}.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/file_imports/show.html.erb', :format => :html, :id => @file_import.id, :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "#{@file_import.disp_name}.pdf") unless params[:debug_pdf] || pdf.blank?

          # send_data(render_to_string(:format => :html, :layout => false, :action => :show, :id => @file_import.id), :filename => "#{f_name}.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

          return
        }
        format.xml {
        send_data(@file_import.to_xml, :filename => "#{f_name}.xml", :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.json {
        send_data(@file_import.to_json, :filename => "#{f_name}.json", :disposition => 'attachment', :type => 'text/json;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "file_imports")
          sheet.row(0).concat(["Started at", "Completed at", "Read lines", "Wrote Records", "Expected total", "Error Count", "Log"])
          sheet.row(1).replace([@file_import.started_at, @file_import.completed_at, @file_import.read_lines, @file_import.wrote_records, @file_import.expected_total, @file_import.error_count, @file_import.log])
          fname = "file_imports.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv { row = @file_import
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            FileImport::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:user, :file_import, :re_imports].include?(c) }
            csv << cols.map{|c|
              if [:ho_assoc, :bt_assoc].include?(FileImport::FIELDS[c])
                v = row.send(c) ; v ? v.disp_name : nil
              else
                row.send(c)
              end
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "#{f_name}.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
          return
        }
      end
    else
      pagin_opts[:page] = 1
      pagin_opts[:per_page] = FileImport.count+1
      @file_imports = FileImport.paginate(pagin_opts)
      respond_to do |format|
        format.html {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/file_imports/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "file_imports.html", :disposition => 'attachment', :type => 'text/html;charset=utf-8') }
        format.doc {
          @no_menubar = true
          @no_links = true
          data = render_to_string(:template => '/file_imports/list.html.erb', :layout => 'minimal').gsub(/\ssrc=\"\//, %Q[ src="#{request.protocol}#{request.host_with_port}/])
        send_data(data, :filename => "file_imports.doc", :disposition => 'attachment', :type => 'application/msword;charset=utf-8') }
        format.pdf {
          @pdf = true
          @debug_pdf = params[:debug_pdf]
          params[:format] = 'html'
          html = render_to_string(:template => '/file_imports/list.html.erb', :layout => 'pdf')
          html.gsub!(/\/images\//, Rails.root.join('public', 'images/')) if !params[:debug_pdf]
          render(:text => html,  :layout => 'pdf') and return if params[:debug_pdf]
          kit = PDFKit.new(html, :encoding => 'UTF-8')
          kit.stylesheets << Rails.root.join('public', 'stylesheets', 'pdf.css')
          pdf = kit.to_pdf
          send_data(pdf, :filename => "file_imports.pdf") unless params[:debug_pdf] || pdf.blank?

          #      send_data(render_to_string(:layout => false, :action => :list), :filename => "file_imports.pdf", :disposition => 'attachment', :type => 'application/pdf;charset=utf-8')

        }
        format.xml {
        send_data(@file_imports.to_xml, :filename => ('file_imports.xml'), :disposition => 'attachment', :type => 'text/xml;charset=utf-8')}
        format.xls {
          book = Spreadsheet::Workbook.new
          sheet = book.create_worksheet(:name => "file_imports")
          sheet.row(0).concat(["Started at", "Completed at", "Read lines", "Wrote Records", "Expected total", "Error Count", "Log"])
          @file_imports.each_with_index do |row,i|
            sheet.row(i+1).replace([row.started_at, row.completed_at, row.read_lines, row.wrote_records, row.expected_total, row.error_count, row.log])
          end
          fname = "file_imports.xls"
          tmp = Tempfile.new(fname)
          book.write(tmp.path)
          tmp.close
          send_file(tmp.path, :filename => fname)
        }
        format.csv {
          @csv_string = FasterCSV.generate({:encoding => 'UTF-8', :col_sep => (SystemSetting['csv_export_separator'] || ';')}) do |csv|
            cols = []
            FileImport::FIELDS.each{|k,v| cols << k if [:string, :text, :integer, :float, :date, :time, :datetime, :timestamp, :ho_assoc, :bt_assoc].include? v}
            cols.reject!{|c| [:user, :file_import, :re_imports].include?(c) }
            csv << cols.map{|c| _(c.titleize)}
            @file_imports.map{|row|
              csv << cols.map {|c|
                if [:ho_assoc, :bt_assoc].include?(FileImport::FIELDS[c])
                  v = row.send(c) ; v ? v.disp_name : nil
                else
                  row.send(c)
                end
              }
            }
          end
          @export_encoding ||= SystemSetting['csv_export_encoding'] || 'UTF-16LE'
          conv = Iconv.new(@export_encoding, 'UTF-8')
          send_data(conv.iconv(@csv_string), :filename => "file_imports.csv", :disposition => 'attachment', :type => "text/csv;charset=#{@export_encoding.downcase}")
        }
      end
    end
  end


  # Exports RSS, XML and ATOM feeds.
  #
  # Author:: Sylvain Abélard
  # Version:: 6
  # Last Update:: 2010-06-16 12:11:11 UTC
  # Status:: Validation Pending


  def feed

    @file_imports = FileImport.all(:limit => 50)
    respond_to do |format|
      format.rss {render :template => 'file_imports/rss', :layout => false}
      format.xml {render :template => 'file_imports/rss', :layout => false}
      format.html {render :template => 'file_imports/rss', :layout => false}
      format.atom {render :template => 'file_imports/atom', :layout => false}
    end
  end


  # Gives help about current module.
  #
  # Author:: Yann Azoury
  # Version:: 17
  # Last Update:: 2012-05-19 23:29:44 UTC
  # Status:: Validation Pending


  def help

    @user_actions = Access.where(:table_sid => "file_imports", :action_sid => ["index", "new", "create", "show", "edit", "update", "destroy", "search", "download", "feed", "help", "adv_search", "preview", "load", "list", "source_files", "running", "complete"]).includes([:user_accesses, :profile_accesses]).reject{|a| @current_user.can_run?(a) }
    render(:layout => !request.xhr?)
  end


  # Make complex queries.
  #
  # Author:: Yann Azoury
  # Version:: 7
  # Last Update:: 2010-05-27 12:12:45 UTC
  # Status:: Validation Pending


  def adv_search

    redirect_to :action => :search
  end


  # Author:: Sylvain Abélard
  # Version:: 4
  # Last Update:: 2013-03-29 11:04:43 UTC
  # Status:: In Progress


  def preview

    @file_import = FileImport.find(params[:id])

    @fpath = @file_import.file__path
    if !File.exists?(@fpath)
      flash[:warning] = _("No file")
      redirect_to(:action => :list) and return
    end
    @file	   = @fpath
    @encoding  = params[:encoding] || SystemSetting['encoding'] || 'UTF-8'  # 'ISO-8859-1'
    @converter = Iconv.new('UTF-8//IGNORE', @encoding)
    @limit = (params[:limit] || 50).to_i
    @limit = 30 if @limit == 0
    File.open(@fpath, "r") {|file|
      firstline = @converter.iconv(file.gets)
      content   = @converter.iconv(file.read)

      # content   = @converter.iconv( params[:full] ? file.read :
      #    ((1..limit).to_a.inject("") {|x, y| x + file.gets.to_s })
      #  )

      counts = {}; [';', ',', "\t"].map{|car| counts[car] = firstline.count(car)}
      col_sep = ';'
      col_sep = ','  if counts[','] > counts[';']
      col_sep = "\t" if counts["\t"] > counts[';'] && counts["\t"] > counts[',']
      @columns = firstline.split(col_sep)
      @cells = FasterCSV.parse(content, {:col_sep => col_sep, :skip_blanks => true})
    }
  end


  # Author:: Sylvain Abélard
  # Version:: 2
  # Last Update:: 2013-03-29 11:11:58 UTC
  # Status:: In Progress


  def load

    if request.post?
      @file_import = FileImport.find_by_id(params[:id])
      if @file_import.nil?
        flash[:warning] ||= []
        flash[:warning] << _("Warning: %{obj} with ID %{id} does not exist!") % {:obj => 'file_import', :id => params[:id]}
        redirect_to(:action => :index)
        return
      end

      # TABLE SELECT

      mode = true
      if mode.is_a?(Hash) && mode[:error]
        flash[:warning] = _("Error : %{err}") % {:err => _(mode[:error])}
        redirect_to :action => :preview, :id => @file_import.id
        return
      end
      optz = {:user => @current_user}
      optz[:encoding] = params[:encoding] if params[:encoding]
      FileImport.file_import(@file_import, optz)
      if @results.is_a?(Hash) && @results[:error]
        flash[:warning] = _("Error : %{err}") % {:err => _(@results[:error])}
      else
        flash[:notice] = _("File loaded!")
      end
      @results
    end
    redirect_to(:action => :list) # show, :id => @file_import.id)
  end


  # This gives the list of all records
  #
  # Author:: Sylvain Abélard
  # Version:: 2
  # Last Update:: 2013-03-29 12:42:40 UTC
  # Status:: Requires Tests


  def list

    @restricted_fields = []
    pagin_opts = {:include => [:user,:file_import,:re_imports]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:file_imports_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'file_imports.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @file_imports = FileImport.paginate(pagin_opts)
    render(:xml => @file_imports.to_xml(:dasherize => false, :only => [:id,:file__name,:started_at,:completed_at,:read_lines,:wrote_records,:expected_total,:error_count,:log], :methods => [:user_human_display,:file_import_human_display,:re_imports_human_display])) and return if params[:format] == 'xml'
    render(:json => @file_imports) and return if params[:format] == 'json'
    render(:pdf => @file_imports, :action => :list) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["user", "file_import", "started_at", "completed_at", "read_lines", "wrote_records", "expected_total", "error_count"].include?(params[:group_by])
      @file_imports_groups = @file_imports.inject({}) { |acc,elt|
        crit = nil
        if ["user", "file_import"].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # This gives the list of all records
  #
  # Author:: Sylvain Abélard
  # Version:: 3
  # Last Update:: 2013-03-29 11:57:44 UTC
  # Status:: Requires Tests


  def source_files

    @restricted_fields = []
    pagin_opts = {:include => [:user,:file_import,:re_imports]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:file_imports_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'file_imports.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @file_imports = FileImport.having_file.paginate(pagin_opts)
    render(:xml => @file_imports.to_xml(:dasherize => false, :only => [:id,:file__name,:started_at,:completed_at,:read_lines,:wrote_records,:expected_total,:error_count,:log], :methods => [:user_human_display,:file_import_human_display,:re_imports_human_display])) and return if params[:format] == 'xml'
    render(:json => @file_imports) and return if params[:format] == 'json'
    render(:pdf => @file_imports, :action => :source_files) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["user", "file_import", "started_at", "completed_at", "read_lines", "wrote_records", "expected_total", "error_count"].include?(params[:group_by])
      @file_imports_groups = @file_imports.inject({}) { |acc,elt|
        crit = nil
        if ["user", "file_import"].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # This gives the list of all records
  #
  # Author:: Sylvain Abélard
  # Version:: 3
  # Last Update:: 2013-03-29 12:00:55 UTC
  # Status:: Requires Tests


  def running

    @restricted_fields = []
    pagin_opts = {:include => [:user,:file_import,:re_imports]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:file_imports_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'file_imports.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @file_imports = FileImport.having_started_at.no_completed_at.paginate(pagin_opts)
    render(:xml => @file_imports.to_xml(:dasherize => false, :only => [:id,:file__name,:started_at,:completed_at,:read_lines,:wrote_records,:expected_total,:error_count,:log], :methods => [:user_human_display,:file_import_human_display,:re_imports_human_display])) and return if params[:format] == 'xml'
    render(:json => @file_imports) and return if params[:format] == 'json'
    render(:pdf => @file_imports, :action => :running) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["user", "file_import", "started_at", "completed_at", "read_lines", "wrote_records", "expected_total", "error_count"].include?(params[:group_by])
      @file_imports_groups = @file_imports.inject({}) { |acc,elt|
        crit = nil
        if ["user", "file_import"].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end


  # This gives the list of all records
  #
  # Author:: Sylvain Abélard
  # Version:: 2
  # Last Update:: 2013-03-29 12:00:59 UTC
  # Status:: Requires Tests


  def complete

    @restricted_fields = []
    pagin_opts = {:include => [:user,:file_import,:re_imports]}
    pagin_opts[:page]	  = params[:page].to_i > 0 ? params[:page].to_i : 1
    pagin_opts[:per_page]	  = (params[:per_page] || cookies[:file_imports_per_page] || 50).to_i
    pagin_opts[:order]	  = @default_order if @default_order
    pagin_opts[:order]	||= 'file_imports.' +params[:sort_by] if !params[:sort_by].blank?
    pagin_opts[:conditions] ||= @default_filter if @default_filter
    pagin_opts[:conditions] ||= params[:conditions] if params[:conditions].is_a?(Hash)
    pagin_opts[:joins]	||= @joins_fields || []

    @file_imports = FileImport.having_completed_at.paginate(pagin_opts)
    render(:xml => @file_imports.to_xml(:dasherize => false, :only => [:id,:file__name,:started_at,:completed_at,:read_lines,:wrote_records,:expected_total,:error_count,:log], :methods => [:user_human_display,:file_import_human_display,:re_imports_human_display])) and return if params[:format] == 'xml'
    render(:json => @file_imports) and return if params[:format] == 'json'
    render(:pdf => @file_imports, :action => :complete) and return if params[:format] == 'pdf'
    if !params[:group_by].blank? && ["user", "file_import", "started_at", "completed_at", "read_lines", "wrote_records", "expected_total", "error_count"].include?(params[:group_by])
      @file_imports_groups = @file_imports.inject({}) { |acc,elt|
        crit = nil
        if ["user", "file_import"].include?(params[:group_by])
          crit = elt.send(params[:group_by]) ? elt.send(params[:group_by]).disp_name : nil
        else
          crit = elt.attributes[params[:group_by]]
        end
        acc[crit] ||= []
        acc[crit] << elt
        acc
      }
    end
  end
  protected
  private


  # Active Filters Data Context
  #
  # Author:: Yann Azoury
  # Last Update:: 2012-11-11 20:10:39 UTC


  def data_context_filter_1

    ckie = (RUBY_VERSION =~ /^1.8/) ? Iconv.new('UTF-8//IGNORE', 'latin1').iconv(cookies[:active_filters] || "") :  (cookies[:active_filters] || "").force_encoding(Encoding::ISO_8859_1).encode!(Encoding::UTF_8)
    if !ckie.blank?
      find_hash = FileImport.named_scope_active_filter_method(ActiveSupport::JSON.decode(ckie))
      conds = find_hash[:conditions]
      @joins_fields = find_hash[:joins]

      FileImport.send(:with_scope, {:find => {:conditions => conds, :joins => (@joins_fields || [])}}) {
        yield
      }

    else
      yield
    end
  end

  def faveod_cookies_loading
    @pres_mode = cookies["#{APP_SID}_file_imports_pres_mode"].to_sym unless cookies["#{APP_SID}_file_imports_pres_mode"].blank?
    @pres_mode = params["#{APP_SID}_file_imports_pres_mode"].to_sym unless params["#{APP_SID}_file_imports_pres_mode"].blank?
  end

end
